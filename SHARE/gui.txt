# GUI Module Files 
# This file contains all Python files from the src/gui/ directory 
# Generated by MCFax sharing script 
 
# --- START OF FILE: main_window.py --- 
 
"""
Main Window for MCFax Application
Provides the primary interface for fax management
"""

import os
import logging
from pathlib import Path
from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QPushButton, QLabel, QListWidget, QListWidgetItem, QGroupBox,
    QFileDialog, QMessageBox, QStatusBar, QMenuBar, QMenu,
    QSplitter, QTextEdit, QProgressBar
)
from PyQt6.QtCore import Qt, QTimer, pyqtSignal
from PyQt6.QtGui import QAction, QIcon, QFont

from .fax_job_window import FaxJobWindow
from .contact_window import ContactWindow
from .fax_history_window import FaxHistoryWindow
from pdf.pdf_browser import PDFBrowser
from pdf.pdf_viewer import PDFViewer
from pdf.pdf_editor import PDFEditor
from database.connection import DatabaseConnection
from database.models import ContactRepository, FaxJobRepository
from core.folder_watcher import FolderWatcher
from core.settings_portable import get_settings

class MainWindow(QMainWindow):
    """Main application window"""
    
    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(__name__)
        
        # Initialize settings
        self.settings = get_settings()
        
        # Initialize components
        self.db_connection = None
        self.contact_repo = None
        self.fax_job_repo = None
        self.pdf_browser = None
        self.temp_folder = None
        
        # Folder monitoring
        self.folder_watcher = None
        self.monitoring_enabled = self.settings.is_folder_monitoring_enabled()
        
        # Child windows
        self.fax_job_window = None
        self.contact_window = None
        
        # Setup UI
        self.setup_ui()
        self.load_window_settings()
        self.setup_database()
        self.setup_temp_folder()
        
        # Start smart periodic updates
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.smart_refresh_pdf_list)
        refresh_interval = self.settings.get_auto_refresh_interval()
        self.update_timer.start(refresh_interval)
    
    def setup_ui(self):
        """Setup the user interface"""
        self.setWindowTitle("MCFax - Fax Management System")
        self.setGeometry(100, 100, 1200, 800)
        
        # Create menu bar
        self.create_menu_bar()
        
        # Create status bar
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.status_bar.showMessage("Ready")
        
        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main layout
        main_layout = QHBoxLayout(central_widget)
        
        # Create splitter for resizable panels
        splitter = QSplitter(Qt.Orientation.Horizontal)
        main_layout.addWidget(splitter)
        
        # Left panel - PDF Browser
        left_panel = self.create_pdf_panel()
        splitter.addWidget(left_panel)
        
        # Right panel - Actions and Status
        right_panel = self.create_action_panel()
        splitter.addWidget(right_panel)
        
        # Set splitter proportions
        splitter.setSizes([600, 400])
    
    def create_menu_bar(self):
        """Create application menu bar"""
        menubar = self.menuBar()
        
        # File menu
        file_menu = menubar.addMenu('&File')
        
        # Select temp folder action
        select_folder_action = QAction('Select &Temp Folder...', self)
        select_folder_action.setShortcut('Ctrl+T')
        select_folder_action.triggered.connect(self.select_temp_folder)
        file_menu.addAction(select_folder_action)
        
        file_menu.addSeparator()
        
        # Exit action
        exit_action = QAction('E&xit', self)
        exit_action.setShortcut('Ctrl+Q')
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # Fax menu
        fax_menu = menubar.addMenu('&Fax')
        
        # New fax job action
        new_fax_action = QAction('&New Fax Job...', self)
        new_fax_action.setShortcut('Ctrl+N')
        new_fax_action.triggered.connect(self.create_new_fax_job)
        fax_menu.addAction(new_fax_action)
        
        fax_menu.addSeparator()
        
        # Fax history action
        history_action = QAction('Fax &History...', self)
        history_action.setShortcut('Ctrl+H')
        history_action.triggered.connect(self.open_fax_history)
        fax_menu.addAction(history_action)
        
        # Contacts menu
        contacts_menu = menubar.addMenu('&Contacts')
        
        # Manage contacts action
        manage_contacts_action = QAction('&Manage Contacts...', self)
        manage_contacts_action.setShortcut('Ctrl+M')
        manage_contacts_action.triggered.connect(self.open_contact_manager)
        contacts_menu.addAction(manage_contacts_action)
        
        # Tools menu
        tools_menu = menubar.addMenu('&Tools')
        
        # Settings action
        settings_action = QAction('&Settings...', self)
        settings_action.setShortcut('Ctrl+,')
        settings_action.triggered.connect(self.open_settings)
        tools_menu.addAction(settings_action)
        
        # Help menu
        help_menu = menubar.addMenu('&Help')
        
        # About action
        about_action = QAction('&About MCFax', self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
    
    def create_pdf_panel(self):
        """Create the PDF browser panel"""
        panel = QGroupBox("PDF Files")
        layout = QVBoxLayout(panel)
        
        # Folder selection
        folder_layout = QHBoxLayout()
        self.folder_label = QLabel("No temp folder selected")
        self.folder_label.setStyleSheet("QLabel { color: #666; font-style: italic; }")
        folder_layout.addWidget(self.folder_label)
        
        select_folder_btn = QPushButton("Select Folder")
        select_folder_btn.clicked.connect(self.select_temp_folder)
        folder_layout.addWidget(select_folder_btn)
        
        layout.addLayout(folder_layout)
        
        # PDF list
        self.pdf_list = QListWidget()
        self.pdf_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
        self.pdf_list.itemSelectionChanged.connect(self.on_pdf_selection_changed)
        layout.addWidget(self.pdf_list)
        
        # PDF actions
        pdf_actions_layout = QHBoxLayout()
        
        view_pdf_btn = QPushButton("View PDF")
        view_pdf_btn.clicked.connect(self.view_selected_pdf)
        pdf_actions_layout.addWidget(view_pdf_btn)
        
        edit_pdf_btn = QPushButton("Edit PDF")
        edit_pdf_btn.clicked.connect(self.edit_selected_pdf)
        pdf_actions_layout.addWidget(edit_pdf_btn)
        
        layout.addLayout(pdf_actions_layout)
        
        # PDF info
        self.pdf_info = QTextEdit()
        self.pdf_info.setMaximumHeight(100)
        self.pdf_info.setReadOnly(True)
        self.pdf_info.setPlaceholderText("Select PDF files to view information...")
        layout.addWidget(self.pdf_info)
        
        # Refresh button
        refresh_btn = QPushButton("Refresh PDF List")
        refresh_btn.clicked.connect(self.refresh_pdf_list)
        layout.addWidget(refresh_btn)
        
        return panel
    
    def create_action_panel(self):
        """Create the action panel"""
        panel = QGroupBox("Actions")
        layout = QVBoxLayout(panel)
        
        # New Fax Job section
        fax_group = QGroupBox("Fax Operations")
        fax_layout = QVBoxLayout(fax_group)
        
        self.new_fax_btn = QPushButton("Create New Fax Job")
        self.new_fax_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 10px;
                font-size: 14px;
                font-weight: bold;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:disabled {
                background-color: #cccccc;
                color: #666666;
            }
        """)
        self.new_fax_btn.clicked.connect(self.create_new_fax_job)
        self.new_fax_btn.setEnabled(False)
        fax_layout.addWidget(self.new_fax_btn)
        
        layout.addWidget(fax_group)
        
        # Contact Management section
        contact_group = QGroupBox("Contact Management")
        contact_layout = QVBoxLayout(contact_group)
        
        manage_contacts_btn = QPushButton("Manage Contacts")
        manage_contacts_btn.clicked.connect(self.open_contact_manager)
        contact_layout.addWidget(manage_contacts_btn)
        
        layout.addWidget(contact_group)
        
        # Status section
        status_group = QGroupBox("System Status")
        status_layout = QVBoxLayout(status_group)
        
        self.db_status_label = QLabel("Database: Not connected")
        self.folder_status_label = QLabel("Temp Folder: Not selected")
        self.pdf_count_label = QLabel("PDF Files: 0")
        
        status_layout.addWidget(self.db_status_label)
        status_layout.addWidget(self.folder_status_label)
        status_layout.addWidget(self.pdf_count_label)
        
        layout.addWidget(status_group)
        
        # Add stretch to push everything to top
        layout.addStretch()
        
        return panel
    
    def setup_database(self):
        """Setup database connection"""
        try:
            self.db_connection = DatabaseConnection()
            if self.db_connection.connect():
                self.contact_repo = ContactRepository(self.db_connection)
                self.fax_job_repo = FaxJobRepository(self.db_connection)
                self.db_status_label.setText("Database: Connected")
                self.db_status_label.setStyleSheet("QLabel { color: green; }")
                self.status_bar.showMessage("Database connected successfully")
                self.logger.info("Database connected successfully")
            else:
                self.db_status_label.setText("Database: Connection failed")
                self.db_status_label.setStyleSheet("QLabel { color: red; }")
                self.status_bar.showMessage("Database connection failed")
                self.logger.error("Failed to connect to database")
        except Exception as e:
            self.db_status_label.setText("Database: Error")
            self.db_status_label.setStyleSheet("QLabel { color: red; }")
            self.status_bar.showMessage(f"Database error: {str(e)}")
            self.logger.error(f"Database setup error: {e}")
    
    def load_window_settings(self):
        """Load window geometry and settings from persistent storage"""
        try:
            # Load window geometry
            geometry = self.settings.get_window_geometry()
            self.setGeometry(geometry['x'], geometry['y'], geometry['width'], geometry['height'])
            
            # Load maximized state
            if self.settings.is_window_maximized():
                self.showMaximized()
            
            # Load splitter sizes
            splitter_sizes = self.settings.get_splitter_sizes()
            # Note: We'll apply splitter sizes after the splitter is created
            
            self.logger.info("Window settings loaded from configuration")
            
        except Exception as e:
            self.logger.error(f"Error loading window settings: {e}")
    
    def save_window_settings(self):
        """Save current window geometry and settings"""
        try:
            # Save window geometry
            if not self.isMaximized():
                geometry = self.geometry()
                self.settings.set_window_geometry(
                    geometry.x(), geometry.y(), 
                    geometry.width(), geometry.height()
                )
            
            # Save maximized state
            self.settings.set_window_maximized(self.isMaximized())
            
            # Save splitter sizes (if splitter exists)
            central_widget = self.centralWidget()
            if central_widget:
                layout = central_widget.layout()
                if layout and layout.count() > 0:
                    splitter = layout.itemAt(0).widget()
                    if isinstance(splitter, QSplitter):
                        self.settings.set_splitter_sizes(splitter.sizes())
            
            # Save settings to file
            self.settings.save_settings()
            
            self.logger.info("Window settings saved")
            
        except Exception as e:
            self.logger.error(f"Error saving window settings: {e}")
    
    def setup_temp_folder(self):
        """Setup temp folder from settings or default"""
        # Try to load from settings first
        saved_temp_folder = self.settings.get_temp_folder()
        if saved_temp_folder and Path(saved_temp_folder).exists():
            self.set_temp_folder(saved_temp_folder)
            self.logger.info(f"Loaded temp folder from settings: {saved_temp_folder}")
            return
        
        # Try to use a default temp folder
        default_temp = Path.cwd() / "temp"
        if default_temp.exists():
            self.set_temp_folder(str(default_temp))
    
    def select_temp_folder(self):
        """Open folder selection dialog"""
        folder = QFileDialog.getExistingDirectory(
            self,
            "Select Temp Folder for PDF Files",
            str(Path.home()),
            QFileDialog.Option.ShowDirsOnly
        )
        
        if folder:
            self.set_temp_folder(folder)
    
    def set_temp_folder(self, folder_path):
        """Set the temp folder and update UI"""
        self.temp_folder = Path(folder_path)
        self.folder_label.setText(f"Temp Folder: {folder_path}")
        self.folder_label.setStyleSheet("QLabel { color: black; }")
        
        self.folder_status_label.setText(f"Temp Folder: {self.temp_folder.name}")
        self.folder_status_label.setStyleSheet("QLabel { color: green; }")
        
        # Save to settings
        self.settings.set_temp_folder(folder_path)
        self.settings.save_settings()
        
        # Initialize PDF browser
        self.pdf_browser = PDFBrowser(str(self.temp_folder))
        
        # Setup folder monitoring
        self.setup_folder_monitoring()
        
        # Refresh PDF list
        self.refresh_pdf_list()
        
        self.status_bar.showMessage(f"Temp folder set to: {folder_path}")
        self.logger.info(f"Temp folder set to: {folder_path}")
    
    def setup_folder_monitoring(self):
        """Setup automatic folder monitoring"""
        if not self.temp_folder or not self.monitoring_enabled:
            return
        
        try:
            # Stop existing watcher if any
            if self.folder_watcher:
                self.folder_watcher.stop_monitoring()
            
            # Create new folder watcher
            self.folder_watcher = FolderWatcher()
            
            # Configure folder watcher
            self.folder_watcher.set_folder(str(self.temp_folder), recursive=False)
            self.folder_watcher.set_callback(self.on_file_detected)
            
            # Start monitoring
            if self.folder_watcher.start_monitoring():
                self.logger.info(f"Started folder monitoring for: {self.temp_folder}")
            else:
                self.logger.error("Failed to start folder monitoring")
            
        except Exception as e:
            self.logger.error(f"Error setting up folder monitoring: {e}")
    
    def on_file_added(self, file_path):
        """Handle file added to monitored folder"""
        self.logger.info(f"File added: {file_path}")
        
        # Check if it's a PDF file
        if file_path.lower().endswith('.pdf'):
            self.status_bar.showMessage(f"New PDF detected: {Path(file_path).name}")
            
            # Refresh PDF list after a short delay to ensure file is fully written
            QTimer.singleShot(1000, self.refresh_pdf_list)
    
    def on_file_removed(self, file_path):
        """Handle file removed from monitored folder"""
        self.logger.info(f"File removed: {file_path}")
        
        if file_path.lower().endswith('.pdf'):
            self.status_bar.showMessage(f"PDF removed: {Path(file_path).name}")
            self.refresh_pdf_list()
    
    def on_file_detected(self, file_path):
        """Handle file detected by folder watcher"""
        self.logger.info(f"PDF file detected: {file_path}")
        
        # Check if it's a PDF file
        if file_path.lower().endswith('.pdf'):
            self.status_bar.showMessage(f"New PDF detected: {Path(file_path).name}")
            
            # Refresh PDF list after a short delay to ensure file is fully written
            QTimer.singleShot(1000, self.refresh_pdf_list)
    
    def smart_refresh_pdf_list(self):
        """Smart refresh that avoids interrupting user interactions"""
        # Check if user is actively interacting with the PDF list
        if (self.pdf_list.hasFocus() or 
            len(self.pdf_list.selectedItems()) > 0 or
            self.fax_job_window is not None):
            # User is busy - defer refresh for another 10 seconds
            QTimer.singleShot(10000, self.smart_refresh_pdf_list)
            return
        
        # Safe to refresh
        self.refresh_pdf_list()
    
    def refresh_pdf_list(self):
        """Refresh the PDF file list while preserving user selections"""
        if not self.pdf_browser:
            return
        
        try:
            # SAVE current selections before clearing
            selected_paths = []
            for item in self.pdf_list.selectedItems():
                selected_paths.append(item.data(Qt.ItemDataRole.UserRole))
            
            # Get PDF files
            pdf_files = self.pdf_browser.get_pdf_files()
            
            # Clear current list
            self.pdf_list.clear()
            
            # Add PDF files to list
            for pdf_file in pdf_files:
                item = QListWidgetItem(pdf_file.name)
                item.setData(Qt.ItemDataRole.UserRole, str(pdf_file.file_path))
                self.pdf_list.addItem(item)
                
                # RESTORE selection if this file was previously selected
                if str(pdf_file.file_path) in selected_paths:
                    item.setSelected(True)
            
            # Update status
            count = len(pdf_files)
            self.pdf_count_label.setText(f"PDF Files: {count}")
            
            # Update selection counter
            selected_count = len(selected_paths)
            if selected_count > 0:
                self.status_bar.showMessage(f"{selected_count} PDF file(s) selected")
            
            # Enable/disable new fax button
            self.new_fax_btn.setEnabled(count > 0 and self.db_connection is not None)
            
            if count > 0:
                self.pdf_count_label.setStyleSheet("QLabel { color: green; }")
            else:
                self.pdf_count_label.setStyleSheet("QLabel { color: #666; }")
                
        except Exception as e:
            self.logger.error(f"Error refreshing PDF list: {e}")
            self.status_bar.showMessage(f"Error refreshing PDF list: {str(e)}")
    
    def create_new_fax_job(self):
        """Create a new fax job"""
        if not self.pdf_browser or not self.db_connection:
            QMessageBox.warning(
                self,
                "Cannot Create Fax Job",
                "Please ensure both database connection and temp folder are configured."
            )
            return
        
        # Get selected PDFs
        selected_items = self.pdf_list.selectedItems()
        if not selected_items:
            QMessageBox.information(
                self,
                "No PDFs Selected",
                "Please select one or more PDF files to include in the fax job."
            )
            return
        
        # Get selected PDF paths
        selected_pdfs = []
        for item in selected_items:
            pdf_path = item.data(Qt.ItemDataRole.UserRole)
            selected_pdfs.append(pdf_path)
        
        # Open fax job window
        if self.fax_job_window:
            self.fax_job_window.close()
        
        self.fax_job_window = FaxJobWindow(
            selected_pdfs,
            self.contact_repo,
            self.fax_job_repo,
            self
        )
        self.fax_job_window.show()
    
    def open_contact_manager(self):
        """Open contact management window"""
        if not self.contact_repo:
            QMessageBox.warning(
                self,
                "Database Not Connected",
                "Please ensure database connection is established."
            )
            return
        
        if self.contact_window:
            self.contact_window.close()
        
        self.contact_window = ContactWindow(self.contact_repo, self)
        self.contact_window.show()
    
    def open_fax_history(self):
        """Open fax history window"""
        if not self.contact_repo or not self.fax_job_repo:
            QMessageBox.warning(
                self,
                "Database Not Connected",
                "Please ensure database connection is established."
            )
            return
        
        # Create and show fax history window
        history_window = FaxHistoryWindow(
            self.fax_job_repo,
            self.contact_repo,
            self
        )
        
        # Connect resend signal to handle fax resending
        history_window.fax_selected.connect(self.handle_fax_resend)
        
        history_window.exec()
    
    def handle_fax_resend(self, fax_job):
        """Handle fax resend request from history window"""
        try:
            # Check if the original PDF file still exists
            if fax_job.pdf_path and os.path.exists(fax_job.pdf_path):
                # Open fax job window with the original PDF
                if self.fax_job_window:
                    self.fax_job_window.close()
                
                self.fax_job_window = FaxJobWindow(
                    [fax_job.pdf_path],
                    self.contact_repo,
                    self.fax_job_repo,
                    self
                )
                
                # Pre-populate with original fax job data
                if hasattr(self.fax_job_window, 'populate_from_fax_job'):
                    self.fax_job_window.populate_from_fax_job(fax_job)
                
                self.fax_job_window.show()
            else:
                QMessageBox.warning(
                    self,
                    "PDF Not Found",
                    f"The original PDF file for this fax job could not be found:\n{fax_job.pdf_path or 'No path recorded'}\n\n"
                    "Please select the PDF files manually to resend this fax."
                )
                # Open empty fax job window
                self.create_new_fax_job()
                
        except Exception as e:
            self.logger.error(f"Error handling fax resend: {e}")
            QMessageBox.critical(
                self,
                "Resend Error",
                f"An error occurred while preparing to resend the fax:\n{str(e)}"
            )
    
    def on_pdf_selection_changed(self):
        """Handle PDF selection change"""
        selected_items = self.pdf_list.selectedItems()
        
        if not selected_items:
            self.pdf_info.clear()
            return
        
        # Show info for selected PDFs
        info_text = []
        for item in selected_items:
            pdf_path = item.data(Qt.ItemDataRole.UserRole)
            try:
                # Get file info
                file_path = Path(pdf_path)
                file_size = file_path.stat().st_size
                size_mb = file_size / (1024 * 1024)
                
                info_text.append(f"File: {file_path.name}")
                info_text.append(f"Size: {size_mb:.1f} MB")
                info_text.append(f"Path: {pdf_path}")
                info_text.append("-" * 40)
                
            except Exception as e:
                info_text.append(f"Error reading {pdf_path}: {e}")
                info_text.append("-" * 40)
        
        self.pdf_info.setText("\n".join(info_text))
    
    def view_selected_pdf(self):
        """View selected PDF"""
        selected_items = self.pdf_list.selectedItems()
        
        if not selected_items:
            QMessageBox.information(
                self,
                "No PDF Selected",
                "Please select a PDF file to view."
            )
            return
        
        if len(selected_items) > 1:
            QMessageBox.information(
                self,
                "Multiple PDFs Selected",
                "Please select only one PDF file to view."
            )
            return
        
        pdf_path = selected_items[0].data(Qt.ItemDataRole.UserRole)
        
        try:
            # Create and show PDF viewer dialog
            from pdf.pdf_viewer import PDFViewerDialog
            viewer = PDFViewerDialog(pdf_path, self)
            viewer.exec()
            
            self.status_bar.showMessage(f"Opened PDF viewer for: {Path(pdf_path).name}")
            
        except Exception as e:
            self.logger.error(f"Error opening PDF viewer: {e}")
            QMessageBox.critical(
                self,
                "PDF Viewer Error",
                f"Failed to open PDF viewer:\n{str(e)}"
            )
    
    def edit_selected_pdf(self):
        """Edit selected PDF"""
        selected_items = self.pdf_list.selectedItems()
        
        if not selected_items:
            QMessageBox.information(
                self,
                "No PDF Selected",
                "Please select a PDF file to edit."
            )
            return
        
        if len(selected_items) > 1:
            QMessageBox.information(
                self,
                "Multiple PDFs Selected",
                "Please select only one PDF file to edit."
            )
            return
        
        pdf_path = selected_items[0].data(Qt.ItemDataRole.UserRole)
        
        try:
            # Create and show PDF editor dialog
            from pdf.pdf_viewer import PDFViewerDialog
            editor = PDFViewerDialog(pdf_path, self)
            editor.exec()
            
            self.status_bar.showMessage(f"Opened PDF editor for: {Path(pdf_path).name}")
            
        except Exception as e:
            self.logger.error(f"Error opening PDF editor: {e}")
            QMessageBox.critical(
                self,
                "PDF Editor Error",
                f"Failed to open PDF editor:\n{str(e)}"
            )
    
    def open_settings(self):
        """Open settings configuration window"""
        try:
            from .settings_window import SettingsWindow
            
            settings_window = SettingsWindow(self)
            if settings_window.exec() == SettingsWindow.DialogCode.Accepted:
                # Settings were saved, update any relevant UI elements
                self.status_bar.showMessage("Settings updated successfully")
                self.logger.info("Settings updated by user")
                
                # Refresh monitoring settings if changed
                self.monitoring_enabled = self.settings.is_folder_monitoring_enabled()
                if self.temp_folder:
                    self.setup_folder_monitoring()
                
                # Update refresh timer interval if changed
                new_interval = self.settings.get_auto_refresh_interval()
                if self.update_timer.interval() != new_interval:
                    self.update_timer.setInterval(new_interval)
                    self.logger.info(f"Updated refresh interval to {new_interval}ms")
            
        except Exception as e:
            self.logger.error(f"Error opening settings window: {e}")
            QMessageBox.critical(
                self,
                "Settings Error",
                f"Failed to open settings window:\n{str(e)}"
            )
    
    def show_about(self):
        """Show about dialog"""
        QMessageBox.about(
            self,
            "About MCFax",
            """
            <h3>MCFax - Fax Management System</h3>
            <p>Version 1.0.0</p>
            <p>A comprehensive fax management solution for MultiTech FaxFinder FF240.R1</p>
            <p><b>Features:</b></p>
            <ul>
                <li>PDF processing and editing</li>
                <li>Cover page generation</li>
                <li>Contact management</li>
                <li>Fax job tracking</li>
                <li>FaxFinder integration</li>
                <li>Settings management</li>
            </ul>
            <p>© 2025 MCFax Solutions</p>
            """
        )
    
    def closeEvent(self, event):
        """Handle application close event"""
        # Save window settings before closing
        self.save_window_settings()
        
        # Stop folder monitoring
        if self.folder_watcher:
            self.folder_watcher.stop_monitoring()
            self.logger.info("Folder monitoring stopped")
        
        # Close child windows
        if self.fax_job_window:
            self.fax_job_window.close()
        if self.contact_window:
            self.contact_window.close()
        
        # Close database connection
        if self.db_connection and hasattr(self.db_connection, 'disconnect'):
            self.db_connection.disconnect()
        
        self.logger.info("MCFax Application closed")
        event.accept()
 
# --- END OF FILE: main_window.py --- 
 
# --- START OF FILE: fax_job_window.py --- 
 
"""
Fax Job Creation Window
Handles the creation and configuration of fax jobs
"""

import os
import logging
import base64
from pathlib import Path
from typing import List, Optional, Dict, Any
from PyQt6.QtWidgets import (
    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QPushButton, QLabel, QListWidget, QListWidgetItem, QGroupBox,
    QLineEdit, QTextEdit, QComboBox, QSpinBox, QCheckBox,
    QTabWidget, QScrollArea, QMessageBox, QProgressBar,
    QSplitter, QFrame, QSlider, QButtonGroup
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QFont, QPixmap, QPainter, QColor

from pdf.pdf_viewer import PDFViewer
from pdf.pdf_editor import PDFEditor
from pdf.pdf_processor import PDFProcessor
from pdf.cover_page import CoverPageGenerator
from database.models import Contact, FaxJob, CoverPageDetails, ContactRepository, FaxJobRepository
from fax.xml_generator import FaxXMLGenerator
from .integrated_pdf_viewer import IntegratedPDFViewer
from .progress_button import ProgressButton

class FaxJobWindow(QDialog):
    """Window for creating and configuring fax jobs"""
    
    def __init__(self, selected_pdfs: List[str], contact_repo: ContactRepository, 
                 fax_job_repo: FaxJobRepository, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(__name__)
        
        # Store dependencies
        self.selected_pdfs = selected_pdfs
        self.contact_repo = contact_repo
        self.fax_job_repo = fax_job_repo
        
        # Track edit data for each PDF
        self.pdf_edit_data = {}  # Maps PDF path to edit data
        
        # Initialize components
        self.pdf_viewer = None
        self.pdf_processor = PDFProcessor()
        self.cover_page_generator = CoverPageGenerator()
        self.xml_generator = FaxXMLGenerator()
        
        # Current state
        self.current_fax_job = FaxJob()
        self.contacts = []
        self.processed_pdf_path = None
        
        # Setup UI
        self.setup_ui()
        self.load_contacts()
        self.load_selected_pdfs()
        self.load_sender_info()
    
    def setup_ui(self):
        """Setup the user interface"""
        self.setWindowTitle("Create New Fax Job")
        self.setGeometry(150, 150, 1400, 900)
        self.setModal(True)
        
        # Main layout
        main_layout = QVBoxLayout(self)
        
        # Create tab widget
        self.tab_widget = QTabWidget()
        # Connect tab change signal to update summary automatically
        self.tab_widget.currentChanged.connect(self.on_tab_changed)
        main_layout.addWidget(self.tab_widget)
        
        # Create tabs
        self.create_pdf_tab()
        self.create_recipient_tab()
        self.create_cover_page_tab()
        self.create_preview_tab()
        
        # Button layout
        button_layout = QHBoxLayout()
        
        self.back_btn = QPushButton("< Back")
        self.back_btn.clicked.connect(self.previous_tab)
        button_layout.addWidget(self.back_btn)
        
        button_layout.addStretch()
        
        self.next_btn = QPushButton("Next >")
        self.next_btn.clicked.connect(self.next_tab)
        button_layout.addWidget(self.next_btn)
        
        # Submit button is now in the Preview Controls section
        # Keep this for backward compatibility but hide it
        self.submit_btn = QPushButton("Submit Fax Job")
        self.submit_btn.setVisible(False)  # Always hidden now
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        main_layout.addLayout(button_layout)
        
        # Update button states
        self.update_navigation_buttons()
    
    def create_pdf_tab(self):
        """Create PDF selection and editing tab"""
        tab = QWidget()
        layout = QHBoxLayout(tab)
        
        # Left panel - PDF list and controls (narrower)
        left_panel = QGroupBox("PDF Files")
        left_layout = QVBoxLayout(left_panel)
        
        # PDF list
        self.pdf_list = QListWidget()
        self.pdf_list.itemSelectionChanged.connect(self.on_pdf_selected)
        left_layout.addWidget(self.pdf_list)
        
        # PDF controls
        controls_layout = QVBoxLayout()
        
        self.remove_pdf_btn = QPushButton("Remove PDF")
        self.remove_pdf_btn.clicked.connect(self.remove_selected_pdf)
        self.remove_pdf_btn.setEnabled(False)
        controls_layout.addWidget(self.remove_pdf_btn)
        
        left_layout.addLayout(controls_layout)
        
        # PDF info (smaller)
        self.pdf_info_text = QTextEdit()
        self.pdf_info_text.setMaximumHeight(100)
        self.pdf_info_text.setReadOnly(True)
        self.pdf_info_text.setPlaceholderText("Select a PDF to view details...")
        left_layout.addWidget(self.pdf_info_text)
        
        layout.addWidget(left_panel, 1)  # Smaller proportion
        
        # Right panel - Integrated PDF viewer/editor (wider)
        right_panel = QGroupBox("PDF Viewer & Editor")
        right_layout = QVBoxLayout(right_panel)
        
        # PDF editing toolbar
        toolbar_layout = QHBoxLayout()
        
        # Page navigation
        self.prev_page_btn = QPushButton("◀ Previous")
        self.prev_page_btn.clicked.connect(self.previous_page)
        self.prev_page_btn.setEnabled(False)
        toolbar_layout.addWidget(self.prev_page_btn)
        
        self.page_label = QLabel("No PDF selected")
        toolbar_layout.addWidget(self.page_label)
        
        self.next_page_btn = QPushButton("Next ▶")
        self.next_page_btn.clicked.connect(self.next_page)
        self.next_page_btn.setEnabled(False)
        toolbar_layout.addWidget(self.next_page_btn)
        
        toolbar_layout.addStretch()
        
        # Zoom controls
        self.zoom_out_btn = QPushButton("Zoom Out")
        self.zoom_out_btn.clicked.connect(self.zoom_out)
        self.zoom_out_btn.setEnabled(False)
        toolbar_layout.addWidget(self.zoom_out_btn)
        
        self.zoom_label = QLabel("100%")
        toolbar_layout.addWidget(self.zoom_label)
        
        self.zoom_in_btn = QPushButton("Zoom In")
        self.zoom_in_btn.clicked.connect(self.zoom_in)
        self.zoom_in_btn.setEnabled(False)
        toolbar_layout.addWidget(self.zoom_in_btn)
        
        right_layout.addLayout(toolbar_layout)
        
        # PDF editing tools
        edit_toolbar_layout = QHBoxLayout()
        
        self.redact_btn = QPushButton("🖍️ Redact")
        self.redact_btn.clicked.connect(self.toggle_redact_mode)
        self.redact_btn.setEnabled(False)
        self.redact_btn.setCheckable(True)
        edit_toolbar_layout.addWidget(self.redact_btn)
        
        self.highlight_btn = QPushButton("🖍️ Highlight")
        self.highlight_btn.clicked.connect(self.toggle_highlight_mode)
        self.highlight_btn.setEnabled(False)
        self.highlight_btn.setCheckable(True)
        edit_toolbar_layout.addWidget(self.highlight_btn)
        
        self.text_btn = QPushButton("📝 Add Text")
        self.text_btn.clicked.connect(self.toggle_text_mode)
        self.text_btn.setEnabled(False)
        self.text_btn.setCheckable(True)
        edit_toolbar_layout.addWidget(self.text_btn)
        
        edit_toolbar_layout.addStretch()
        
        self.undo_btn = QPushButton("↶ Undo")
        self.undo_btn.clicked.connect(self.undo_edit)
        self.undo_btn.setEnabled(False)
        edit_toolbar_layout.addWidget(self.undo_btn)
        
        edit_toolbar_layout.addStretch()
        
        # Brush size controls
        edit_toolbar_layout.addWidget(QLabel("Brush Size:"))
        self.brush_size_slider = QSlider(Qt.Orientation.Horizontal)
        self.brush_size_slider.setRange(1, 50)
        self.brush_size_slider.setValue(10)
        self.brush_size_slider.setMaximumWidth(100)
        self.brush_size_slider.valueChanged.connect(self.update_brush_size)
        self.brush_size_slider.setEnabled(False)
        edit_toolbar_layout.addWidget(self.brush_size_slider)
        
        self.brush_size_label = QLabel("10px")
        edit_toolbar_layout.addWidget(self.brush_size_label)
        
        # Color selection buttons
        edit_toolbar_layout.addWidget(QLabel("Color:"))
        
        self.black_btn = QPushButton("Black")
        self.black_btn.setStyleSheet("QPushButton { background-color: black; color: white; }")
        self.black_btn.clicked.connect(lambda: self.set_brush_color(QColor(0, 0, 0)))
        self.black_btn.setEnabled(False)
        self.black_btn.setCheckable(True)
        self.black_btn.setChecked(True)
        edit_toolbar_layout.addWidget(self.black_btn)
        
        self.grey_btn = QPushButton("Grey")
        self.grey_btn.setStyleSheet("QPushButton { background-color: grey; color: white; }")
        self.grey_btn.clicked.connect(lambda: self.set_brush_color(QColor(128, 128, 128)))
        self.grey_btn.setEnabled(False)
        self.grey_btn.setCheckable(True)
        edit_toolbar_layout.addWidget(self.grey_btn)
        
        self.white_btn = QPushButton("White")
        self.white_btn.setStyleSheet("QPushButton { background-color: white; color: black; border: 1px solid black; }")
        self.white_btn.clicked.connect(lambda: self.set_brush_color(QColor(255, 255, 255)))
        self.white_btn.setEnabled(False)
        self.white_btn.setCheckable(True)
        edit_toolbar_layout.addWidget(self.white_btn)
        
        # Create button group for color selection
        self.color_button_group = QButtonGroup()
        self.color_button_group.addButton(self.black_btn)
        self.color_button_group.addButton(self.grey_btn)
        self.color_button_group.addButton(self.white_btn)
        
        edit_toolbar_layout.addStretch()
        
        self.exclude_page_btn = QPushButton("🚫 Exclude Page")
        self.exclude_page_btn.clicked.connect(self.toggle_page_exclusion)
        self.exclude_page_btn.setEnabled(False)
        self.exclude_page_btn.setCheckable(True)
        edit_toolbar_layout.addWidget(self.exclude_page_btn)
        
        self.save_pdf_btn = QPushButton("💾 Save PDF")
        self.save_pdf_btn.clicked.connect(self.save_pdf_edits)
        self.save_pdf_btn.setEnabled(False)
        edit_toolbar_layout.addWidget(self.save_pdf_btn)
        
        right_layout.addLayout(edit_toolbar_layout)
        
        # PDF viewer area
        self.pdf_viewer_container = QWidget()
        self.pdf_viewer_container.setMinimumHeight(400)
        self.pdf_viewer_container.setStyleSheet("""
            QWidget {
                background-color: #f0f0f0;
                border: 1px solid #ccc;
            }
        """)
        self.pdf_viewer_layout = QVBoxLayout(self.pdf_viewer_container)
        
        # Placeholder label
        self.pdf_placeholder_label = QLabel("Select a PDF file from the list to view and edit it here")
        self.pdf_placeholder_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.pdf_placeholder_label.setStyleSheet("color: #666; font-size: 14px; font-style: italic;")
        self.pdf_viewer_layout.addWidget(self.pdf_placeholder_label)
        
        scroll_area = QScrollArea()
        scroll_area.setWidget(self.pdf_viewer_container)
        scroll_area.setWidgetResizable(True)
        right_layout.addWidget(scroll_area)
        
        layout.addWidget(right_panel, 3)  # Larger proportion
        
        # Initialize PDF viewer state
        self.current_pdf_path = None
        self.current_page = 0
        self.zoom_level = 1.0
        self.pdf_viewer = None
        self.edit_mode = None  # 'redact', 'highlight', 'text', or None
        
        self.tab_widget.addTab(tab, "1. PDF Selection & Editing")
    
    def create_cover_page_tab(self):
        """Create cover page configuration tab"""
        tab = QWidget()
        main_layout = QHBoxLayout(tab)
        
        # Left side - Form controls (60% width)
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 10, 0)
        
        # Sender Information Section (Compact)
        sender_group = QGroupBox("Sender Information")
        sender_layout = QGridLayout(sender_group)
        sender_layout.setVerticalSpacing(8)
        sender_layout.setHorizontalSpacing(10)
        
        # From Name
        sender_layout.addWidget(QLabel("Name:"), 0, 0)
        self.from_name_edit = QLineEdit()
        sender_layout.addWidget(self.from_name_edit, 0, 1)
        
        # From Company
        sender_layout.addWidget(QLabel("Company:"), 1, 0)
        self.from_company_edit = QLineEdit()
        sender_layout.addWidget(self.from_company_edit, 1, 1)
        
        # From Phone
        sender_layout.addWidget(QLabel("Phone:"), 2, 0)
        self.from_phone_edit = QLineEdit()
        sender_layout.addWidget(self.from_phone_edit, 2, 1)
        
        # From Email
        sender_layout.addWidget(QLabel("Email:"), 3, 0)
        self.from_email_edit = QLineEdit()
        sender_layout.addWidget(self.from_email_edit, 3, 1)
        
        # Save sender info button
        save_sender_btn = QPushButton("Save as Default")
        save_sender_btn.clicked.connect(self.save_sender_info)
        sender_layout.addWidget(save_sender_btn, 4, 0, 1, 2)
        
        # Create aliases for backward compatibility
        self.sender_name_edit = self.from_name_edit
        self.sender_email_edit = self.from_email_edit
        
        left_layout.addWidget(sender_group)
        
        # Recipient Information Section (auto-filled, compact)
        recipient_group = QGroupBox("Recipient Information")
        recipient_layout = QGridLayout(recipient_group)
        recipient_layout.setVerticalSpacing(8)
        recipient_layout.setHorizontalSpacing(10)
        
        # To Name (auto-filled)
        recipient_layout.addWidget(QLabel("To:"), 0, 0)
        self.to_edit = QLineEdit()
        self.to_edit.setReadOnly(True)
        self.to_edit.setStyleSheet("background-color: #f0f0f0;")
        recipient_layout.addWidget(self.to_edit, 0, 1)
        
        # Fax Number (auto-filled)
        recipient_layout.addWidget(QLabel("Fax:"), 1, 0)
        self.fax_edit = QLineEdit()
        self.fax_edit.setReadOnly(True)
        self.fax_edit.setStyleSheet("background-color: #f0f0f0;")
        recipient_layout.addWidget(self.fax_edit, 1, 1)
        
        left_layout.addWidget(recipient_group)
        
        # Message Details Section (Compact)
        details_group = QGroupBox("Message Details")
        details_layout = QGridLayout(details_group)
        details_layout.setVerticalSpacing(8)
        details_layout.setHorizontalSpacing(10)
        
        # RE field
        details_layout.addWidget(QLabel("Re:"), 0, 0)
        self.re_edit = QLineEdit()
        details_layout.addWidget(self.re_edit, 0, 1)
        
        # Comments field (smaller)
        details_layout.addWidget(QLabel("Comments:"), 1, 0, Qt.AlignmentFlag.AlignTop)
        self.comments_edit = QTextEdit()
        self.comments_edit.setMaximumHeight(60)
        details_layout.addWidget(self.comments_edit, 1, 1)
        
        left_layout.addWidget(details_group)
        
        # Priority Options Section (Compact)
        priority_group = QGroupBox("Priority Options")
        priority_layout = QGridLayout(priority_group)
        priority_layout.setVerticalSpacing(5)
        priority_layout.setHorizontalSpacing(10)
        
        self.urgent_checkbox = QCheckBox("Urgent")
        self.for_review_checkbox = QCheckBox("For Review")
        self.please_comment_checkbox = QCheckBox("Please Comment")
        self.please_reply_checkbox = QCheckBox("Please Reply")
        
        priority_layout.addWidget(self.urgent_checkbox, 0, 0)
        priority_layout.addWidget(self.for_review_checkbox, 0, 1)
        priority_layout.addWidget(self.please_comment_checkbox, 1, 0)
        priority_layout.addWidget(self.please_reply_checkbox, 1, 1)
        
        left_layout.addWidget(priority_group)
        left_layout.addStretch()
        
        # Right side - Visual Preview (40% width)
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(10, 0, 0, 0)
        
        # Visual Preview Section
        preview_group = QGroupBox("Cover Page Preview")
        preview_layout = QVBoxLayout(preview_group)
        
        # Visual preview image area
        self.cover_preview_scroll = QScrollArea()
        self.cover_preview_scroll.setWidgetResizable(True)
        self.cover_preview_scroll.setMinimumHeight(280)
        self.cover_preview_scroll.setStyleSheet("""
            QScrollArea {
                background-color: #f8f8f8;
                border: 1px solid #ccc;
            }
        """)
        
        self.cover_preview_label = QLabel()
        self.cover_preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.cover_preview_label.setStyleSheet("""
            QLabel {
                background-color: white;
                border: 1px solid #ddd;
                margin: 5px;
            }
        """)
        self.cover_preview_label.setText("Visual preview will appear here")
        
        self.cover_preview_scroll.setWidget(self.cover_preview_label)
        preview_layout.addWidget(self.cover_preview_scroll)
        
        # Preview buttons
        preview_buttons_layout = QHBoxLayout()
        
        refresh_preview_btn = QPushButton("🔄 Refresh")
        refresh_preview_btn.clicked.connect(self.update_cover_visual_preview)
        preview_buttons_layout.addWidget(refresh_preview_btn)
        
        preview_buttons_layout.addStretch()
        
        preview_layout.addLayout(preview_buttons_layout)
        
        right_layout.addWidget(preview_group)
        
        # Add panels to main layout with proper proportions
        main_layout.addWidget(left_panel, 60)  # 60% width
        main_layout.addWidget(right_panel, 40)  # 40% width
        
        # Connect form fields to update preview on field exit
        self.from_name_edit.editingFinished.connect(self.update_cover_visual_preview)
        self.from_company_edit.editingFinished.connect(self.update_cover_visual_preview)
        self.from_phone_edit.editingFinished.connect(self.update_cover_visual_preview)
        self.re_edit.editingFinished.connect(self.update_cover_visual_preview)
        self.comments_edit.textChanged.connect(self.schedule_preview_update)
        self.urgent_checkbox.toggled.connect(self.update_cover_visual_preview)
        self.for_review_checkbox.toggled.connect(self.update_cover_visual_preview)
        self.please_comment_checkbox.toggled.connect(self.update_cover_visual_preview)
        self.please_reply_checkbox.toggled.connect(self.update_cover_visual_preview)
        
        # Initialize preview update timer for comments field
        self.preview_update_timer = QTimer()
        self.preview_update_timer.setSingleShot(True)
        self.preview_update_timer.timeout.connect(self.update_cover_visual_preview)
        
        # Initial preview update
        QTimer.singleShot(500, self.update_cover_visual_preview)
        
        self.tab_widget.addTab(tab, "3. Cover Page")
    
    def create_recipient_tab(self):
        """Create recipient selection tab"""
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        
        # Fax Job Settings Section (at top)
        settings_group = QGroupBox("Fax Job Settings")
        settings_layout = QGridLayout(settings_group)
        settings_layout.setVerticalSpacing(8)
        settings_layout.setHorizontalSpacing(15)
        
        # Priority
        settings_layout.addWidget(QLabel("Priority:"), 0, 0)
        self.priority_combo = QComboBox()
        self.priority_combo.addItems(["1st", "High", "Medium/High", "Medium", "Medium/Low", "Low"])
        self.priority_combo.setCurrentText("Medium")
        settings_layout.addWidget(self.priority_combo, 0, 1)
        
        # Max attempts
        settings_layout.addWidget(QLabel("Max Attempts:"), 0, 2)
        self.max_attempts_spin = QSpinBox()
        self.max_attempts_spin.setRange(1, 10)
        self.max_attempts_spin.setValue(3)
        settings_layout.addWidget(self.max_attempts_spin, 0, 3)
        
        # Retry interval
        settings_layout.addWidget(QLabel("Retry Interval:"), 1, 0)
        self.retry_interval_spin = QSpinBox()
        self.retry_interval_spin.setRange(1, 60)
        self.retry_interval_spin.setValue(5)
        self.retry_interval_spin.setSuffix(" minutes")
        settings_layout.addWidget(self.retry_interval_spin, 1, 1)
        
        # Add some spacing
        settings_layout.setColumnStretch(4, 1)
        
        main_layout.addWidget(settings_group)
        
        # Contact selection and details section
        contact_layout = QHBoxLayout()
        
        # Left panel - Contact selection
        left_panel = QGroupBox("Select Recipient")
        left_layout = QVBoxLayout(left_panel)
        
        # Contact search
        search_layout = QHBoxLayout()
        search_layout.addWidget(QLabel("Search:"))
        self.contact_search = QLineEdit()
        self.contact_search.textChanged.connect(self.filter_contacts)
        search_layout.addWidget(self.contact_search)
        left_layout.addLayout(search_layout)
        
        # Contact list
        self.contact_list = QListWidget()
        self.contact_list.itemSelectionChanged.connect(self.on_contact_selected)
        left_layout.addWidget(self.contact_list)
        
        # New contact button
        new_contact_btn = QPushButton("Add New Contact")
        new_contact_btn.clicked.connect(self.add_new_contact)
        left_layout.addWidget(new_contact_btn)
        
        contact_layout.addWidget(left_panel, 1)
        
        # Right panel - Contact details
        right_panel = QGroupBox("Contact Details")
        right_layout = QGridLayout(right_panel)
        
        # Contact form
        right_layout.addWidget(QLabel("Name:"), 0, 0)
        self.contact_name_edit = QLineEdit()
        right_layout.addWidget(self.contact_name_edit, 0, 1)
        
        right_layout.addWidget(QLabel("Fax Number:"), 1, 0)
        self.contact_fax_edit = QLineEdit()
        right_layout.addWidget(self.contact_fax_edit, 1, 1)
        
        right_layout.addWidget(QLabel("Organization:"), 2, 0)
        self.contact_org_edit = QLineEdit()
        right_layout.addWidget(self.contact_org_edit, 2, 1)
        
        right_layout.addWidget(QLabel("Phone:"), 3, 0)
        self.contact_phone_edit = QLineEdit()
        right_layout.addWidget(self.contact_phone_edit, 3, 1)
        
        right_layout.addWidget(QLabel("Email:"), 4, 0)
        self.contact_email_edit = QLineEdit()
        right_layout.addWidget(self.contact_email_edit, 4, 1)
        
        right_layout.addWidget(QLabel("Notes:"), 5, 0, Qt.AlignmentFlag.AlignTop)
        self.contact_notes_edit = QTextEdit()
        self.contact_notes_edit.setMaximumHeight(80)
        right_layout.addWidget(self.contact_notes_edit, 5, 1)
        
        # Save contact button
        save_contact_btn = QPushButton("Save Contact")
        save_contact_btn.clicked.connect(self.save_contact)
        right_layout.addWidget(save_contact_btn, 6, 0, 1, 2)
        
        contact_layout.addWidget(right_panel, 1)
        
        main_layout.addLayout(contact_layout)
        
        self.tab_widget.addTab(tab, "2. Recipient")
    
    
    def create_preview_tab(self):
        """Create preview and submission tab"""
        tab = QWidget()
        layout = QHBoxLayout(tab)
        
        # Left panel - Summary and controls
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        
        # Summary section (expanded - no height limit)
        summary_group = QGroupBox("Fax Job Summary")
        summary_layout = QVBoxLayout(summary_group)
        
        self.summary_text = QTextEdit()
        self.summary_text.setReadOnly(True)
        # Remove height limit to allow summary to expand
        summary_layout.addWidget(self.summary_text)
        
        left_layout.addWidget(summary_group, 3)  # Give summary more weight
        
        # Preview controls (pushed down)
        preview_controls_group = QGroupBox("Preview Controls")
        preview_controls_layout = QVBoxLayout(preview_controls_group)
        
        # Generate preview button (using custom progress button)
        self.generate_preview_btn = ProgressButton("🔄 Generate Final Preview")
        self.generate_preview_btn.clicked.connect(self.generate_final_preview)
        preview_controls_layout.addWidget(self.generate_preview_btn)
        
        # Preview navigation
        nav_layout = QHBoxLayout()
        
        self.preview_prev_btn = QPushButton("◀ Previous")
        self.preview_prev_btn.clicked.connect(self.preview_previous_page)
        self.preview_prev_btn.setEnabled(False)
        nav_layout.addWidget(self.preview_prev_btn)
        
        self.preview_page_label = QLabel("No preview generated")
        nav_layout.addWidget(self.preview_page_label)
        
        self.preview_next_btn = QPushButton("Next ▶")
        self.preview_next_btn.clicked.connect(self.preview_next_page)
        self.preview_next_btn.setEnabled(False)
        nav_layout.addWidget(self.preview_next_btn)
        
        preview_controls_layout.addLayout(nav_layout)
        
        # Zoom controls for preview
        zoom_layout = QHBoxLayout()
        
        self.preview_zoom_out_btn = QPushButton("Zoom Out")
        self.preview_zoom_out_btn.clicked.connect(self.preview_zoom_out)
        self.preview_zoom_out_btn.setEnabled(False)
        zoom_layout.addWidget(self.preview_zoom_out_btn)
        
        self.preview_zoom_label = QLabel("100%")
        zoom_layout.addWidget(self.preview_zoom_label)
        
        self.preview_zoom_in_btn = QPushButton("Zoom In")
        self.preview_zoom_in_btn.clicked.connect(self.preview_zoom_in)
        self.preview_zoom_in_btn.setEnabled(False)
        zoom_layout.addWidget(self.preview_zoom_in_btn)
        
        preview_controls_layout.addLayout(zoom_layout)
        
        # Add Submit Fax Job button to preview controls
        preview_controls_layout.addWidget(QLabel())  # Small spacer
        
        # Create the submit button here (moved from main button layout)
        self.preview_submit_btn = QPushButton("Submit Fax Job")
        self.preview_submit_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 12px 24px;
                font-size: 14px;
                font-weight: bold;
                border-radius: 5px;
                margin-top: 10px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        self.preview_submit_btn.clicked.connect(self.submit_fax_job)
        preview_controls_layout.addWidget(self.preview_submit_btn)
        
        left_layout.addWidget(preview_controls_group, 1)  # Give controls less weight
        
        layout.addWidget(left_panel, 1)  # 30% width
        
        # Right panel - Final PDF preview
        right_panel = QGroupBox("Final Fax Document Preview")
        right_layout = QVBoxLayout(right_panel)
        
        # Preview area
        self.final_preview_container = QWidget()
        self.final_preview_container.setMinimumHeight(500)
        self.final_preview_container.setStyleSheet("""
            QWidget {
                background-color: #f8f8f8;
                border: 1px solid #ccc;
            }
        """)
        self.final_preview_layout = QVBoxLayout(self.final_preview_container)
        
        # Placeholder label
        self.final_preview_placeholder = QLabel("Click 'Generate Final Preview' to see the complete fax document\n(Cover Page + Selected PDFs)")
        self.final_preview_placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.final_preview_placeholder.setStyleSheet("color: #666; font-size: 14px; font-style: italic;")
        self.final_preview_layout.addWidget(self.final_preview_placeholder)
        
        scroll_area = QScrollArea()
        scroll_area.setWidget(self.final_preview_container)
        scroll_area.setWidgetResizable(True)
        right_layout.addWidget(scroll_area)
        
        layout.addWidget(right_panel, 2)  # 70% width
        
        # Initialize preview state
        self.final_preview_pdf_path = None
        self.final_preview_viewer = None
        self.final_preview_current_page = 0
        self.final_preview_zoom_level = 1.0
        
        self.tab_widget.addTab(tab, "4. Preview & Submit")
    
    def load_contacts(self):
        """Load contacts from database"""
        try:
            self.contacts = self.contact_repo.get_all()
            self.update_contact_list()
        except Exception as e:
            self.logger.error(f"Error loading contacts: {e}")
            QMessageBox.warning(self, "Error", f"Failed to load contacts: {str(e)}")
    
    def update_contact_list(self):
        """Update the contact list widget"""
        self.contact_list.clear()
        search_term = self.contact_search.text().lower()
        
        for contact in self.contacts:
            if (not search_term or 
                search_term in contact.name.lower() or 
                search_term in contact.fax_number.lower() or 
                (contact.organization and search_term in contact.organization.lower())):
                
                item_text = f"{contact.name} - {contact.fax_number}"
                if contact.organization:
                    item_text += f" ({contact.organization})"
                
                item = QListWidgetItem(item_text)
                item.setData(Qt.ItemDataRole.UserRole, contact)
                self.contact_list.addItem(item)
    
    def filter_contacts(self):
        """Filter contacts based on search term"""
        self.update_contact_list()
    
    def on_contact_selected(self):
        """Handle contact selection"""
        current_item = self.contact_list.currentItem()
        if current_item:
            contact = current_item.data(Qt.ItemDataRole.UserRole)
            self.populate_contact_form(contact)
    
    def populate_contact_form(self, contact: Contact):
        """Populate contact form with contact data"""
        self.contact_name_edit.setText(contact.name or "")
        self.contact_fax_edit.setText(contact.fax_number or "")
        self.contact_org_edit.setText(contact.organization or "")
        self.contact_phone_edit.setText(contact.phone_number or "")
        self.contact_email_edit.setText(contact.email or "")
        self.contact_notes_edit.setText(contact.notes or "")
    
    def add_new_contact(self):
        """Add a new contact"""
        self.contact_list.clearSelection()
        self.contact_name_edit.clear()
        self.contact_fax_edit.clear()
        self.contact_org_edit.clear()
        self.contact_phone_edit.clear()
        self.contact_email_edit.clear()
        self.contact_notes_edit.clear()
        self.contact_name_edit.setFocus()
    
    def save_contact(self):
        """Save the current contact"""
        try:
            # Get current contact if editing
            current_item = self.contact_list.currentItem()
            contact = current_item.data(Qt.ItemDataRole.UserRole) if current_item else Contact()
            
            # Update contact data
            contact.name = self.contact_name_edit.text().strip()
            contact.fax_number = self.contact_fax_edit.text().strip()
            contact.organization = self.contact_org_edit.text().strip() or None
            contact.phone_number = self.contact_phone_edit.text().strip() or None
            contact.email = self.contact_email_edit.text().strip() or None
            contact.notes = self.contact_notes_edit.toPlainText().strip() or None
            
            # Validate
            errors = contact.validate()
            if errors:
                QMessageBox.warning(self, "Validation Error", "\n".join(errors))
                return
            
            # Save to database
            if contact.contact_id:
                # Update existing
                self.contact_repo.update(contact)
                QMessageBox.information(self, "Success", "Contact updated successfully")
            else:
                # Create new
                contact_id = self.contact_repo.create(contact)
                contact.contact_id = contact_id
                QMessageBox.information(self, "Success", "Contact created successfully")
            
            # Refresh contact list
            self.load_contacts()
            
        except Exception as e:
            self.logger.error(f"Error saving contact: {e}")
            QMessageBox.critical(self, "Error", f"Failed to save contact: {str(e)}")
    
    def load_selected_pdfs(self):
        """Load the selected PDF files"""
        self.pdf_list.clear()
        for pdf_path in self.selected_pdfs:
            item = QListWidgetItem(Path(pdf_path).name)
            item.setData(Qt.ItemDataRole.UserRole, pdf_path)
            self.pdf_list.addItem(item)
        
        self.update_pdf_info()
    
    def update_pdf_info(self):
        """Update PDF information display"""
        total_size = 0
        total_pages = 0
        file_count = len(self.selected_pdfs)
        
        info_text = f"Selected Files: {file_count}\n"
        
        for pdf_path in self.selected_pdfs:
            try:
                file_path = Path(pdf_path)
                size_mb = file_path.stat().st_size / (1024 * 1024)
                total_size += size_mb
                
                # Get page count (simplified for now)
                # TODO: Implement proper page counting with exclusions
                
            except Exception as e:
                self.logger.error(f"Error analyzing {pdf_path}: {e}")
        
        info_text += f"Total Size: {total_size:.1f} MB\n"
        info_text += f"Size Limit: 36.0 MB\n"
        
        if total_size > 36.0:
            info_text += "⚠️ WARNING: Size exceeds limit!"
        
        self.pdf_info_text.setText(info_text)
    
    def view_selected_pdf(self):
        """View/edit the selected PDF"""
        current_item = self.pdf_list.currentItem()
        if not current_item:
            QMessageBox.information(self, "No Selection", "Please select a PDF file to view.")
            return
        
        pdf_path = current_item.data(Qt.ItemDataRole.UserRole)
        
        try:
            # Create custom message box with clear options
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("PDF Action")
            msg_box.setText(f"What would you like to do with {Path(pdf_path).name}?")
            
            view_btn = msg_box.addButton("View PDF", QMessageBox.ButtonRole.YesRole)
            edit_btn = msg_box.addButton("Edit PDF", QMessageBox.ButtonRole.NoRole)
            cancel_btn = msg_box.addButton("Cancel", QMessageBox.ButtonRole.RejectRole)
            
            msg_box.setDefaultButton(view_btn)
            msg_box.exec()
            
            clicked_button = msg_box.clickedButton()
            
            if clicked_button == view_btn:
                # View PDF using dialog
                from pdf.pdf_viewer import PDFViewerDialog
                viewer = PDFViewerDialog(pdf_path, self)
                viewer.exec()
                self.logger.info(f"Opened PDF viewer for: {Path(pdf_path).name}")
                
            elif clicked_button == edit_btn:
                # Edit PDF using dialog
                from pdf.pdf_viewer import PDFViewerDialog
                editor = PDFViewerDialog(pdf_path, self)
                editor.exec()
                self.logger.info(f"Opened PDF editor for: {Path(pdf_path).name}")
                
            # Cancel - do nothing
            
        except Exception as e:
            self.logger.error(f"Error opening PDF viewer/editor: {e}")
            QMessageBox.critical(
                self,
                "PDF Error",
                f"Failed to open PDF viewer/editor:\n{str(e)}"
            )
    
    def remove_selected_pdf(self):
        """Remove the selected PDF from the list"""
        current_item = self.pdf_list.currentItem()
        if not current_item:
            QMessageBox.information(self, "No Selection", "Please select a PDF file to remove.")
            return
        
        pdf_path = current_item.data(Qt.ItemDataRole.UserRole)
        self.selected_pdfs.remove(pdf_path)
        
        row = self.pdf_list.row(current_item)
        self.pdf_list.takeItem(row)
        
        self.update_pdf_info()
    
    def preview_cover_page(self):
        """Preview the cover page"""
        # TODO: Implement cover page preview
        QMessageBox.information(self, "Cover Page Preview", "Cover page preview will be implemented here.")
    
    def next_tab(self):
        """Go to next tab"""
        current_index = self.tab_widget.currentIndex()
        
        # Save edits if leaving PDF tab
        if current_index == 0 and self.pdf_viewer and self.current_pdf_path:
            edit_data = self.pdf_viewer.get_edit_data()
            self.pdf_edit_data[self.current_pdf_path] = edit_data
        
        if current_index < self.tab_widget.count() - 1:
            self.tab_widget.setCurrentIndex(current_index + 1)
        self.update_navigation_buttons()

    def previous_tab(self):
        """Go to previous tab"""
        current_index = self.tab_widget.currentIndex()
        
        # Save edits if leaving PDF tab (though previous_tab typically doesn't leave PDF, but for safety)
        if current_index == 0 and self.pdf_viewer and self.current_pdf_path:
            edit_data = self.pdf_viewer.get_edit_data()
            self.pdf_edit_data[self.current_pdf_path] = edit_data
        
        if current_index > 0:
            self.tab_widget.setCurrentIndex(current_index - 1)
        self.update_navigation_buttons()
    
    def on_tab_changed(self, index: int):
        """Handle tab change events"""
        # Update navigation buttons
        self.update_navigation_buttons()
        
        # Auto-update summary when switching to Preview & Submit tab
        if index == self.tab_widget.count() - 1:  # Last tab (Preview & Submit)
            self.update_summary()
    
    def update_navigation_buttons(self):
        """Update navigation button states"""
        # Safety check to ensure buttons exist before trying to use them
        if not hasattr(self, 'back_btn') or not hasattr(self, 'next_btn'):
            return
        
        current_index = self.tab_widget.currentIndex()
        
        self.back_btn.setEnabled(current_index > 0)
        # Hide Next button on the final tab (Preview & Submit)
        self.next_btn.setVisible(current_index < self.tab_widget.count() - 1)
        # Submit button is now in Preview Controls section, always visible on final tab
    
    def update_summary(self):
        """Update the enhanced fax job summary with detailed information"""
        # Safety check to ensure summary_text widget exists
        if not hasattr(self, 'summary_text'):
            return
            
        try:
            summary = "Fax Job Summary:\n\n"
            
            # Recipient Information
            current_contact = self.contact_list.currentItem()
            if current_contact:
                contact = current_contact.data(Qt.ItemDataRole.UserRole)
                summary += "Recipient:\n"
                summary += f"• Name: {contact.name}\n"
                summary += f"• Fax: {contact.fax_number}\n"
                if contact.organization:
                    summary += f"• Organization: {contact.organization}\n"
                summary += "\n"
            else:
                summary += "Recipient: ⚠️ Not selected\n\n"
            
            # Document Information
            total_size_mb = 0.0
            total_pages = 0
            
            summary += "Documents:\n"
            summary += "• Cover Page: Included\n"
            summary += f"• PDF Files: {len(self.selected_pdfs)} files\n"
            
            # Calculate file sizes and estimate pages
            for pdf_path in self.selected_pdfs:
                try:
                    file_path = Path(pdf_path)
                    size_mb = file_path.stat().st_size / (1024 * 1024)
                    total_size_mb += size_mb
                    
                    # Try to get page count if PyMuPDF is available
                    try:
                        import fitz
                        doc = fitz.open(pdf_path)
                        pages = len(doc)
                        doc.close()
                        total_pages += pages
                        summary += f"  - {file_path.name} ({size_mb:.1f} MB, {pages} pages)\n"
                    except ImportError:
                        summary += f"  - {file_path.name} ({size_mb:.1f} MB)\n"
                    except Exception:
                        summary += f"  - {file_path.name} ({size_mb:.1f} MB)\n"
                        
                except Exception as e:
                    summary += f"  - {Path(pdf_path).name} (Error reading file)\n"
            
            # Add cover page to totals (estimate 1 page, ~0.1 MB)
            total_pages += 1
            total_size_mb += 0.1
            
            # Total information with size validation
            if total_pages > 0:
                summary += f"• Total Pages: {total_pages} pages\n"
            summary += f"• Total Size: {total_size_mb:.1f} MB / 36.0 MB limit\n"
            
            # Size warning
            if total_size_mb > 36.0:
                summary += "• ⚠️ WARNING: Size exceeds 36 MB limit!\n"
            elif total_size_mb > 30.0:
                summary += "• ⚠️ CAUTION: Approaching size limit\n"
            
            summary += "\n"
            
            # Settings Information
            summary += "Settings:\n"
            summary += f"• Priority: {self.priority_combo.currentText()}\n"
            summary += f"• Max Attempts: {self.max_attempts_spin.value()}\n"
            summary += f"• Retry Interval: {self.retry_interval_spin.value()} minutes\n"
            
            # Sender Information
            sender_name = self.sender_name_edit.text().strip()
            if sender_name:
                summary += f"• Sender: {sender_name}\n"
            else:
                summary += "• Sender: ⚠️ Not specified\n"
            
            # Validation Status
            summary += "\nValidation:\n"
            validation_errors = []
            
            if not self.selected_pdfs:
                validation_errors.append("No PDF files selected")
            if not current_contact:
                validation_errors.append("No recipient selected")
            if not sender_name:
                validation_errors.append("Sender name required")
            if total_size_mb > 36.0:
                validation_errors.append("File size exceeds limit")
            
            if validation_errors:
                summary += "• ❌ Issues found:\n"
                for error in validation_errors:
                    summary += f"  - {error}\n"
            else:
                summary += "• ✅ Ready to submit\n"
            
            self.summary_text.setText(summary)
            
        except Exception as e:
            self.logger.error(f"Error updating summary: {e}")
            self.summary_text.setText(f"Error generating summary: {str(e)}")
    
    def submit_fax_job(self):
        """Submit the fax job"""
        try:
            # Save current edits before submitting (if user is on PDF tab when submitting)
            if self.tab_widget.currentIndex() == 0 and self.pdf_viewer and self.current_pdf_path:
                edit_data = self.pdf_viewer.get_edit_data()
                self.pdf_edit_data[self.current_pdf_path] = edit_data
            
            # Validate all required fields
            if not self.validate_fax_job():
                return
            
            # Create fax job object
            fax_job = self.create_fax_job_object()
            
            # Step 1: Generate cover page and combine with PDFs
            final_pdf_path = self.generate_final_pdf(fax_job)
            if not final_pdf_path:
                QMessageBox.critical(self, "Error", "Failed to generate final PDF")
                return
            
            # Step 2: Check file size
            file_size_mb = Path(final_pdf_path).stat().st_size / (1024 * 1024)
            if file_size_mb > 36:
                response = QMessageBox.question(
                    self, 
                    "File Size Warning", 
                    f"The final PDF is {file_size_mb:.1f} MB, which exceeds the 36 MB limit.\n\n"
                    "Would you like to:\n"
                    "• Continue anyway (may fail)\n"
                    "• Cancel and remove some PDFs\n\n"
                    "Continue with oversized file?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No
                )
                
                if response == QMessageBox.StandardButton.No:
                    self.cleanup_temp_file(final_pdf_path)
                    return
            
            # Step 3: Update fax job with file paths and metadata
            fax_job.pdf_path = final_pdf_path
            fax_job.page_count = self.calculate_page_count(final_pdf_path)
            fax_job.file_size_mb = file_size_mb
            
            # Step 4: Save to database
            fax_id = self.fax_job_repo.create(fax_job)
            fax_job.fax_id = fax_id
            
            # Step 5: Generate local XML file for storage (with base64 content)
            xml_file_path = self.generate_xml_file_with_base64(fax_job, final_pdf_path)
            if xml_file_path:
                self.logger.info(f"Generated local XML file with base64: {xml_file_path}")
            else:
                self.logger.warning("Failed to generate local XML file")
            
            # Step 6: Submit to FaxFinder (if configured)
            # The FaxFinder API will generate its own XML with base64 content
            submission_result = self.submit_to_faxfinder(fax_job, final_pdf_path)
            
            # Step 7: Update status based on submission result
            if submission_result['success']:
                # Update database with submission details
                if submission_result.get('fax_entry_url'):
                    # Update the fax job with the FaxFinder entry URL
                    # Note: We'd need to add this method to the repository
                    pass
                
                QMessageBox.information(
                    self, 
                    "Success", 
                    f"Fax job created and submitted successfully!\n\n"
                    f"Fax ID: {fax_id}\n"
                    f"PDF: {Path(final_pdf_path).name}\n"
                    f"Size: {file_size_mb:.1f} MB\n"
                    f"Pages: {fax_job.page_count}"
                )
            else:
                # Update status to indicate submission failure
                self.fax_job_repo.update_status(fax_id, "Failed", submission_result.get('error', 'Unknown submission error'))
                
                QMessageBox.warning(
                    self, 
                    "Partial Success", 
                    f"Fax job created but FaxFinder submission failed:\n\n"
                    f"Error: {submission_result.get('error', 'Unknown error')}\n\n"
                    f"The job has been saved and can be resubmitted later.\n"
                    f"Fax ID: {fax_id}"
                )
            
            self.accept()
            
        except Exception as e:
            self.logger.error(f"Error submitting fax job: {e}")
            QMessageBox.critical(self, "Error", f"Failed to submit fax job: {str(e)}")
    
    def validate_fax_job(self) -> bool:
        """Validate the fax job before submission"""
        errors = []
        
        # Check PDFs
        if not self.selected_pdfs:
            errors.append("No PDF files selected")
        
        # Check recipient
        current_contact = self.contact_list.currentItem()
        if not current_contact:
            errors.append("No recipient selected")
        
        # Check sender
        if not self.sender_name_edit.text().strip():
            errors.append("Sender name is required")
        
        if errors:
            QMessageBox.warning(self, "Validation Error", "\n".join(errors))
            return False
        
        return True
    
    def create_fax_job_object(self) -> FaxJob:
        """Create a FaxJob object from the form data"""
        # Get selected contact
        current_contact = self.contact_list.currentItem()
        contact = current_contact.data(Qt.ItemDataRole.UserRole)
        
        # Create cover page details
        cover_page = CoverPageDetails(
            to=self.to_edit.text().strip() or None,
            from_field=self.from_name_edit.text().strip() or None,
            company=self.from_company_edit.text().strip() or None,
            fax=self.fax_edit.text().strip() or None,
            phone=self.from_phone_edit.text().strip() or None,
            re=self.re_edit.text().strip() or None,
            comments=self.comments_edit.toPlainText().strip() or None,
            urgent=self.urgent_checkbox.isChecked(),
            for_review=self.for_review_checkbox.isChecked(),
            please_comment=self.please_comment_checkbox.isChecked(),
            please_reply=self.please_reply_checkbox.isChecked()
        )
        
        # Create fax job
        fax_job = FaxJob(
            sender_name=self.sender_name_edit.text().strip(),
            sender_email=self.sender_email_edit.text().strip() or None,
            recipient_id=contact.contact_id,
            recipient_fax=contact.fax_number,
            priority=self.priority_combo.currentText(),
            max_attempts=self.max_attempts_spin.value(),
            retry_interval=self.retry_interval_spin.value(),
            cover_page_details=cover_page
        )
        
        return fax_job
    
    # New methods for integrated PDF viewer/editor functionality
    
    def on_pdf_selected(self):
        """Handle PDF selection from the list"""
        current_item = self.pdf_list.currentItem()
        if current_item:
            pdf_path = current_item.data(Qt.ItemDataRole.UserRole)
            
            # Save edits from previous PDF if it was loaded
            if self.pdf_viewer and self.current_pdf_path and pdf_path != self.current_pdf_path:
                edit_data = self.pdf_viewer.get_edit_data()
                self.pdf_edit_data[self.current_pdf_path] = edit_data
            
            self.load_pdf_in_viewer(pdf_path)
            self.remove_pdf_btn.setEnabled(True)
            
            # Update PDF info for selected file
            try:
                file_path = Path(pdf_path)
                size_mb = file_path.stat().st_size / (1024 * 1024)
                
                info_text = f"File: {file_path.name}\n"
                info_text += f"Size: {size_mb:.1f} MB\n"
                info_text += f"Path: {pdf_path}"
                
                self.pdf_info_text.setText(info_text)
                
            except Exception as e:
                self.pdf_info_text.setText(f"Error reading file info: {e}")
        else:
            self.clear_pdf_viewer()
            self.remove_pdf_btn.setEnabled(False)
            self.pdf_info_text.clear()
    
    def load_pdf_in_viewer(self, pdf_path: str):
        """Load a PDF file in the integrated viewer"""
        try:
            # Save current PDF path before changing it
            old_pdf_path = self.current_pdf_path
            
            # Update current PDF path
            self.current_pdf_path = pdf_path
            self.current_page = 0
            self.zoom_level = 1.0
            
            # Clear existing viewer (but don't save edit data since we already saved it in on_pdf_selected)
            self.clear_pdf_viewer_without_saving()
            
            # Hide placeholder
            self.pdf_placeholder_label.hide()
            
            # Create integrated PDF viewer widget
            self.pdf_viewer = IntegratedPDFViewer(pdf_path)
            
            # Connect signals
            self.pdf_viewer.page_changed.connect(self.on_viewer_page_changed)
            self.pdf_viewer.zoom_changed.connect(self.on_viewer_zoom_changed)
            
            # Connect edit signal to capture edit data
            if hasattr(self.pdf_viewer, 'pdf_edited'):
                self.pdf_viewer.pdf_edited.connect(self.on_pdf_edited)
            
            # Apply saved edit data if exists
            if pdf_path in self.pdf_edit_data:
                self.pdf_viewer.apply_edit_data(self.pdf_edit_data[pdf_path])
                self.logger.info(f"Applied saved edit data for {Path(pdf_path).name}")
            
            # Add to layout
            self.pdf_viewer_layout.addWidget(self.pdf_viewer)
            
            # Enable controls
            self.enable_pdf_controls(True)
            
            # Update zoom display to match the loaded zoom level
            self.zoom_level = self.pdf_viewer.zoom_level
            self.zoom_label.setText(f"{int(self.zoom_level * 100)}%")
            
            # Update page info with exclusion support
            self.update_page_info_with_exclusion()
            
            self.logger.info(f"Loaded PDF in integrated viewer: {Path(pdf_path).name}")
                
        except Exception as e:
            self.logger.error(f"Error loading PDF in viewer: {e}")
            self.show_pdf_error(f"Error loading PDF: {str(e)}")
    
    def clear_pdf_viewer(self):
        """Clear the PDF viewer"""
        # Save current edits before clearing
        if self.pdf_viewer and self.current_pdf_path:
            try:
                edit_data = self.pdf_viewer.get_edit_data()
                self.pdf_edit_data[self.current_pdf_path] = edit_data
                self.logger.info(f"Saved edit data for {Path(self.current_pdf_path).name} before clearing viewer")
            except Exception as e:
                self.logger.error(f"Error saving edit data before clearing viewer: {e}")
        
        # Remove existing viewer widget
        for i in reversed(range(self.pdf_viewer_layout.count())):
            child = self.pdf_viewer_layout.itemAt(i).widget()
            if child and child != self.pdf_placeholder_label:
                child.setParent(None)
        
        # Show placeholder
        self.pdf_placeholder_label.show()
        
        # Disable controls
        self.enable_pdf_controls(False)
        
        # Reset state
        self.current_pdf_path = None
        self.current_page = 0
        self.zoom_level = 1.0
        self.pdf_viewer = None
        self.edit_mode = None
        
        # Reset button states
        self.redact_btn.setChecked(False)
        self.highlight_btn.setChecked(False)
        self.text_btn.setChecked(False)
    
    def clear_pdf_viewer_without_saving(self):
        """Clear the PDF viewer without saving edit data (used when we already saved it)"""
        # Remove existing viewer widget
        for i in reversed(range(self.pdf_viewer_layout.count())):
            child = self.pdf_viewer_layout.itemAt(i).widget()
            if child and child != self.pdf_placeholder_label:
                child.setParent(None)
        
        # Show placeholder
        self.pdf_placeholder_label.show()
        
        # Disable controls
        self.enable_pdf_controls(False)
        
        # Reset state (but don't save edit data)
        self.pdf_viewer = None
        self.edit_mode = None
        
        # Reset button states
        self.redact_btn.setChecked(False)
        self.highlight_btn.setChecked(False)
        self.text_btn.setChecked(False)
    
    def enable_pdf_controls(self, enabled: bool):
        """Enable or disable PDF controls"""
        self.prev_page_btn.setEnabled(enabled)
        self.next_page_btn.setEnabled(enabled)
        self.zoom_out_btn.setEnabled(enabled)
        self.zoom_in_btn.setEnabled(enabled)
        self.redact_btn.setEnabled(enabled)
        self.highlight_btn.setEnabled(enabled)
        self.text_btn.setEnabled(enabled)
        self.undo_btn.setEnabled(enabled)
        self.exclude_page_btn.setEnabled(enabled)
        self.save_pdf_btn.setEnabled(enabled)
        
        # Enable brush controls
        self.brush_size_slider.setEnabled(enabled)
        self.black_btn.setEnabled(enabled)
        self.grey_btn.setEnabled(enabled)
        self.white_btn.setEnabled(enabled)
        
        if not enabled:
            self.page_label.setText("No PDF selected")
            self.zoom_label.setText("100%")
    
    def update_page_info(self):
        """Update page information display"""
        if self.pdf_viewer and self.current_pdf_path:
            total_pages = self.pdf_viewer.get_page_count()
            current_page_display = self.current_page + 1  # Display 1-based
            self.page_label.setText(f"Page {current_page_display} of {total_pages}")
            
            # Update navigation buttons
            self.prev_page_btn.setEnabled(self.current_page > 0)
            self.next_page_btn.setEnabled(self.current_page < total_pages - 1)
        else:
            self.page_label.setText("No PDF selected")
    
    def show_pdf_error(self, message: str):
        """Show an error message in the PDF viewer area"""
        self.clear_pdf_viewer()
        error_label = QLabel(f"❌ {message}")
        error_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        error_label.setStyleSheet("color: red; font-size: 14px;")
        self.pdf_viewer_layout.addWidget(error_label)
    
    def previous_page(self):
        """Go to previous page"""
        if self.pdf_viewer and self.current_page > 0:
            try:
                # Store current zoom level before navigation
                current_zoom = self.zoom_level
                
                self.current_page -= 1
                self.pdf_viewer.go_to_page(self.current_page)
                
                # Always restore zoom level after page navigation
                self.pdf_viewer.set_zoom(current_zoom)
                self.zoom_level = current_zoom
                self.zoom_label.setText(f"{int(current_zoom * 100)}%")
                
                self.update_page_info_with_exclusion()
                self.logger.info(f"Navigated to page {self.current_page + 1}, zoom maintained at {int(current_zoom * 100)}%")
            except RuntimeError as e:
                if "wrapped C/C++ object" in str(e):
                    self.logger.warning(f"PDF viewer widget was deleted, reloading PDF: {e}")
                    # Try to reload the PDF viewer
                    if self.current_pdf_path:
                        self.load_pdf_in_viewer(self.current_pdf_path)
                else:
                    raise e
    
    def next_page(self):
        """Go to next page"""
        if self.pdf_viewer:
            total_pages = self.pdf_viewer.get_page_count()
            if self.current_page < total_pages - 1:
                # Store current zoom level before navigation
                current_zoom = self.zoom_level
                
                self.current_page += 1
                self.pdf_viewer.go_to_page(self.current_page)
                
                # Always restore zoom level after page navigation
                self.pdf_viewer.set_zoom(current_zoom)
                self.zoom_level = current_zoom
                self.zoom_label.setText(f"{int(current_zoom * 100)}%")
                
                self.update_page_info_with_exclusion()
                self.logger.info(f"Navigated to page {self.current_page + 1}, zoom maintained at {int(current_zoom * 100)}%")
    
    def zoom_in(self):
        """Zoom in on the PDF"""
        if self.pdf_viewer:
            new_zoom = min(self.zoom_level * 1.25, 5.0)  # Max 500%
            self.zoom_level = new_zoom
            self.pdf_viewer.set_zoom(new_zoom)
            self.zoom_label.setText(f"{int(new_zoom * 100)}%")
            self.logger.debug(f"Zoom in: set to {new_zoom:.2f}")
    
    def zoom_out(self):
        """Zoom out on the PDF"""
        if self.pdf_viewer:
            new_zoom = max(self.zoom_level / 1.25, 0.25)  # Min 25%
            self.zoom_level = new_zoom
            self.pdf_viewer.set_zoom(new_zoom)
            self.zoom_label.setText(f"{int(new_zoom * 100)}%")
            self.logger.debug(f"Zoom out: set to {new_zoom:.2f}")
    
    def toggle_redact_mode(self):
        """Toggle redaction mode"""
        if self.redact_btn.isChecked():
            self.edit_mode = 'redaction'
            # Uncheck other modes
            self.highlight_btn.setChecked(False)
            self.text_btn.setChecked(False)
            
            if self.pdf_viewer:
                self.pdf_viewer.set_edit_mode('redaction')
        else:
            self.edit_mode = None
            if self.pdf_viewer:
                self.pdf_viewer.set_edit_mode(None)
    
    def toggle_highlight_mode(self):
        """Toggle highlight mode"""
        if self.highlight_btn.isChecked():
            self.edit_mode = 'highlight'
            # Uncheck other modes
            self.redact_btn.setChecked(False)
            self.text_btn.setChecked(False)
            
            # Set yellow color for highlighting
            highlight_color = QColor(255, 255, 0)  # Yellow
            if self.pdf_viewer:
                self.pdf_viewer.set_edit_mode('highlight')
                self.pdf_viewer.set_brush_color(highlight_color)
            
            # Update color button states to show yellow is selected
            self.black_btn.setChecked(False)
            self.grey_btn.setChecked(False)
            self.white_btn.setChecked(False)
        else:
            self.edit_mode = None
            if self.pdf_viewer:
                self.pdf_viewer.set_edit_mode(None)
    
    def toggle_text_mode(self):
        """Toggle text addition mode"""
        if self.text_btn.isChecked():
            self.edit_mode = 'text'
            # Uncheck other modes
            self.redact_btn.setChecked(False)
            self.highlight_btn.setChecked(False)
            
            if self.pdf_viewer:
                self.pdf_viewer.set_edit_mode('text')
        else:
            self.edit_mode = None
            if self.pdf_viewer:
                self.pdf_viewer.set_edit_mode(None)
    
    def undo_edit(self):
        """Undo the last edit"""
        if self.pdf_viewer:
            self.pdf_viewer.undo_last_edit()
    
    def toggle_page_exclusion(self):
        """Toggle exclusion of current page"""
        if self.pdf_viewer:
            self.pdf_viewer.toggle_page_exclusion()
            
            # Update button state
            is_excluded = self.pdf_viewer.is_page_excluded(self.current_page)
            self.exclude_page_btn.setChecked(is_excluded)
            
            # Update page info to show exclusion status
            self.update_page_info_with_exclusion()
    
    def update_page_info_with_exclusion(self):
        """Update page info including exclusion status"""
        if self.pdf_viewer and self.current_pdf_path:
            total_pages = self.pdf_viewer.get_page_count()
            current_page_display = self.current_page + 1  # Display 1-based
            
            # Check if current page is excluded
            is_excluded = self.pdf_viewer.is_page_excluded(self.current_page)
            excluded_count = len(self.pdf_viewer.get_excluded_pages())
            included_count = self.pdf_viewer.get_included_page_count()
            
            page_text = f"Page {current_page_display} of {total_pages}"
            if is_excluded:
                page_text += " (EXCLUDED)"
            
            if excluded_count > 0:
                page_text += f" • {included_count} pages will be faxed"
            
            self.page_label.setText(page_text)
            
            # Update navigation buttons
            self.prev_page_btn.setEnabled(self.current_page > 0)
            self.next_page_btn.setEnabled(self.current_page < total_pages - 1)
        else:
            self.page_label.setText("No PDF selected")
    
    def save_pdf_edits(self):
        """Save PDF edits"""
        if self.pdf_viewer and self.current_pdf_path:
            try:
                # Save the edited PDF
                if self.pdf_viewer.save_pdf():
                    QMessageBox.information(self, "Success", "PDF edits saved successfully!")
                    self.logger.info(f"Saved PDF edits for: {Path(self.current_pdf_path).name}")
                else:
                    QMessageBox.warning(self, "Save Failed", "Failed to save PDF edits.")
                    
            except Exception as e:
                self.logger.error(f"Error saving PDF edits: {e}")
                QMessageBox.critical(self, "Save Error", f"Error saving PDF edits:\n{str(e)}")
    
    def update_page_info_simple(self, pages):
        """Update page info with simple page count"""
        if pages != 'Unknown':
            self.page_label.setText(f"PDF loaded • {pages} pages")
        else:
            self.page_label.setText("PDF loaded")
    
    def on_pdf_edited(self, edit_info: Dict[str, Any]):
        """Handle PDF edits from the integrated viewer"""
        if self.current_pdf_path:
            # Store edit data for this PDF
            self.pdf_edit_data[self.current_pdf_path] = edit_info
            self.logger.info(f"Captured edit data for {Path(self.current_pdf_path).name}")
    
    def _save_current_pdf_edits(self):
        """Save current PDF edits to the edit data map"""
        if self.pdf_viewer and self.current_pdf_path:
            try:
                edit_data = self.pdf_viewer.get_edit_data()
                self.pdf_edit_data[self.current_pdf_path] = edit_data
                self.logger.info(f"Saved current PDF edits for {Path(self.current_pdf_path).name}")
            except Exception as e:
                self.logger.error(f"Error saving current PDF edits: {e}")
    
    def open_full_pdf_editor(self, pdf_path: str):
        """Open the full PDF editor dialog"""
        try:
            from pdf.pdf_viewer import PDFViewerDialog
            editor_dialog = PDFViewerDialog(pdf_path, self)
            
            # Connect to capture edits when dialog closes
            editor_dialog.edits_applied.connect(lambda edit_info: self.on_pdf_edited(edit_info))
            
            if editor_dialog.exec() == QDialog.DialogCode.Accepted:
                QMessageBox.information(self, "PDF Editor", "PDF editor closed. Any changes have been applied.")
                self.logger.info(f"PDF editor closed for: {Path(pdf_path).name}")
            
        except Exception as e:
            self.logger.error(f"Error opening full PDF editor: {e}")
            QMessageBox.critical(self, "Editor Error", f"Failed to open PDF editor:\n{str(e)}")
    
    def on_viewer_page_changed(self, page_number: int):
        """Handle page change from the integrated viewer"""
        self.current_page = page_number
        self.update_page_info()
    
    def on_viewer_zoom_changed(self, zoom_level: float):
        """Handle zoom change from the integrated viewer"""
        self.zoom_level = zoom_level
        self.zoom_label.setText(f"{int(zoom_level * 100)}%")
        self.logger.debug(f"Zoom level synchronized: {zoom_level:.2f}")
    
    def update_brush_size(self, size: int):
        """Update brush size for PDF editing"""
        self.brush_size_label.setText(f"{size}px")
        if self.pdf_viewer:
            self.pdf_viewer.set_brush_size(size)
    
    def set_brush_color(self, color: QColor):
        """Set brush color for PDF editing"""
        if self.pdf_viewer:
            self.pdf_viewer.set_brush_color(color)
        
        # Update button states to show which color is selected
        self.black_btn.setChecked(color == QColor(0, 0, 0))
        self.grey_btn.setChecked(color == QColor(128, 128, 128))
        self.white_btn.setChecked(color == QColor(255, 255, 255))
    
    def load_sender_info(self):
        """Load sender information from settings"""
        try:
            from core.settings import get_settings
            settings = get_settings()
            sender_info = settings.get_sender_info()
            
            # Populate sender fields
            self.from_name_edit.setText(sender_info.get('from_name', ''))
            self.from_company_edit.setText(sender_info.get('from_company', 'The Spine Hospital Louisiana'))
            self.from_phone_edit.setText(sender_info.get('from_phone', '(225) 906-4805'))
            
            self.logger.info("Loaded sender information from settings")
            
        except Exception as e:
            self.logger.error(f"Error loading sender info: {e}")
            # Set defaults if loading fails
            self.from_company_edit.setText('The Spine Hospital Louisiana')
            self.from_phone_edit.setText('(225) 906-4805')
    
    def save_sender_info(self):
        """Save sender information to settings"""
        try:
            from core.settings import get_settings
            settings = get_settings()
            
            # Save sender information
            settings.set_sender_info(
                from_name=self.from_name_edit.text().strip(),
                from_company=self.from_company_edit.text().strip(),
                from_phone=self.from_phone_edit.text().strip()
            )
            
            # Save settings to file
            settings.save_settings()
            
            QMessageBox.information(self, "Success", "Sender information saved as default!")
            self.logger.info("Saved sender information to settings")
            
        except Exception as e:
            self.logger.error(f"Error saving sender info: {e}")
            QMessageBox.warning(self, "Error", f"Failed to save sender information: {str(e)}")
    
    def on_contact_selected(self):
        """Handle contact selection and auto-populate recipient fields"""
        current_item = self.contact_list.currentItem()
        if current_item:
            contact = current_item.data(Qt.ItemDataRole.UserRole)
            
            # Populate contact form
            self.populate_contact_form(contact)
            
            # Auto-populate recipient fields in cover page tab
            self.to_edit.setText(contact.name or "")
            self.fax_edit.setText(contact.fax_number or "")
            
            self.logger.info(f"Selected contact: {contact.name} - {contact.fax_number}")
            
            # Update cover page preview when contact is selected
            self.update_cover_preview()
    
    def update_cover_preview(self):
        """Update the visual cover page preview (text preview removed)"""
        # This method now just calls the visual preview update
        self.update_cover_visual_preview()
    
    def generate_cover_pdf_preview(self):
        """Generate a PDF preview of the cover page"""
        try:
            # Create cover page details from current form data
            cover_details = CoverPageDetails(
                to=self.to_edit.text().strip() or None,
                from_field=self.from_name_edit.text().strip() or None,
                company=self.from_company_edit.text().strip() or None,
                fax=self.fax_edit.text().strip() or None,
                phone=self.from_phone_edit.text().strip() or None,
                re=self.re_edit.text().strip() or None,
                comments=self.comments_edit.toPlainText().strip() or None,
                urgent=self.urgent_checkbox.isChecked(),
                for_review=self.for_review_checkbox.isChecked(),
                please_comment=self.please_comment_checkbox.isChecked(),
                please_reply=self.please_reply_checkbox.isChecked()
            )
            
            # Generate PDF preview
            preview_path = "cover_page_preview.pdf"
            success = self.cover_page_generator.generate_cover_page(
                cover_details=cover_details,
                output_path=preview_path,
                page_count=len(self.selected_pdfs)
            )
            
            if success:
                # Open the PDF preview
                import subprocess
                subprocess.run(["start", preview_path], shell=True, check=False)
                QMessageBox.information(self, "Preview Generated", f"Cover page preview saved as: {preview_path}")
            else:
                QMessageBox.warning(self, "Preview Failed", "Failed to generate PDF preview.")
                
        except Exception as e:
            self.logger.error(f"Error generating PDF preview: {e}")
            QMessageBox.critical(self, "Preview Error", f"Error generating PDF preview:\n{str(e)}")
    
    def schedule_preview_update(self):
        """Schedule a preview update after a delay (for text fields)"""
        self.preview_update_timer.stop()
        self.preview_update_timer.start(1000)  # 1 second delay
    
    def update_cover_previews(self):
        """Update both text and visual cover page previews"""
        self.update_cover_preview()  # Update text preview
        self.update_cover_visual_preview()  # Update visual preview
    
    def update_cover_visual_preview(self):
        """Update the visual cover page preview"""
        try:
            # Create cover page details from current form data
            cover_details = CoverPageDetails(
                to=self.to_edit.text().strip() or None,
                from_field=self.from_name_edit.text().strip() or None,
                company=self.from_company_edit.text().strip() or None,
                fax=self.fax_edit.text().strip() or None,
                phone=self.from_phone_edit.text().strip() or None,
                re=self.re_edit.text().strip() or None,
                comments=self.comments_edit.toPlainText().strip() or None,
                urgent=self.urgent_checkbox.isChecked(),
                for_review=self.for_review_checkbox.isChecked(),
                please_comment=self.please_comment_checkbox.isChecked(),
                please_reply=self.please_reply_checkbox.isChecked()
            )
            
            # Generate temporary PDF for preview
            temp_preview_path = "temp_cover_preview.pdf"
            logo_path = r"c:\mcfaxapp\sholalogo.jpg"
            
            success = self.cover_page_generator.generate_cover_page(
                cover_details=cover_details,
                output_path=temp_preview_path,
                page_count=len(self.selected_pdfs),
                logo_path=logo_path if os.path.exists(logo_path) else None
            )
            
            if success:
                # Convert PDF to image for display
                self.convert_pdf_to_preview_image(temp_preview_path)
                
                # Clean up temporary file
                try:
                    os.remove(temp_preview_path)
                except:
                    pass
            else:
                self.cover_preview_label.setText("Error generating cover page preview")
                
        except Exception as e:
            self.logger.error(f"Error updating visual cover preview: {e}")
            self.cover_preview_label.setText(f"Preview error: {str(e)}")
    
    def convert_pdf_to_preview_image(self, pdf_path: str):
        """Convert PDF to image for preview display"""
        try:
            # Try to use PyMuPDF for PDF to image conversion
            try:
                import fitz  # PyMuPDF
                
                # Open PDF
                doc = fitz.open(pdf_path)
                page = doc[0]  # First page only
                
                # Render page to image at appropriate resolution
                # Scale to fit preview area while maintaining aspect ratio
                available_width = self.cover_preview_scroll.width() - 20  # Account for margins
                available_height = self.cover_preview_scroll.height() - 20
                
                # Calculate scale factor to fit in preview area
                page_rect = page.rect
                scale_x = available_width / page_rect.width
                scale_y = available_height / page_rect.height
                scale = min(scale_x, scale_y, 1.0)  # Don't scale up beyond 100%
                
                # Create transformation matrix
                mat = fitz.Matrix(scale, scale)
                
                # Render to pixmap
                pix = page.get_pixmap(matrix=mat)
                
                # Convert to QPixmap
                img_data = pix.tobytes("ppm")
                qpixmap = QPixmap()
                qpixmap.loadFromData(img_data)
                
                # Display in preview label
                self.cover_preview_label.setPixmap(qpixmap)
                self.cover_preview_label.resize(qpixmap.size())
                
                doc.close()
                
                self.logger.info("Cover page visual preview updated successfully")
                
            except ImportError:
                # Fallback: show message that PyMuPDF is needed for visual preview
                self.cover_preview_label.setText(
                    "Visual preview requires PyMuPDF\n"
                    "Install with: pip install PyMuPDF\n\n"
                    "PDF generated successfully at:\n" + pdf_path
                )
                
        except Exception as e:
            self.logger.error(f"Error converting PDF to preview image: {e}")
            self.cover_preview_label.setText(f"Preview conversion error: {str(e)}")
    
    # Final preview methods for the preview tab
    
    def generate_final_preview(self):
        """Generate the final combined PDF preview (cover page + selected PDFs)"""
        try:
            # Validate that we have the required data
            if not self.selected_pdfs:
                QMessageBox.warning(self, "No PDFs", "No PDF files selected to preview.")
                return
            
            current_contact = self.contact_list.currentItem()
            if not current_contact:
                QMessageBox.warning(self, "No Recipient", "Please select a recipient first.")
                return
            
            # Start progress button animation
            self.generate_preview_btn.start_processing()
            
            # Clear any existing preview first to release file locks
            self.clear_final_preview()
            
            # Update progress button
            self.generate_preview_btn.set_progress(10)
            
            # Create cover page details
            cover_details = CoverPageDetails(
                to=self.to_edit.text().strip() or None,
                from_field=self.from_name_edit.text().strip() or None,
                company=self.from_company_edit.text().strip() or None,
                fax=self.fax_edit.text().strip() or None,
                phone=self.from_phone_edit.text().strip() or None,
                re=self.re_edit.text().strip() or None,
                comments=self.comments_edit.toPlainText().strip() or None,
                urgent=self.urgent_checkbox.isChecked(),
                for_review=self.for_review_checkbox.isChecked(),
                please_comment=self.please_comment_checkbox.isChecked(),
                please_reply=self.please_reply_checkbox.isChecked()
            )
            
            # Generate cover page
            self.generate_preview_btn.set_progress(30)
            
            cover_page_path = "temp_final_cover.pdf"
            logo_path = r"c:\mcfaxapp\sholalogo.jpg"
            
            cover_success = self.cover_page_generator.generate_cover_page(
                cover_details=cover_details,
                output_path=cover_page_path,
                page_count=len(self.selected_pdfs),
                logo_path=logo_path if os.path.exists(logo_path) else None
            )
            
            if not cover_success:
                self.generate_preview_btn.finish_processing(success=False)
                QMessageBox.warning(self, "Cover Page Error", "Failed to generate cover page.")
                return
            
            # Combine cover page with selected PDFs
            self.generate_preview_btn.set_progress(60)
            
            final_pdf_path = "temp_final_preview.pdf"
            combined_success = self.combine_pdfs_for_preview(cover_page_path, self.selected_pdfs, final_pdf_path)
            
            if not combined_success:
                self.generate_preview_btn.finish_processing(success=False)
                QMessageBox.warning(self, "Combine Error", "Failed to combine PDFs.")
                return
            
            # Load the final PDF in the preview viewer
            self.generate_preview_btn.set_progress(90)
            
            self.load_final_preview(final_pdf_path)
            
            # Clean up temporary cover page
            try:
                os.remove(cover_page_path)
            except:
                pass
            
            # Complete progress
            self.generate_preview_btn.set_progress(100)
            self.generate_preview_btn.finish_processing(success=True)
            
            self.logger.info("Final preview generated successfully")
            
        except Exception as e:
            self.logger.error(f"Error generating final preview: {e}")
            self.generate_preview_btn.finish_processing(success=False)
            self.status_label.setText(f"Preview generation failed: {str(e)}")
            QMessageBox.critical(self, "Preview Error", f"Failed to generate final preview:\n{str(e)}")
    
    def combine_pdfs_for_preview(self, cover_page_path: str, pdf_paths: List[str], output_path: str) -> bool:
        """Combine cover page and selected PDFs into a single preview PDF (with edits applied)"""
        try:
            # First, ensure any existing preview file is properly closed and removed
            if os.path.exists(output_path):
                # Clear the final preview to release file locks
                self.clear_final_preview()
                
                # Try to remove the existing file with retry logic
                import time
                max_attempts = 5
                for attempt in range(max_attempts):
                    try:
                        os.remove(output_path)
                        self.logger.debug(f"Successfully removed existing preview file: {output_path}")
                        break
                    except PermissionError:
                        if attempt < max_attempts - 1:
                            self.logger.warning(f"File locked, retrying in 0.5 seconds (attempt {attempt + 1}/{max_attempts})")
                            time.sleep(0.5)
                        else:
                            self.logger.error(f"Could not remove existing preview file after {max_attempts} attempts: {output_path}")
                            return False
                    except Exception as e:
                        self.logger.error(f"Error removing existing preview file {output_path}: {e}")
                        return False
            
            # Save current PDF edits before generating preview
            self._save_current_pdf_edits()
            
            # Check if we have any PDF edits to apply for preview
            if self.pdf_edit_data:
                self.logger.info(f"Applying edits to preview - found edit data for {len(self.pdf_edit_data)} PDFs")
                
                # Use the PDF processor's combine_pdfs_with_edits method for preview
                success = self.pdf_processor.combine_pdfs_with_edits(
                    pdf_files=[cover_page_path] + pdf_paths,
                    output_path=output_path,
                    edit_data_map=self.pdf_edit_data,
                    excluded_pages=None  # Page exclusions are handled within edit data
                )
                
                if success:
                    self.logger.info("Successfully combined preview PDFs with edits applied")
                    return True
                else:
                    error_msg = "Failed to combine preview PDFs with edits applied"
                    self.logger.error(error_msg)
                    from PyQt6.QtWidgets import QMessageBox
                    QMessageBox.critical(
                        self, 
                        "Preview Generation Failed", 
                        f"{error_msg}\n\nCheck logs for detailed error information.\nOperation stopped."
                    )
                    return False
            else:
                self.logger.info("No PDF edits found for preview, using standard combination")
            
            # Standard PDF combination (no edits)
            try:
                import fitz  # PyMuPDF
                
                # Create new PDF document
                combined_doc = fitz.open()
                
                # Add cover page
                cover_doc = fitz.open(cover_page_path)
                combined_doc.insert_pdf(cover_doc)
                cover_doc.close()
                
                # Add each selected PDF
                for pdf_path in pdf_paths:
                    try:
                        pdf_doc = fitz.open(pdf_path)
                        combined_doc.insert_pdf(pdf_doc)
                        pdf_doc.close()
                    except Exception as e:
                        self.logger.warning(f"Error adding PDF {pdf_path}: {e}")
                        continue
                
                # Save combined PDF
                combined_doc.save(output_path)
                combined_doc.close()
                
                return True
                
            except ImportError:
                # Fallback: just copy the cover page as preview
                try:
                    import shutil
                    shutil.copy2(cover_page_path, output_path)
                    return True
                except Exception as e:
                    self.logger.error(f"Fallback copy failed: {e}")
                    return False
                    
        except Exception as e:
            self.logger.error(f"Error combining PDFs for preview: {e}")
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.critical(
                self, 
                "Preview Generation Error", 
                f"Error combining PDFs for preview:\n\n{str(e)}\n\nOperation stopped."
            )
            return False
    
    def load_final_preview(self, pdf_path: str):
        """Load the final combined PDF in the preview viewer"""
        try:
            # Clear existing preview
            self.clear_final_preview()
            
            # Hide placeholder
            self.final_preview_placeholder.hide()
            
            # Create integrated PDF viewer for final preview
            self.final_preview_viewer = IntegratedPDFViewer(pdf_path)
            
            # Connect signals
            self.final_preview_viewer.page_changed.connect(self.on_final_preview_page_changed)
            self.final_preview_viewer.zoom_changed.connect(self.on_final_preview_zoom_changed)
            
            # Add to layout
            self.final_preview_layout.addWidget(self.final_preview_viewer)
            
            # Enable preview controls
            self.enable_final_preview_controls(True)
            
            # Store the path for cleanup later
            self.final_preview_pdf_path = pdf_path
            
            # Set initial zoom to fit the panel
            self.fit_preview_to_panel()
            
            # Update page info
            self.update_final_preview_page_info()
            
            self.logger.info(f"Loaded final preview: {pdf_path}")
            
        except Exception as e:
            self.logger.error(f"Error loading final preview: {e}")
            self.show_final_preview_error(f"Error loading preview: {str(e)}")
    
    def clear_final_preview(self):
        """Clear the final preview viewer"""
        # Remove existing viewer widget
        for i in reversed(range(self.final_preview_layout.count())):
            child = self.final_preview_layout.itemAt(i).widget()
            if child and child != self.final_preview_placeholder:
                child.setParent(None)
        
        # Show placeholder
        self.final_preview_placeholder.show()
        
        # Disable controls
        self.enable_final_preview_controls(False)
        
        # Clean up temporary file
        if self.final_preview_pdf_path and os.path.exists(self.final_preview_pdf_path):
            try:
                os.remove(self.final_preview_pdf_path)
            except:
                pass
        
        # Reset state
        self.final_preview_pdf_path = None
        self.final_preview_viewer = None
        self.final_preview_current_page = 0
        self.final_preview_zoom_level = 1.0
    
    def enable_final_preview_controls(self, enabled: bool):
        """Enable or disable final preview controls"""
        self.preview_prev_btn.setEnabled(enabled)
        self.preview_next_btn.setEnabled(enabled)
        self.preview_zoom_out_btn.setEnabled(enabled)
        self.preview_zoom_in_btn.setEnabled(enabled)
        
        if not enabled:
            self.preview_page_label.setText("No preview generated")
            self.preview_zoom_label.setText("100%")
    
    def update_final_preview_page_info(self):
        """Update final preview page information"""
        if self.final_preview_viewer and self.final_preview_pdf_path:
            total_pages = self.final_preview_viewer.get_page_count()
            current_page_display = self.final_preview_current_page + 1  # Display 1-based
            self.preview_page_label.setText(f"Page {current_page_display} of {total_pages}")
            
            # Update navigation buttons
            self.preview_prev_btn.setEnabled(self.final_preview_current_page > 0)
            self.preview_next_btn.setEnabled(self.final_preview_current_page < total_pages - 1)
        else:
            self.preview_page_label.setText("No preview generated")
    
    def show_final_preview_error(self, message: str):
        """Show an error message in the final preview area"""
        self.clear_final_preview()
        error_label = QLabel(f"❌ {message}")
        error_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        error_label.setStyleSheet("color: red; font-size: 14px;")
        self.final_preview_layout.addWidget(error_label)
    
    
    def create_simple_pdf_viewer(self, pdf_path: str):
        """Create a simple PDF viewer using basic image display"""
        try:
            import fitz  # PyMuPDF
            
            # Open PDF document
            self.final_preview_pdf_doc = fitz.open(pdf_path)
            self.final_preview_total_pages = len(self.final_preview_pdf_doc)
            
            # Create a simple label for displaying PDF pages
            self.final_preview_label = QLabel()
            self.final_preview_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.final_preview_label.setStyleSheet("""
                QLabel {
                    background-color: white;
                    border: 1px solid #ddd;
                    margin: 5px;
                }
            """)
            
            # Add to layout
            self.final_preview_layout.addWidget(self.final_preview_label)
            
            # Set initial zoom level to fit panel
            self.final_preview_zoom_level = 0.6  # Start at 60% to fit better
            
            self.logger.info(f"Created simple PDF viewer for {self.final_preview_total_pages} pages")
            
        except ImportError:
            self.show_final_preview_error("PyMuPDF is required for PDF preview. Please install with: pip install PyMuPDF")
        except Exception as e:
            self.logger.error(f"Error creating simple PDF viewer: {e}")
            self.show_final_preview_error(f"Error creating PDF viewer: {str(e)}")
    
    def load_preview_page(self, page_number: int):
        """Load and display a specific page in the simple PDF viewer"""
        try:
            if not hasattr(self, 'final_preview_pdf_doc') or not self.final_preview_pdf_doc:
                return
            
            if 0 <= page_number < self.final_preview_total_pages:
                # Get the page
                page = self.final_preview_pdf_doc[page_number]
                
                # Calculate zoom to fit panel
                available_width = self.final_preview_container.width() - 60  # Account for margins and scrollbars
                available_height = self.final_preview_container.height() - 60
                
                # Get page dimensions
                page_rect = page.rect
                
                # Calculate scale factors
                scale_x = available_width / page_rect.width if page_rect.width > 0 else 1.0
                scale_y = available_height / page_rect.height if page_rect.height > 0 else 1.0
                
                # Use the smaller scale to ensure the page fits completely, but don't go below 0.3 or above 1.0
                auto_fit_scale = max(0.3, min(scale_x, scale_y, 1.0))
                
                # Use the current zoom level or auto-fit if this is the first load
                if not hasattr(self, '_preview_zoom_set'):
                    self.final_preview_zoom_level = auto_fit_scale
                    self._preview_zoom_set = True
                
                # Create transformation matrix
                mat = fitz.Matrix(self.final_preview_zoom_level, self.final_preview_zoom_level)
                
                # Render page to pixmap
                pix = page.get_pixmap(matrix=mat)
                
                # Convert to QPixmap
                img_data = pix.tobytes("ppm")
                qpixmap = QPixmap()
                qpixmap.loadFromData(img_data)
                
                # Display in label
                self.final_preview_label.setPixmap(qpixmap)
                self.final_preview_label.resize(qpixmap.size())
                
                # Update zoom label
                self.preview_zoom_label.setText(f"{int(self.final_preview_zoom_level * 100)}%")
                
                self.logger.info(f"Loaded preview page {page_number + 1} at {int(self.final_preview_zoom_level * 100)}% zoom")
                
        except Exception as e:
            self.logger.error(f"Error loading preview page {page_number}: {e}")
            self.show_final_preview_error(f"Error loading page: {str(e)}")
    
    def preview_previous_page(self):
        """Go to previous page in final preview"""
        if self.final_preview_viewer and self.final_preview_current_page > 0:
            self.final_preview_current_page -= 1
            self.final_preview_viewer.go_to_page(self.final_preview_current_page)
            self.update_final_preview_page_info()
    
    def preview_next_page(self):
        """Go to next page in final preview"""
        if self.final_preview_viewer:
            total_pages = self.final_preview_viewer.get_page_count()
            if self.final_preview_current_page < total_pages - 1:
                self.final_preview_current_page += 1
                self.final_preview_viewer.go_to_page(self.final_preview_current_page)
                self.update_final_preview_page_info()
    
    def preview_zoom_in(self):
        """Zoom in on the final preview"""
        if self.final_preview_viewer:
            self.final_preview_zoom_level = min(self.final_preview_zoom_level * 1.25, 5.0)  # Max 500%
            self.final_preview_viewer.set_zoom(self.final_preview_zoom_level)
            self.preview_zoom_label.setText(f"{int(self.final_preview_zoom_level * 100)}%")
    
    def preview_zoom_out(self):
        """Zoom out on the final preview"""
        if self.final_preview_viewer:
            self.final_preview_zoom_level = max(self.final_preview_zoom_level / 1.25, 0.25)  # Min 25%
            self.final_preview_viewer.set_zoom(self.final_preview_zoom_level)
            self.preview_zoom_label.setText(f"{int(self.final_preview_zoom_level * 100)}%")
    
    def update_final_preview_page_info(self):
        """Update final preview page information"""
        if hasattr(self, 'final_preview_pdf_doc') and self.final_preview_pdf_doc:
            current_page_display = self.final_preview_current_page + 1  # Display 1-based
            self.preview_page_label.setText(f"Page {current_page_display} of {self.final_preview_total_pages}")
            
            # Update navigation buttons
            self.preview_prev_btn.setEnabled(self.final_preview_current_page > 0)
            self.preview_next_btn.setEnabled(self.final_preview_current_page < self.final_preview_total_pages - 1)
        else:
            self.preview_page_label.setText("No preview generated")
    
    def on_final_preview_page_changed(self, page_number: int):
        """Handle page change from the final preview viewer"""
        self.final_preview_current_page = page_number
        self.update_final_preview_page_info()
    
    def on_final_preview_zoom_changed(self, zoom_level: float):
        """Handle zoom change from the final preview viewer"""
        self.final_preview_zoom_level = zoom_level
        self.preview_zoom_label.setText(f"{int(zoom_level * 100)}%")
    
    def fit_preview_to_panel(self):
        """Set the preview zoom to fit the panel width"""
        if not self.final_preview_viewer:
            return
        
        try:
            # Get the available width of the preview panel
            available_width = self.final_preview_container.width() - 40  # Account for margins and scrollbars
            available_height = self.final_preview_container.height() - 40
            
            # Get the first page to calculate dimensions
            if self.final_preview_viewer.page_images:
                first_page = self.final_preview_viewer.page_images[0]
                page_width = first_page.width()
                page_height = first_page.height()
                
                # Calculate scale factors
                scale_x = available_width / page_width if page_width > 0 else 1.0
                scale_y = available_height / page_height if page_height > 0 else 1.0
                
                # Use the smaller scale to ensure the page fits completely
                fit_scale = min(scale_x, scale_y, 1.0)  # Don't scale up beyond 100%
                
                # Apply the fit scale
                if fit_scale < 1.0:  # Only scale down if needed
                    self.final_preview_zoom_level = fit_scale
                    self.final_preview_viewer.set_zoom(fit_scale)
                    self.preview_zoom_label.setText(f"{int(fit_scale * 100)}%")
                    
                    self.logger.info(f"Set preview zoom to fit panel: {int(fit_scale * 100)}%")
                
        except Exception as e:
            self.logger.error(f"Error fitting preview to panel: {e}")
            # Fallback to a reasonable default zoom
            self.final_preview_zoom_level = 0.75  # 75%
            if self.final_preview_viewer:
                self.final_preview_viewer.set_zoom(0.75)
            self.preview_zoom_label.setText("75%")
    
    def clear_final_preview(self):
        """Clear the final preview viewer"""
        # First, close and clean up the viewer to release file locks
        if self.final_preview_viewer:
            try:
                # Close the PDF document in the viewer
                if hasattr(self.final_preview_viewer, 'pdf_document') and self.final_preview_viewer.pdf_document:
                    self.final_preview_viewer.pdf_document.close()
                
                # Remove the viewer widget
                self.final_preview_viewer.setParent(None)
                self.final_preview_viewer = None
                
                # Force garbage collection to release file handles
                import gc
                gc.collect()
                
            except Exception as e:
                self.logger.warning(f"Error closing preview viewer: {e}")
        
        # Remove existing viewer widgets
        for i in reversed(range(self.final_preview_layout.count())):
            child = self.final_preview_layout.itemAt(i).widget()
            if child and child != self.final_preview_placeholder:
                child.setParent(None)
        
        # Show placeholder
        self.final_preview_placeholder.show()
        
        # Disable controls
        self.enable_final_preview_controls(False)
        
        # Clean up PDF document
        if hasattr(self, 'final_preview_pdf_doc') and self.final_preview_pdf_doc:
            try:
                self.final_preview_pdf_doc.close()
            except:
                pass
        
        # Clean up temporary file with retry logic
        if self.final_preview_pdf_path and os.path.exists(self.final_preview_pdf_path):
            self.cleanup_temp_file(self.final_preview_pdf_path)
        
        # Reset state
        self.final_preview_pdf_path = None
        self.final_preview_pdf_doc = None
        self.final_preview_current_page = 0
        self.final_preview_zoom_level = 1.0
        self.final_preview_total_pages = 0
        if hasattr(self, '_preview_zoom_set'):
            delattr(self, '_preview_zoom_set')
    
    def cleanup_temp_file(self, file_path: str):
        """Clean up temporary file with retry logic"""
        import time
        max_attempts = 3
        
        for attempt in range(max_attempts):
            try:
                os.remove(file_path)
                self.logger.debug(f"Successfully removed temporary file: {file_path}")
                return
            except PermissionError:
                if attempt < max_attempts - 1:
                    self.logger.warning(f"File locked, retrying in 0.5 seconds (attempt {attempt + 1}/{max_attempts})")
                    time.sleep(0.5)
                else:
                    self.logger.warning(f"Could not remove temporary file after {max_attempts} attempts: {file_path}")
            except Exception as e:
                self.logger.warning(f"Error removing temporary file {file_path}: {e}")
                break
    
    # XML Generation and FaxFinder Submission Methods
    
    def generate_final_pdf(self, fax_job: FaxJob) -> Optional[str]:
        """Generate the final combined PDF (cover page + selected PDFs with edits applied)"""
        try:
            from datetime import datetime
            
            # Save current PDF edits before generating final PDF
            self._save_current_pdf_edits()
            
            # Create output directories
            processed_dir = Path("processed")
            processed_dir.mkdir(exist_ok=True)
            
            temp_dir = Path("temp")
            temp_dir.mkdir(exist_ok=True)
            
            # Generate timestamp for unique filenames
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Generate cover page
            cover_page_path = temp_dir / f"cover_{timestamp}.pdf"
            logo_path = Path("SholaLogo.JPG")
            
            cover_success = self.cover_page_generator.generate_cover_page(
                cover_details=fax_job.cover_page_details,
                output_path=str(cover_page_path),
                page_count=len(self.selected_pdfs),
                logo_path=str(logo_path) if logo_path.exists() else None
            )
            
            if not cover_success:
                self.logger.error("Failed to generate cover page")
                return None
            
            # Combine cover page with selected PDFs (applying edits if any)
            final_pdf_path = processed_dir / f"fax_job_{timestamp}.pdf"
            
            # Check if we have any PDF edits to apply
            if self.pdf_edit_data:
                self.logger.info(f"Found edit data for {len(self.pdf_edit_data)} PDFs, applying edits...")
                
                # Use the new combine_pdfs_with_edits method
                success = self.pdf_processor.combine_pdfs_with_edits(
                    pdf_files=[str(cover_page_path)] + self.selected_pdfs,
                    output_path=str(final_pdf_path),
                    edit_data_map=self.pdf_edit_data,
                    excluded_pages=None  # Page exclusions are handled within edit data
                )
                
                if not success:
                    error_msg = "Failed to combine PDFs with edits applied"
                    self.logger.error(error_msg)
                    from PyQt6.QtWidgets import QMessageBox
                    QMessageBox.critical(
                        self, 
                        "Final PDF Generation Failed", 
                        f"{error_msg}\n\nCheck logs for detailed error information.\nOperation stopped."
                    )
                    return None
                    
            else:
                # No edits, use standard PDF combination
                self.logger.info("No PDF edits found, using standard combination...")
                
                try:
                    import fitz  # PyMuPDF
                    
                    # Create new PDF document
                    combined_doc = fitz.open()
                    
                    # Add cover page
                    cover_doc = fitz.open(str(cover_page_path))
                    combined_doc.insert_pdf(cover_doc)
                    cover_doc.close()
                    
                    # Add each selected PDF
                    for pdf_path in self.selected_pdfs:
                        try:
                            pdf_doc = fitz.open(pdf_path)
                            combined_doc.insert_pdf(pdf_doc)
                            pdf_doc.close()
                            self.logger.info(f"Added PDF to final document: {Path(pdf_path).name}")
                        except Exception as e:
                            self.logger.warning(f"Error adding PDF {pdf_path}: {e}")
                            continue
                    
                    # Save combined PDF
                    combined_doc.save(str(final_pdf_path))
                    combined_doc.close()
                    
                except ImportError:
                    self.logger.error("PyMuPDF is required for PDF combination")
                    return None
            
            # Clean up temporary cover page
            self.cleanup_temp_file(str(cover_page_path))
            
            self.logger.info(f"Generated final PDF: {final_pdf_path}")
            return str(final_pdf_path)
                
        except Exception as e:
            self.logger.error(f"Error generating final PDF: {e}")
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.critical(
                self, 
                "Final PDF Generation Error", 
                f"Error generating final PDF:\n\n{str(e)}\n\nOperation stopped."
            )
            return None
    
    def generate_xml_file(self, fax_job: FaxJob, pdf_path: str) -> Optional[str]:
        """Generate XML file for local storage (without base64 content)"""
        try:
            from datetime import datetime
            
            # Ensure XML directory exists relative to current working directory
            xml_dir = Path.cwd() / "xml"
            xml_dir.mkdir(parents=True, exist_ok=True)
            
            # Generate timestamp for unique filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            xml_filename = f"fax_job_{timestamp}.xml"
            xml_path = xml_dir / xml_filename
            
            # Get selected contact
            current_contact = self.contact_list.currentItem()
            if not current_contact:
                self.logger.error("No contact selected for XML generation")
                return None
            
            contact = current_contact.data(Qt.ItemDataRole.UserRole)
            
            # Use the generate_fax_xml method for local storage (no base64)
            success = self.xml_generator.generate_fax_xml(
                fax_job=fax_job,
                contact=contact,
                pdf_file_path=pdf_path,
                output_path=str(xml_path)
            )
            
            if success:
                self.logger.info(f"Generated XML file for local storage: {xml_path}")
                return str(xml_path)
            else:
                self.logger.error("Failed to generate XML file")
                return None
                
        except Exception as e:
            self.logger.error(f"Error generating XML file: {e}")
            return None
    
    def generate_xml_file_with_base64(self, fax_job: FaxJob, pdf_path: str) -> Optional[str]:
        """Generate XML file for local storage (WITH base64 content)"""
        try:
            from datetime import datetime
            
            # Ensure XML directory exists relative to current working directory
            xml_dir = Path.cwd() / "xml"
            xml_dir.mkdir(parents=True, exist_ok=True)
            
            # Generate timestamp for unique filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            xml_filename = f"fax_job_{timestamp}.xml"
            xml_path = xml_dir / xml_filename
            
            # Get selected contact
            current_contact = self.contact_list.currentItem()
            if not current_contact:
                self.logger.error("No contact selected for XML generation")
                return None
            
            contact = current_contact.data(Qt.ItemDataRole.UserRole)
            
            # Use the generate_faxfinder_xml method to get XML WITH base64 content
            xml_content = self.xml_generator.generate_faxfinder_xml(
                fax_job=fax_job,
                contact=contact,
                pdf_file_path=pdf_path
            )
            
            if xml_content:
                # Save the XML content to file
                with open(xml_path, 'w', encoding='utf-8') as f:
                    f.write(xml_content)
                
                self.logger.info(f"Generated XML file with base64 content: {xml_path}")
                return str(xml_path)
            else:
                self.logger.error("Failed to generate XML content with base64")
                return None
                
        except Exception as e:
            self.logger.error(f"Error generating XML file with base64: {e}")
            return None
    
    def calculate_page_count(self, pdf_path: str) -> int:
        """Calculate the total page count of the final PDF"""
        try:
            import fitz  # PyMuPDF
            
            doc = fitz.open(pdf_path)
            page_count = len(doc)
            doc.close()
            
            return page_count
            
        except ImportError:
            self.logger.warning("PyMuPDF not available for page counting")
            return 0
        except Exception as e:
            self.logger.error(f"Error calculating page count: {e}")
            return 0
    
    def submit_to_faxfinder(self, fax_job: FaxJob, pdf_path: str) -> Dict[str, Any]:
        """Submit the fax job to FaxFinder using the correct API method"""
        try:
            from core.settings import get_settings
            from fax.faxfinder_api import FaxFinderAPI
            
            # Get FaxFinder settings
            settings = get_settings()
            faxfinder_settings = settings.get_faxfinder_settings()
            
            # Check if FaxFinder is configured
            if not faxfinder_settings.get('host'):
                return {
                    'success': False,
                    'error': 'FaxFinder not configured. Please configure FaxFinder settings first.'
                }
            
            # Create FaxFinder API client
            api = FaxFinderAPI(
                host=faxfinder_settings['host'],
                username=faxfinder_settings['username'],
                password=faxfinder_settings['password'],
                use_https=faxfinder_settings.get('use_https', False)
            )
            
            # Test connection first
            connection_test = api.test_connection()
            if not connection_test['success']:
                return {
                    'success': False,
                    'error': f'Cannot connect to FaxFinder: {connection_test.get("error", "Unknown connection error")}'
                }
            
            # Get selected contact
            current_contact = self.contact_list.currentItem()
            if not current_contact:
                return {
                    'success': False,
                    'error': 'No contact selected for submission'
                }
            
            contact = current_contact.data(Qt.ItemDataRole.UserRole)
            
            # DEBUG: Verify PDF file exists and is readable
            if not os.path.exists(pdf_path):
                self.logger.error(f"PDF file does not exist: {pdf_path}")
                return {
                    'success': False,
                    'error': f'PDF file not found: {pdf_path}'
                }
            
            # DEBUG: Check file size
            file_size = os.path.getsize(pdf_path)
            self.logger.info(f"PDF file size: {file_size} bytes ({file_size/1024/1024:.1f} MB)")
            
            # DEBUG: Test base64 conversion locally before sending
            try:
                self.logger.info("=== DEBUG: Testing Base64 conversion locally ===")
                with open(pdf_path, 'rb') as test_file:
                    pdf_data = test_file.read()
                    pdf_base64_encoded = base64.b64encode(pdf_data).decode('utf-8')
                    self.logger.info(f"Base64 conversion successful: {len(pdf_base64_encoded)} characters")
                    self.logger.info(f"Base64 sample: {pdf_base64_encoded[:100]}...")
            except Exception as base64_error:
                self.logger.error(f"Base64 conversion failed: {base64_error}")
                return {
                    'success': False,
                    'error': f'Base64 conversion failed: {str(base64_error)}'
                }
            
            # DEBUG: Test XML generation before submission
            self.logger.info("=== DEBUG: Testing XML generation ===")
            from fax.xml_generator import FaxXMLGenerator
            test_generator = FaxXMLGenerator()
            
            try:
                test_xml = test_generator.generate_faxfinder_xml(fax_job, contact, pdf_path)
                
                if test_xml:
                    self.logger.info(f"XML generated successfully, length: {len(test_xml)} characters")
                    
                    # Check for base64 content in XML
                    if 'base64' in test_xml:
                        self.logger.info("✓ Base64 content found in XML")
                        
                        # Extract and verify base64 content
                        start_marker = '<content>'
                        end_marker = '</content>'
                        start_pos = test_xml.find(start_marker)
                        end_pos = test_xml.find(end_marker)
                        
                        if start_pos != -1 and end_pos != -1:
                            start_pos += len(start_marker)
                            base64_content = test_xml[start_pos:end_pos].strip()
                            self.logger.info(f"✓ Extracted base64 content: {len(base64_content)} characters")
                            
                            # Verify it's valid base64
                            try:
                                decoded = base64.b64decode(base64_content)
                                self.logger.info(f"✓ Base64 validation successful: {len(decoded)} bytes")
                            except Exception as b64_error:
                                self.logger.error(f"✗ Base64 validation failed: {b64_error}")
                        else:
                            self.logger.error("✗ Base64 content markers not found in XML")
                    else:
                        self.logger.error("✗ No base64 content found in XML")
                        
                    # Save debug XML for inspection
                    debug_xml_path = "debug_xml_with_base64.xml"
                    with open(debug_xml_path, 'w', encoding='utf-8') as f:
                        f.write(test_xml)
                    self.logger.info(f"Debug XML saved to: {debug_xml_path}")
                    
                else:
                    self.logger.error("XML generation returned None/empty")
                    return {
                        'success': False,
                        'error': 'XML generation failed'
                    }
                    
            except Exception as xml_error:
                self.logger.error(f"XML generation failed: {xml_error}")
                return {
                    'success': False,
                    'error': f'XML generation failed: {str(xml_error)}'
                }
            
            # Use the correct submit_fax_job method that calls generate_faxfinder_xml
            self.logger.info("=== DEBUG: Submitting to FaxFinder ===")
            result = api.submit_fax_job(fax_job, contact, pdf_path)
            
            if result['success']:
                self.logger.info(f"Successfully submitted fax to FaxFinder: {result.get('fax_entry_url', 'No URL returned')}")
                return {
                    'success': True,
                    'fax_entry_url': result.get('fax_entry_url'),
                    'message': 'Fax submitted successfully to FaxFinder'
                }
            else:
                self.logger.error(f"FaxFinder submission failed: {result.get('error', 'Unknown error')}")
                return {
                    'success': False,
                    'error': result.get('error', 'Unknown FaxFinder error')
                }
                
        except Exception as e:
            self.logger.error(f"Error submitting to FaxFinder: {e}")
            return {
                'success': False,
                'error': f'Submission error: {str(e)}'
            }
    
    def _has_unsaved_edits(self) -> bool:
        """Check if there are any unsaved PDF edits"""
        # Check if current PDF viewer has edits
        if self.pdf_viewer and self.current_pdf_path:
            current_edit_data = self.pdf_viewer.get_edit_data()
            if self.pdf_viewer._has_edits(current_edit_data):
                return True
        
        # Check if any stored edit data has actual edits
        for pdf_path, edit_data in self.pdf_edit_data.items():
            if edit_data and self._edit_data_has_changes(edit_data):
                return True
        
        return False
    
    def _edit_data_has_changes(self, edit_data: Dict[str, Any]) -> bool:
        """Check if edit data contains actual changes"""
        pages_data = edit_data.get('pages', [])
        
        for page_data in pages_data:
            # Check for excluded pages
            if page_data.get('excluded', False):
                return True
                
            # Check for brush strokes
            if page_data.get('brush_strokes'):
                return True
                
            # Check for annotations
            if page_data.get('annotations'):
                return True
        
        return False
    
    def closeEvent(self, event):
        """Handle window close event - warn about unsaved edits"""
        try:
            # Save current PDF edits before checking
            if self.pdf_viewer and self.current_pdf_path:
                edit_data = self.pdf_viewer.get_edit_data()
                self.pdf_edit_data[self.current_pdf_path] = edit_data
            
            # Check for unsaved edits
            if self._has_unsaved_edits():
                reply = QMessageBox.question(
                    self,
                    "Unsaved PDF Edits",
                    "You have unsaved PDF edits that will be lost if you close this window.\n\n"
                    "Are you sure you want to close without saving?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No
                )
                
                if reply == QMessageBox.StandardButton.No:
                    event.ignore()
                    return
            
            # Clean up resources
            self.clear_final_preview()
            
            # Accept the close event
            event.accept()
            
        except Exception as e:
            self.logger.error(f"Error in closeEvent: {e}")
            # If there's an error, still allow closing
            event.accept()
 
# --- END OF FILE: fax_job_window.py --- 
 
# --- START OF FILE: contact_window.py --- 
 
"""
Contact Management Window
Handles contact CRUD operations and CSV import/export
"""

import os
import csv
import logging
from pathlib import Path
from typing import List, Optional
from PyQt6.QtWidgets import (
    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QPushButton, QLabel, QTableWidget, QTableWidgetItem, QGroupBox,
    QLineEdit, QTextEdit, QHeaderView, QMessageBox, QFileDialog,
    QSplitter, QAbstractItemView
)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QFont

from database.models import Contact, ContactRepository

class ContactWindow(QDialog):
    """Window for managing contacts"""
    
    contact_updated = pyqtSignal()  # Signal emitted when contacts are updated
    
    def __init__(self, contact_repo: ContactRepository, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(__name__)
        self.contact_repo = contact_repo
        self.contacts = []
        self.current_contact = None
        
        self.setup_ui()
        self.load_contacts()
    
    def setup_ui(self):
        """Setup the user interface"""
        self.setWindowTitle("Contact Management")
        self.setGeometry(200, 200, 1000, 700)
        self.setModal(True)
        
        # Main layout
        main_layout = QVBoxLayout(self)
        
        # Create splitter for resizable panels
        splitter = QSplitter(Qt.Orientation.Horizontal)
        main_layout.addWidget(splitter)
        
        # Left panel - Contact list
        left_panel = self.create_contact_list_panel()
        splitter.addWidget(left_panel)
        
        # Right panel - Contact details
        right_panel = self.create_contact_details_panel()
        splitter.addWidget(right_panel)
        
        # Set splitter proportions
        splitter.setSizes([600, 400])
        
        # Button layout
        button_layout = QHBoxLayout()
        
        # Import/Export buttons
        import_btn = QPushButton("Import CSV")
        import_btn.clicked.connect(self.import_csv)
        button_layout.addWidget(import_btn)
        
        export_btn = QPushButton("Export CSV")
        export_btn.clicked.connect(self.export_csv)
        button_layout.addWidget(export_btn)
        
        button_layout.addStretch()
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        button_layout.addWidget(close_btn)
        
        main_layout.addLayout(button_layout)
    
    def create_contact_list_panel(self):
        """Create the contact list panel"""
        panel = QGroupBox("Contacts")
        layout = QVBoxLayout(panel)
        
        # Search bar
        search_layout = QHBoxLayout()
        search_layout.addWidget(QLabel("Search:"))
        
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search by name, fax, or organization...")
        self.search_edit.textChanged.connect(self.filter_contacts)
        search_layout.addWidget(self.search_edit)
        
        layout.addLayout(search_layout)
        
        # Contact table
        self.contact_table = QTableWidget()
        self.contact_table.setColumnCount(4)
        self.contact_table.setHorizontalHeaderLabels(["Name", "Fax Number", "Organization", "Phone"])
        
        # Configure table
        header = self.contact_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        
        self.contact_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.contact_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.contact_table.itemSelectionChanged.connect(self.on_contact_selected)
        
        layout.addWidget(self.contact_table)
        
        # Contact list buttons
        button_layout = QHBoxLayout()
        
        new_btn = QPushButton("New Contact")
        new_btn.clicked.connect(self.new_contact)
        button_layout.addWidget(new_btn)
        
        self.delete_btn = QPushButton("Delete Contact")
        self.delete_btn.clicked.connect(self.delete_contact)
        self.delete_btn.setEnabled(False)
        button_layout.addWidget(self.delete_btn)
        
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_contacts)
        button_layout.addWidget(refresh_btn)
        
        layout.addLayout(button_layout)
        
        return panel
    
    def create_contact_details_panel(self):
        """Create the contact details panel"""
        panel = QGroupBox("Contact Details")
        layout = QVBoxLayout(panel)
        
        # Contact form
        form_layout = QGridLayout()
        
        # Name
        form_layout.addWidget(QLabel("Name:"), 0, 0)
        self.name_edit = QLineEdit()
        form_layout.addWidget(self.name_edit, 0, 1)
        
        # Fax Number
        form_layout.addWidget(QLabel("Fax Number:"), 1, 0)
        self.fax_edit = QLineEdit()
        form_layout.addWidget(self.fax_edit, 1, 1)
        
        # Organization
        form_layout.addWidget(QLabel("Organization:"), 2, 0)
        self.org_edit = QLineEdit()
        form_layout.addWidget(self.org_edit, 2, 1)
        
        # Phone Number
        form_layout.addWidget(QLabel("Phone Number:"), 3, 0)
        self.phone_edit = QLineEdit()
        form_layout.addWidget(self.phone_edit, 3, 1)
        
        # Email
        form_layout.addWidget(QLabel("Email:"), 4, 0)
        self.email_edit = QLineEdit()
        form_layout.addWidget(self.email_edit, 4, 1)
        
        # Notes
        form_layout.addWidget(QLabel("Notes:"), 5, 0, Qt.AlignmentFlag.AlignTop)
        self.notes_edit = QTextEdit()
        self.notes_edit.setMaximumHeight(100)
        form_layout.addWidget(self.notes_edit, 5, 1)
        
        layout.addLayout(form_layout)
        
        # Form buttons
        button_layout = QHBoxLayout()
        
        self.save_btn = QPushButton("Save Contact")
        self.save_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 8px 16px;
                font-weight: bold;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:disabled {
                background-color: #cccccc;
                color: #666666;
            }
        """)
        self.save_btn.clicked.connect(self.save_contact)
        self.save_btn.setEnabled(False)
        button_layout.addWidget(self.save_btn)
        
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.cancel_edit)
        self.cancel_btn.setEnabled(False)
        button_layout.addWidget(self.cancel_btn)
        
        layout.addLayout(button_layout)
        
        # Add stretch to push form to top
        layout.addStretch()
        
        # Connect form fields to enable/disable save button
        self.name_edit.textChanged.connect(self.on_form_changed)
        self.fax_edit.textChanged.connect(self.on_form_changed)
        self.org_edit.textChanged.connect(self.on_form_changed)
        self.phone_edit.textChanged.connect(self.on_form_changed)
        self.email_edit.textChanged.connect(self.on_form_changed)
        self.notes_edit.textChanged.connect(self.on_form_changed)
        
        return panel
    
    def load_contacts(self):
        """Load contacts from database"""
        try:
            self.contacts = self.contact_repo.get_all()
            self.update_contact_table()
            self.clear_form()
        except Exception as e:
            self.logger.error(f"Error loading contacts: {e}")
            QMessageBox.critical(self, "Error", f"Failed to load contacts: {str(e)}")
    
    def update_contact_table(self):
        """Update the contact table with current contacts"""
        # Filter contacts based on search
        search_term = self.search_edit.text().lower()
        filtered_contacts = []
        
        for contact in self.contacts:
            if (not search_term or 
                search_term in contact.name.lower() or 
                search_term in contact.fax_number.lower() or 
                (contact.organization and search_term in contact.organization.lower()) or
                (contact.phone_number and search_term in contact.phone_number.lower())):
                filtered_contacts.append(contact)
        
        # Update table
        self.contact_table.setRowCount(len(filtered_contacts))
        
        for row, contact in enumerate(filtered_contacts):
            # Name
            name_item = QTableWidgetItem(contact.name or "")
            name_item.setData(Qt.ItemDataRole.UserRole, contact)
            self.contact_table.setItem(row, 0, name_item)
            
            # Fax Number
            fax_item = QTableWidgetItem(contact.fax_number or "")
            self.contact_table.setItem(row, 1, fax_item)
            
            # Organization
            org_item = QTableWidgetItem(contact.organization or "")
            self.contact_table.setItem(row, 2, org_item)
            
            # Phone
            phone_item = QTableWidgetItem(contact.phone_number or "")
            self.contact_table.setItem(row, 3, phone_item)
    
    def filter_contacts(self):
        """Filter contacts based on search term"""
        self.update_contact_table()
    
    def on_contact_selected(self):
        """Handle contact selection in table"""
        current_row = self.contact_table.currentRow()
        if current_row >= 0:
            name_item = self.contact_table.item(current_row, 0)
            if name_item:
                contact = name_item.data(Qt.ItemDataRole.UserRole)
                self.load_contact_to_form(contact)
                self.delete_btn.setEnabled(True)
        else:
            self.delete_btn.setEnabled(False)
    
    def load_contact_to_form(self, contact: Contact):
        """Load contact data into the form"""
        self.current_contact = contact
        
        self.name_edit.setText(contact.name or "")
        self.fax_edit.setText(contact.fax_number or "")
        self.org_edit.setText(contact.organization or "")
        self.phone_edit.setText(contact.phone_number or "")
        self.email_edit.setText(contact.email or "")
        self.notes_edit.setText(contact.notes or "")
        
        self.save_btn.setEnabled(False)  # No changes yet
        self.cancel_btn.setEnabled(True)
    
    def clear_form(self):
        """Clear the contact form"""
        self.current_contact = None
        
        self.name_edit.clear()
        self.fax_edit.clear()
        self.org_edit.clear()
        self.phone_edit.clear()
        self.email_edit.clear()
        self.notes_edit.clear()
        
        self.save_btn.setEnabled(False)
        self.cancel_btn.setEnabled(False)
        self.delete_btn.setEnabled(False)
    
    def new_contact(self):
        """Start creating a new contact"""
        self.contact_table.clearSelection()
        self.clear_form()
        self.name_edit.setFocus()
        self.cancel_btn.setEnabled(True)
    
    def on_form_changed(self):
        """Handle form field changes"""
        # Enable save button if there are changes
        has_name = bool(self.name_edit.text().strip())
        has_fax = bool(self.fax_edit.text().strip())
        
        # Basic validation - need at least name and fax
        can_save = has_name and has_fax
        
        # Check if there are actual changes
        if self.current_contact:
            has_changes = (
                self.name_edit.text() != (self.current_contact.name or "") or
                self.fax_edit.text() != (self.current_contact.fax_number or "") or
                self.org_edit.text() != (self.current_contact.organization or "") or
                self.phone_edit.text() != (self.current_contact.phone_number or "") or
                self.email_edit.text() != (self.current_contact.email or "") or
                self.notes_edit.toPlainText() != (self.current_contact.notes or "")
            )
            can_save = can_save and has_changes
        
        self.save_btn.setEnabled(can_save)
    
    def save_contact(self):
        """Save the current contact"""
        try:
            # Create or update contact object
            if self.current_contact:
                contact = self.current_contact
            else:
                contact = Contact()
            
            # Update contact data
            contact.name = self.name_edit.text().strip()
            contact.fax_number = self.fax_edit.text().strip()
            contact.organization = self.org_edit.text().strip() or None
            contact.phone_number = self.phone_edit.text().strip() or None
            contact.email = self.email_edit.text().strip() or None
            contact.notes = self.notes_edit.toPlainText().strip() or None
            
            # Validate
            errors = contact.validate()
            if errors:
                QMessageBox.warning(self, "Validation Error", "\n".join(errors))
                return
            
            # Save to database
            if contact.contact_id:
                # Update existing
                success = self.contact_repo.update(contact)
                if success:
                    QMessageBox.information(self, "Success", "Contact updated successfully")
                else:
                    QMessageBox.warning(self, "Warning", "No changes were made to the contact")
            else:
                # Create new
                contact_id = self.contact_repo.create(contact)
                contact.contact_id = contact_id
                QMessageBox.information(self, "Success", "Contact created successfully")
            
            # Refresh the contact list
            self.load_contacts()
            
            # Emit signal for other windows
            self.contact_updated.emit()
            
        except Exception as e:
            self.logger.error(f"Error saving contact: {e}")
            QMessageBox.critical(self, "Error", f"Failed to save contact: {str(e)}")
    
    def cancel_edit(self):
        """Cancel current edit operation"""
        if self.current_contact:
            # Reload the original contact data
            self.load_contact_to_form(self.current_contact)
        else:
            # Clear form for new contact
            self.clear_form()
    
    def delete_contact(self):
        """Delete the selected contact"""
        if not self.current_contact:
            return
        
        # Confirm deletion
        reply = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete contact '{self.current_contact.name}'?\n\n"
            "This action cannot be undone.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            try:
                success = self.contact_repo.delete(self.current_contact.contact_id)
                if success:
                    QMessageBox.information(self, "Success", "Contact deleted successfully")
                    self.load_contacts()
                    self.contact_updated.emit()
                else:
                    QMessageBox.warning(self, "Warning", "Contact was not found or already deleted")
            except Exception as e:
                self.logger.error(f"Error deleting contact: {e}")
                QMessageBox.critical(self, "Error", f"Failed to delete contact: {str(e)}")
    
    def import_csv(self):
        """Import contacts from CSV file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Import Contacts from CSV",
            str(Path.home()),
            "CSV Files (*.csv);;All Files (*)"
        )
        
        if not file_path:
            return
        
        try:
            imported_count = 0
            error_count = 0
            errors = []
            
            with open(file_path, 'r', newline='', encoding='utf-8') as csvfile:
                # Try to detect if file has headers
                sample = csvfile.read(1024)
                csvfile.seek(0)
                sniffer = csv.Sniffer()
                has_header = sniffer.has_header(sample)
                
                reader = csv.reader(csvfile)
                
                # Skip header if present
                if has_header:
                    next(reader)
                
                for row_num, row in enumerate(reader, start=2 if has_header else 1):
                    try:
                        if len(row) < 2:  # Need at least name and fax
                            continue
                        
                        # Map CSV columns: Name, Fax, Phone, Organization, Notes
                        contact = Contact(
                            name=row[0].strip() if len(row) > 0 else "",
                            fax_number=row[1].strip() if len(row) > 1 else "",
                            phone_number=row[2].strip() if len(row) > 2 else None,
                            organization=row[3].strip() if len(row) > 3 else None,
                            notes=row[4].strip() if len(row) > 4 else None
                        )
                        
                        # Validate
                        validation_errors = contact.validate()
                        if validation_errors:
                            error_count += 1
                            errors.append(f"Row {row_num}: {', '.join(validation_errors)}")
                            continue
                        
                        # Check for duplicate fax number
                        existing = self.contact_repo.get_by_fax_number(contact.fax_number)
                        if existing:
                            error_count += 1
                            errors.append(f"Row {row_num}: Duplicate fax number {contact.fax_number}")
                            continue
                        
                        # Save contact
                        self.contact_repo.create(contact)
                        imported_count += 1
                        
                    except Exception as e:
                        error_count += 1
                        errors.append(f"Row {row_num}: {str(e)}")
            
            # Show results
            message = f"Import completed:\n"
            message += f"• {imported_count} contacts imported successfully\n"
            if error_count > 0:
                message += f"• {error_count} errors encountered\n\n"
                if errors:
                    message += "Errors:\n" + "\n".join(errors[:10])  # Show first 10 errors
                    if len(errors) > 10:
                        message += f"\n... and {len(errors) - 10} more errors"
            
            if error_count > 0:
                QMessageBox.warning(self, "Import Results", message)
            else:
                QMessageBox.information(self, "Import Results", message)
            
            # Refresh contact list
            if imported_count > 0:
                self.load_contacts()
                self.contact_updated.emit()
                
        except Exception as e:
            self.logger.error(f"Error importing CSV: {e}")
            QMessageBox.critical(self, "Import Error", f"Failed to import CSV file: {str(e)}")
    
    def export_csv(self):
        """Export contacts to CSV file"""
        if not self.contacts:
            QMessageBox.information(self, "No Data", "No contacts to export")
            return
        
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Contacts to CSV",
            str(Path.home() / "contacts.csv"),
            "CSV Files (*.csv);;All Files (*)"
        )
        
        if not file_path:
            return
        
        try:
            with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                
                # Write header
                writer.writerow(["Name", "Fax", "Phone", "Organization", "Notes"])
                
                # Write contact data
                for contact in self.contacts:
                    writer.writerow([
                        contact.name or "",
                        contact.fax_number or "",
                        contact.phone_number or "",
                        contact.organization or "",
                        contact.notes or ""
                    ])
            
            QMessageBox.information(
                self,
                "Export Complete",
                f"Successfully exported {len(self.contacts)} contacts to:\n{file_path}"
            )
            
        except Exception as e:
            self.logger.error(f"Error exporting CSV: {e}")
            QMessageBox.critical(self, "Export Error", f"Failed to export CSV file: {str(e)}")
 
# --- END OF FILE: contact_window.py --- 
 
# --- START OF FILE: fax_history_window.py --- 
 
"""
Fax History Window
Displays historical fax jobs with filtering and viewing capabilities
"""

import os
import json
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Optional, Dict, Any
from PyQt6.QtWidgets import (
    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QPushButton, QLabel, QTableWidget, QTableWidgetItem, QGroupBox,
    QLineEdit, QComboBox, QDateEdit, QHeaderView, QMessageBox,
    QSplitter, QAbstractItemView, QMenu, QTextEdit, QTabWidget,
    QScrollArea
)
from PyQt6.QtCore import Qt, QDate, pyqtSignal
from PyQt6.QtGui import QFont, QAction, QColor

from database.models import FaxJob, Contact, FaxJobRepository, ContactRepository

class FaxHistoryWindow(QDialog):
    """Window for viewing fax job history"""
    
    fax_selected = pyqtSignal(object)  # Signal emitted when fax is selected for resending
    
    def __init__(self, fax_job_repo: FaxJobRepository, contact_repo: ContactRepository, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(__name__)
        self.fax_job_repo = fax_job_repo
        self.contact_repo = contact_repo
        
        # Data
        self.fax_jobs = []
        self.contacts = {}  # contact_id -> Contact object
        self.filtered_jobs = []
        
        # Current selection
        self.selected_fax_job = None
        
        self.setup_ui()
        self.load_data()
    
    def setup_ui(self):
        """Setup the user interface"""
        self.setWindowTitle("Fax History")
        self.setGeometry(200, 200, 1200, 800)
        self.setModal(True)
        
        # Main layout
        main_layout = QVBoxLayout(self)
        
        # Filter section
        filter_group = self.create_filter_section()
        main_layout.addWidget(filter_group)
        
        # Create splitter for resizable panels
        splitter = QSplitter(Qt.Orientation.Horizontal)
        main_layout.addWidget(splitter)
        
        # Left panel - Fax job list
        left_panel = self.create_fax_list_panel()
        splitter.addWidget(left_panel)
        
        # Right panel - Fax details
        right_panel = self.create_fax_details_panel()
        splitter.addWidget(right_panel)
        
        # Set splitter proportions
        splitter.setSizes([700, 500])
        
        # Button layout
        button_layout = QHBoxLayout()
        
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.load_data)
        button_layout.addWidget(refresh_btn)
        
        button_layout.addStretch()
        
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        button_layout.addWidget(close_btn)
        
        main_layout.addLayout(button_layout)
    
    def create_filter_section(self):
        """Create the filter section"""
        group = QGroupBox("Filters")
        layout = QHBoxLayout(group)
        
        # Contact filter
        layout.addWidget(QLabel("Contact:"))
        self.contact_filter = QComboBox()
        self.contact_filter.addItem("All Contacts", None)
        self.contact_filter.currentTextChanged.connect(self.apply_filters)
        layout.addWidget(self.contact_filter)
        
        # Status filter
        layout.addWidget(QLabel("Status:"))
        self.status_filter = QComboBox()
        self.status_filter.addItems([
            "All Statuses", "Pending", "Processing", "Sent", "Failed", "Cancelled"
        ])
        self.status_filter.currentTextChanged.connect(self.apply_filters)
        layout.addWidget(self.status_filter)
        
        # Date range
        layout.addWidget(QLabel("From:"))
        self.date_from = QDateEdit()
        self.date_from.setDate(QDate.currentDate().addDays(-30))  # Default to last 30 days
        self.date_from.setCalendarPopup(True)
        self.date_from.dateChanged.connect(self.apply_filters)
        layout.addWidget(self.date_from)
        
        layout.addWidget(QLabel("To:"))
        self.date_to = QDateEdit()
        self.date_to.setDate(QDate.currentDate())
        self.date_to.setCalendarPopup(True)
        self.date_to.dateChanged.connect(self.apply_filters)
        layout.addWidget(self.date_to)
        
        # Search
        layout.addWidget(QLabel("Search:"))
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search subject, recipient...")
        self.search_edit.textChanged.connect(self.apply_filters)
        layout.addWidget(self.search_edit)
        
        layout.addStretch()
        
        return group
    
    def create_fax_list_panel(self):
        """Create the fax job list panel"""
        panel = QGroupBox("Fax Jobs")
        layout = QVBoxLayout(panel)
        
        # Fax job table
        self.fax_table = QTableWidget()
        self.fax_table.setColumnCount(6)
        self.fax_table.setHorizontalHeaderLabels([
            "Date/Time", "Recipient", "Subject", "Status", "Pages", "Priority"
        ])
        
        # Configure table
        header = self.fax_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(5, QHeaderView.ResizeMode.ResizeToContents)
        
        self.fax_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.fax_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.fax_table.itemSelectionChanged.connect(self.on_fax_selected)
        
        # Context menu
        self.fax_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.fax_table.customContextMenuRequested.connect(self.show_context_menu)
        
        layout.addWidget(self.fax_table)
        
        # Status label
        self.status_label = QLabel("No fax jobs loaded")
        layout.addWidget(self.status_label)
        
        return panel
    
    def create_fax_details_panel(self):
        """Create the fax details panel"""
        panel = QGroupBox("Fax Details")
        layout = QVBoxLayout(panel)
        
        # Tab widget for different detail views
        self.details_tabs = QTabWidget()
        layout.addWidget(self.details_tabs)
        
        # General info tab
        self.create_general_info_tab()
        
        # Cover page tab
        self.create_cover_page_tab()
        
        # Technical details tab
        self.create_technical_tab()
        
        # Action buttons
        button_layout = QHBoxLayout()
        
        self.view_details_btn = QPushButton("View Full Details")
        self.view_details_btn.clicked.connect(self.view_full_details)
        self.view_details_btn.setEnabled(False)
        button_layout.addWidget(self.view_details_btn)
        
        self.resend_btn = QPushButton("Resend Fax")
        self.resend_btn.clicked.connect(self.resend_fax)
        self.resend_btn.setEnabled(False)
        self.resend_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 8px 16px;
                font-weight: bold;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:disabled {
                background-color: #cccccc;
                color: #666666;
            }
        """)
        button_layout.addWidget(self.resend_btn)
        
        layout.addLayout(button_layout)
        
        return panel
    
    def create_general_info_tab(self):
        """Create general information tab"""
        tab = QWidget()
        layout = QGridLayout(tab)
        
        # Create labels for displaying fax info
        self.info_labels = {}
        
        fields = [
            ("Fax ID:", "fax_id"),
            ("Status:", "status"),
            ("Created:", "created_at"),
            ("Sent:", "sent_at"),
            ("Sender:", "sender_name"),
            ("Sender Email:", "sender_email"),
            ("Recipient:", "recipient_name"),
            ("Recipient Fax:", "recipient_fax"),
            ("Priority:", "priority"),
            ("Max Attempts:", "max_attempts"),
            ("Retry Interval:", "retry_interval")
        ]
        
        for i, (label_text, field_name) in enumerate(fields):
            row = i // 2
            col = (i % 2) * 2
            
            layout.addWidget(QLabel(label_text), row, col)
            value_label = QLabel("-")
            value_label.setStyleSheet("QLabel { color: #333; font-weight: bold; }")
            layout.addWidget(value_label, row, col + 1)
            self.info_labels[field_name] = value_label
        
        layout.setRowStretch(len(fields) // 2 + 1, 1)
        
        self.details_tabs.addTab(tab, "General")
    
    def create_cover_page_tab(self):
        """Create cover page details tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Scroll area for cover page details
        scroll_area = QScrollArea()
        scroll_widget = QWidget()
        scroll_layout = QGridLayout(scroll_widget)
        
        # Cover page fields
        self.cover_page_labels = {}
        
        cover_fields = [
            ("To:", "to"),
            ("Attention:", "attn"),
            ("From:", "from_field"),
            ("Company:", "company"),
            ("Fax:", "fax"),
            ("Phone:", "phone"),
            ("Date:", "date"),
            ("Subject:", "subject"),
            ("Re:", "re"),
            ("CC:", "cc"),
            ("Pages:", "pages")
        ]
        
        for i, (label_text, field_name) in enumerate(cover_fields):
            scroll_layout.addWidget(QLabel(label_text), i, 0)
            value_label = QLabel("-")
            value_label.setWordWrap(True)
            value_label.setStyleSheet("QLabel { color: #333; }")
            scroll_layout.addWidget(value_label, i, 1)
            self.cover_page_labels[field_name] = value_label
        
        # Comments and message (larger fields)
        scroll_layout.addWidget(QLabel("Comments:"), len(cover_fields), 0, Qt.AlignmentFlag.AlignTop)
        self.comments_label = QTextEdit()
        self.comments_label.setReadOnly(True)
        self.comments_label.setMaximumHeight(80)
        scroll_layout.addWidget(self.comments_label, len(cover_fields), 1)
        
        scroll_layout.addWidget(QLabel("Message:"), len(cover_fields) + 1, 0, Qt.AlignmentFlag.AlignTop)
        self.message_label = QTextEdit()
        self.message_label.setReadOnly(True)
        self.message_label.setMaximumHeight(80)
        scroll_layout.addWidget(self.message_label, len(cover_fields) + 1, 1)
        
        scroll_area.setWidget(scroll_widget)
        layout.addWidget(scroll_area)
        
        self.details_tabs.addTab(tab, "Cover Page")
    
    def create_technical_tab(self):
        """Create technical details tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Technical info
        self.technical_text = QTextEdit()
        self.technical_text.setReadOnly(True)
        self.technical_text.setFont(QFont("Courier", 9))
        layout.addWidget(self.technical_text)
        
        self.details_tabs.addTab(tab, "Technical")
    
    def load_data(self):
        """Load fax jobs and contacts from database"""
        try:
            # Load contacts for filter dropdown
            contacts = self.contact_repo.get_all()
            self.contacts = {contact.contact_id: contact for contact in contacts}
            
            # Update contact filter
            self.contact_filter.clear()
            self.contact_filter.addItem("All Contacts", None)
            for contact in sorted(contacts, key=lambda c: c.name):
                self.contact_filter.addItem(f"{contact.name} ({contact.fax_number})", contact.contact_id)
            
            # Load fax jobs
            self.fax_jobs = self.fax_job_repo.get_all()
            
            # Apply filters and update display
            self.apply_filters()
            
            self.logger.info(f"Loaded {len(self.fax_jobs)} fax jobs and {len(contacts)} contacts")
            
        except Exception as e:
            self.logger.error(f"Error loading fax history data: {e}")
            QMessageBox.critical(self, "Error", f"Failed to load fax history: {str(e)}")
    
    def apply_filters(self):
        """Apply current filters to fax job list"""
        try:
            # Get filter values
            selected_contact_id = self.contact_filter.currentData()
            selected_status = self.status_filter.currentText()
            date_from = self.date_from.date().toPython()
            date_to = self.date_to.date().toPython()
            search_term = self.search_edit.text().lower()
            
            # Filter fax jobs
            self.filtered_jobs = []
            
            for fax_job in self.fax_jobs:
                # Contact filter
                if selected_contact_id is not None and fax_job.recipient_id != selected_contact_id:
                    continue
                
                # Status filter
                if selected_status != "All Statuses" and fax_job.status != selected_status:
                    continue
                
                # Date filter
                if fax_job.created_at:
                    job_date = fax_job.created_at.date()
                    if job_date < date_from or job_date > date_to:
                        continue
                
                # Search filter
                if search_term:
                    # Get contact name for search
                    contact = self.contacts.get(fax_job.recipient_id)
                    contact_name = contact.name.lower() if contact else ""
                    
                    # Get cover page subject
                    subject = ""
                    if fax_job.cover_page_details:
                        try:
                            cover_data = json.loads(fax_job.cover_page_details) if isinstance(fax_job.cover_page_details, str) else fax_job.cover_page_details
                            subject = (cover_data.get('subject', '') or '').lower()
                        except:
                            pass
                    
                    if (search_term not in contact_name and 
                        search_term not in subject and 
                        search_term not in (fax_job.sender_name or '').lower()):
                        continue
                
                self.filtered_jobs.append(fax_job)
            
            # Update table
            self.update_fax_table()
            
        except Exception as e:
            self.logger.error(f"Error applying filters: {e}")
    
    def update_fax_table(self):
        """Update the fax job table with filtered results"""
        self.fax_table.setRowCount(len(self.filtered_jobs))
        
        for row, fax_job in enumerate(self.filtered_jobs):
            # Date/Time
            date_str = fax_job.created_at.strftime("%Y-%m-%d %H:%M") if fax_job.created_at else "Unknown"
            date_item = QTableWidgetItem(date_str)
            date_item.setData(Qt.ItemDataRole.UserRole, fax_job)
            self.fax_table.setItem(row, 0, date_item)
            
            # Recipient
            contact = self.contacts.get(fax_job.recipient_id)
            recipient_name = contact.name if contact else f"Contact ID: {fax_job.recipient_id}"
            recipient_item = QTableWidgetItem(recipient_name)
            self.fax_table.setItem(row, 1, recipient_item)
            
            # Subject (from cover page)
            subject = "No Subject"
            if fax_job.cover_page_details:
                try:
                    cover_data = json.loads(fax_job.cover_page_details) if isinstance(fax_job.cover_page_details, str) else fax_job.cover_page_details
                    subject = cover_data.get('subject', 'No Subject') or 'No Subject'
                except:
                    pass
            subject_item = QTableWidgetItem(subject)
            self.fax_table.setItem(row, 2, subject_item)
            
            # Status
            status_item = QTableWidgetItem(fax_job.status or "Unknown")
            # Color code status
            if fax_job.status == "Sent":
                status_item.setBackground(QColor(200, 255, 200))  # Light green
            elif fax_job.status == "Failed":
                status_item.setBackground(QColor(255, 200, 200))  # Light red
            elif fax_job.status in ["Pending", "Processing"]:
                status_item.setBackground(QColor(255, 255, 200))  # Light yellow
            self.fax_table.setItem(row, 3, status_item)
            
            # Pages (placeholder - would need to parse from PDF or XML)
            pages_item = QTableWidgetItem("N/A")
            self.fax_table.setItem(row, 4, pages_item)
            
            # Priority
            priority_item = QTableWidgetItem(fax_job.priority or "Medium")
            self.fax_table.setItem(row, 5, priority_item)
        
        # Update status
        total_jobs = len(self.fax_jobs)
        filtered_jobs = len(self.filtered_jobs)
        self.status_label.setText(f"Showing {filtered_jobs} of {total_jobs} fax jobs")
    
    def on_fax_selected(self):
        """Handle fax job selection in table"""
        current_row = self.fax_table.currentRow()
        if current_row >= 0:
            date_item = self.fax_table.item(current_row, 0)
            if date_item:
                self.selected_fax_job = date_item.data(Qt.ItemDataRole.UserRole)
                self.update_fax_details()
                self.view_details_btn.setEnabled(True)
                self.resend_btn.setEnabled(True)
        else:
            self.selected_fax_job = None
            self.clear_fax_details()
            self.view_details_btn.setEnabled(False)
            self.resend_btn.setEnabled(False)
    
    def update_fax_details(self):
        """Update the fax details panel with selected fax job"""
        if not self.selected_fax_job:
            return
        
        fax_job = self.selected_fax_job
        
        # Update general info
        self.info_labels["fax_id"].setText(str(fax_job.fax_id or "N/A"))
        self.info_labels["status"].setText(fax_job.status or "Unknown")
        self.info_labels["created_at"].setText(
            fax_job.created_at.strftime("%Y-%m-%d %H:%M:%S") if fax_job.created_at else "N/A"
        )
        self.info_labels["sent_at"].setText(
            fax_job.sent_at.strftime("%Y-%m-%d %H:%M:%S") if fax_job.sent_at else "Not sent"
        )
        self.info_labels["sender_name"].setText(fax_job.sender_name or "N/A")
        self.info_labels["sender_email"].setText(fax_job.sender_email or "N/A")
        
        # Recipient info
        contact = self.contacts.get(fax_job.recipient_id)
        if contact:
            self.info_labels["recipient_name"].setText(contact.name)
            self.info_labels["recipient_fax"].setText(contact.fax_number)
        else:
            self.info_labels["recipient_name"].setText(f"Contact ID: {fax_job.recipient_id}")
            self.info_labels["recipient_fax"].setText(fax_job.recipient_fax or "N/A")
        
        self.info_labels["priority"].setText(fax_job.priority or "N/A")
        self.info_labels["max_attempts"].setText(str(fax_job.max_attempts or "N/A"))
        self.info_labels["retry_interval"].setText(f"{fax_job.retry_interval or 'N/A'} minutes")
        
        # Update cover page details
        self.update_cover_page_details(fax_job)
        
        # Update technical details
        self.update_technical_details(fax_job)
    
    def update_cover_page_details(self, fax_job):
        """Update cover page details tab"""
        # Clear all fields first
        for label in self.cover_page_labels.values():
            label.setText("-")
        self.comments_label.clear()
        self.message_label.clear()
        
        if not fax_job.cover_page_details:
            return
        
        try:
            # Parse cover page data
            if isinstance(fax_job.cover_page_details, str):
                cover_data = json.loads(fax_job.cover_page_details)
            else:
                cover_data = fax_job.cover_page_details
            
            # Update fields
            for field_name, label in self.cover_page_labels.items():
                value = cover_data.get(field_name, '') or '-'
                label.setText(str(value))
            
            # Update text fields
            self.comments_label.setText(cover_data.get('comments', '') or '')
            self.message_label.setText(cover_data.get('msg', '') or '')
            
        except Exception as e:
            self.logger.error(f"Error parsing cover page details: {e}")
            self.comments_label.setText(f"Error parsing cover page data: {str(e)}")
    
    def update_technical_details(self, fax_job):
        """Update technical details tab"""
        technical_info = []
        
        technical_info.append("=== FAX JOB TECHNICAL DETAILS ===\n")
        technical_info.append(f"Fax ID: {fax_job.fax_id}")
        technical_info.append(f"Entry URL: {fax_job.fax_entry_url or 'N/A'}")
        technical_info.append(f"PDF Path: {fax_job.pdf_path or 'N/A'}")
        technical_info.append(f"Created: {fax_job.created_at}")
        technical_info.append(f"Sent: {fax_job.sent_at or 'Not sent'}")
        technical_info.append("")
        
        # XML content (if available)
        if fax_job.xml_content:
            technical_info.append("=== XML CONTENT ===")
            technical_info.append(fax_job.xml_content)
        else:
            technical_info.append("=== XML CONTENT ===")
            technical_info.append("No XML content available")
        
        self.technical_text.setText("\n".join(technical_info))
    
    def clear_fax_details(self):
        """Clear the fax details panel"""
        # Clear general info
        for label in self.info_labels.values():
            label.setText("-")
        
        # Clear cover page
        for label in self.cover_page_labels.values():
            label.setText("-")
        self.comments_label.clear()
        self.message_label.clear()
        
        # Clear technical
        self.technical_text.clear()
    
    def show_context_menu(self, position):
        """Show context menu for fax table"""
        if self.fax_table.itemAt(position) is None:
            return
        
        menu = QMenu(self)
        
        view_action = QAction("View Details", self)
        view_action.triggered.connect(self.view_full_details)
        menu.addAction(view_action)
        
        resend_action = QAction("Resend Fax", self)
        resend_action.triggered.connect(self.resend_fax)
        menu.addAction(resend_action)
        
        menu.addSeparator()
        
        export_action = QAction("Export Details", self)
        export_action.triggered.connect(self.export_fax_details)
        menu.addAction(export_action)
        
        menu.exec(self.fax_table.mapToGlobal(position))
    
    def view_full_details(self):
        """View full details of selected fax job"""
        if not self.selected_fax_job:
            return
        
        # Create a detailed view dialog
        dialog = QDialog(self)
        dialog.setWindowTitle(f"Fax Details - ID {self.selected_fax_job.fax_id}")
        dialog.setGeometry(300, 300, 800, 600)
        
        layout = QVBoxLayout(dialog)
        
        # Full details text
        details_text = QTextEdit()
        details_text.setReadOnly(True)
        details_text.setFont(QFont("Courier", 10))
        
        # Generate detailed text
        details = self.generate_full_details_text(self.selected_fax_job)
        details_text.setText(details)
        
        layout.addWidget(details_text)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        layout.addWidget(close_btn)
        
        dialog.exec()
    
    def generate_full_details_text(self, fax_job):
        """Generate full details text for a fax job"""
        lines = []
        
        lines.append("=" * 60)
        lines.append(f"FAX JOB DETAILS - ID: {fax_job.fax_id}")
        lines.append("=" * 60)
        lines.append("")
        
        # Basic info
        lines.append("BASIC INFORMATION:")
        lines.append(f"  Status: {fax_job.status or 'Unknown'}")
        lines.append(f"  Created: {fax_job.created_at or 'N/A'}")
        lines.append(f"  Sent: {fax_job.sent_at or 'Not sent'}")
        lines.append(f"  Entry URL: {fax_job.fax_entry_url or 'N/A'}")
        lines.append("")
        
        # Sender info
        lines.append("SENDER INFORMATION:")
        lines.append(f"  Name: {fax_job.sender_name or 'N/A'}")
        lines.append(f"  Email: {fax_job.sender_email or 'N/A'}")
        lines.append("")
        
        # Recipient info
        lines.append("RECIPIENT INFORMATION:")
        contact = self.contacts.get(fax_job.recipient_id)
        if contact:
            lines.append(f"  Name: {contact.name}")
            lines.append(f"  Fax: {contact.fax_number}")
            lines.append(f"  Organization: {contact.organization or 'N/A'}")
            lines.append(f"  Phone: {contact.phone_number or 'N/A'}")
            lines.append(f"  Email: {contact.email or 'N/A'}")
        else:
            lines.append(f"  Contact ID: {fax_job.recipient_id}")
            lines.append(f"  Fax: {fax_job.recipient_fax or 'N/A'}")
        lines.append("")
        
        # Fax settings
        lines.append("FAX SETTINGS:")
        lines.append(f"  Priority: {fax_job.priority or 'N/A'}")
        lines.append(f"  Max Attempts: {fax_job.max_attempts or 'N/A'}")
        lines.append(f"  Retry Interval: {fax_job.retry_interval or 'N/A'} minutes")
        lines.append("")
        
        # Cover page details
        if fax_job.cover_page_details:
            lines.append("COVER PAGE DETAILS:")
            try:
                if isinstance(fax_job.cover_page_details, str):
                    cover_data = json.loads(fax_job.cover_page_details)
                else:
                    cover_data = fax_job.cover_page_details
                
                for key, value in cover_data.items():
                    if value:
                        lines.append(f"  {key.title()}: {value}")
            except Exception as e:
                lines.append(f"  Error parsing cover page: {str(e)}")
            lines.append("")
        
        # File info
        lines.append("FILE INFORMATION:")
        lines.append(f"  PDF Path: {fax_job.pdf_path or 'N/A'}")
        lines.append("")
        
        # XML content
        if fax_job.xml_content:
            lines.append("XML CONTENT:")
            lines.append("-" * 40)
            lines.append(fax_job.xml_content)
        
        return "\n".join(lines)
    
    def resend_fax(self):
        """Resend the selected fax job"""
        if not self.selected_fax_job:
            return
        
        reply = QMessageBox.question(
            self,
            "Resend Fax",
            f"Are you sure you want to resend fax job {self.selected_fax_job.fax_id}?\n\n"
            "This will create a new fax job with the same details.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Emit signal to parent window to handle resending
            self.fax_selected.emit(self.selected_fax_job)
            QMessageBox.information(self, "Resend Initiated", "Fax resend has been initiated.")
    
    def export_fax_details(self):
        """Export fax details to a text file"""
        if not self.selected_fax_job:
            return
        
        from PyQt6.QtWidgets import QFileDialog
        
        # Get save location
        filename = f"fax_details_{self.selected_fax_job.fax_id}.txt"
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Fax Details",
            filename,
            "Text Files (*.txt);;All Files (*)"
        )
        
        if file_path:
            try:
                details = self.generate_full_details_text(self.selected_fax_job)
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(details)
                
                QMessageBox.information(
                    self,
                    "Export Complete",
                    f"Fax details exported to:\n{file_path}"
                )
                
            except Exception as e:
                self.logger.error(f"Error exporting fax details: {e}")
                QMessageBox.critical(
                    self,
                    "Export Error",
                    f"Failed to export fax details: {str(e)}"
                )
 
# --- END OF FILE: fax_history_window.py --- 
 
# --- START OF FILE: settings_window.py --- 
 
"""
Settings Window for MCFax Application
Allows users to configure FaxFinder connection and other application settings
"""

import logging
from PyQt6.QtWidgets import (
    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QPushButton, QLabel, QLineEdit, QCheckBox, QGroupBox,
    QTabWidget, QMessageBox, QSpinBox, QComboBox
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont

from core.settings import get_settings
from fax.faxfinder_api import FaxFinderAPI

class SettingsWindow(QDialog):
    """Settings configuration window"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(__name__)
        self.settings = get_settings()
        
        self.setup_ui()
        self.load_current_settings()
    
    def setup_ui(self):
        """Setup the user interface"""
        self.setWindowTitle("MCFax Settings")
        self.setGeometry(200, 200, 600, 500)
        self.setModal(True)
        
        # Main layout
        main_layout = QVBoxLayout(self)
        
        # Create tab widget
        self.tab_widget = QTabWidget()
        main_layout.addWidget(self.tab_widget)
        
        # Create tabs
        self.create_faxfinder_tab()
        self.create_database_tab()
        self.create_general_tab()
        self.create_sender_tab()
        
        # Button layout
        button_layout = QHBoxLayout()
        
        # Test connection button
        self.test_btn = QPushButton("Test FaxFinder Connection")
        self.test_btn.clicked.connect(self.test_faxfinder_connection)
        button_layout.addWidget(self.test_btn)
        
        button_layout.addStretch()
        
        # Save and Cancel buttons
        save_btn = QPushButton("Save Settings")
        save_btn.clicked.connect(self.save_settings)
        save_btn.setDefault(True)
        button_layout.addWidget(save_btn)
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        main_layout.addLayout(button_layout)
    
    def create_faxfinder_tab(self):
        """Create FaxFinder configuration tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # FaxFinder Connection Settings
        faxfinder_group = QGroupBox("FaxFinder Connection Settings")
        faxfinder_layout = QGridLayout(faxfinder_group)
        
        # Host/IP Address
        faxfinder_layout.addWidget(QLabel("Host/IP Address:"), 0, 0)
        self.host_edit = QLineEdit()
        self.host_edit.setPlaceholderText("192.168.1.100 or faxfinder.local")
        faxfinder_layout.addWidget(self.host_edit, 0, 1)
        
        # Username
        faxfinder_layout.addWidget(QLabel("Username:"), 1, 0)
        self.username_edit = QLineEdit()
        self.username_edit.setPlaceholderText("admin")
        faxfinder_layout.addWidget(self.username_edit, 1, 1)
        
        # Password
        faxfinder_layout.addWidget(QLabel("Password:"), 2, 0)
        self.password_edit = QLineEdit()
        self.password_edit.setEchoMode(QLineEdit.EchoMode.Password)
        self.password_edit.setPlaceholderText("Enter password")
        faxfinder_layout.addWidget(self.password_edit, 2, 1)
        
        # Use HTTPS
        self.use_https_checkbox = QCheckBox("Use HTTPS (Secure Connection)")
        faxfinder_layout.addWidget(self.use_https_checkbox, 3, 0, 1, 2)
        
        # Auto Submit
        self.auto_submit_checkbox = QCheckBox("Automatically submit faxes to FaxFinder")
        faxfinder_layout.addWidget(self.auto_submit_checkbox, 4, 0, 1, 2)
        
        layout.addWidget(faxfinder_group)
        
        # Connection Status
        status_group = QGroupBox("Connection Status")
        status_layout = QVBoxLayout(status_group)
        
        self.connection_status_label = QLabel("Status: Not tested")
        self.connection_status_label.setStyleSheet("QLabel { color: #666; }")
        status_layout.addWidget(self.connection_status_label)
        
        layout.addWidget(status_group)
        
        # Help text
        help_group = QGroupBox("Configuration Help")
        help_layout = QVBoxLayout(help_group)
        
        help_text = QLabel("""
<b>FaxFinder Configuration:</b><br>
• <b>Host/IP Address:</b> The IP address or hostname of your FaxFinder device<br>
• <b>Username/Password:</b> Login credentials for the FaxFinder web interface<br>
• <b>HTTPS:</b> Enable if your FaxFinder is configured for secure connections<br>
• <b>Auto Submit:</b> Automatically send faxes to FaxFinder when created<br><br>

<b>Default FaxFinder Settings:</b><br>
• Username: admin<br>
• Password: (device default or custom)<br>
• Port: 80 (HTTP) or 443 (HTTPS)<br>
        """)
        help_text.setWordWrap(True)
        help_text.setStyleSheet("QLabel { color: #444; font-size: 11px; }")
        help_layout.addWidget(help_text)
        
        layout.addWidget(help_group)
        
        layout.addStretch()
        
        self.tab_widget.addTab(tab, "FaxFinder")
    
    def create_database_tab(self):
        """Create database configuration tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Database Connection Settings
        database_group = QGroupBox("Database Connection Settings")
        database_layout = QGridLayout(database_group)
        
        # Server/IP Address
        database_layout.addWidget(QLabel("Server/IP Address:"), 0, 0)
        self.db_server_edit = QLineEdit()
        self.db_server_edit.setPlaceholderText("10.70.1.251 or server.domain.com")
        database_layout.addWidget(self.db_server_edit, 0, 1)
        
        # Database Name
        database_layout.addWidget(QLabel("Database Name:"), 1, 0)
        self.db_database_edit = QLineEdit()
        self.db_database_edit.setPlaceholderText("MCFAX")
        database_layout.addWidget(self.db_database_edit, 1, 1)
        
        # Username
        database_layout.addWidget(QLabel("Username:"), 2, 0)
        self.db_username_edit = QLineEdit()
        self.db_username_edit.setPlaceholderText("SA")
        database_layout.addWidget(self.db_username_edit, 2, 1)
        
        # Password
        database_layout.addWidget(QLabel("Password:"), 3, 0)
        self.db_password_edit = QLineEdit()
        self.db_password_edit.setEchoMode(QLineEdit.EchoMode.Password)
        self.db_password_edit.setPlaceholderText("Enter database password")
        database_layout.addWidget(self.db_password_edit, 3, 1)
        
        layout.addWidget(database_group)
        
        # Database Status
        db_status_group = QGroupBox("Database Status")
        db_status_layout = QVBoxLayout(db_status_group)
        
        self.db_connection_status_label = QLabel("Status: Not tested")
        self.db_connection_status_label.setStyleSheet("QLabel { color: #666; }")
        db_status_layout.addWidget(self.db_connection_status_label)
        
        # Test database connection button
        self.test_db_btn = QPushButton("Test Database Connection")
        self.test_db_btn.clicked.connect(self.test_database_connection)
        db_status_layout.addWidget(self.test_db_btn)
        
        layout.addWidget(db_status_group)
        
        # Help text
        db_help_group = QGroupBox("Configuration Help")
        db_help_layout = QVBoxLayout(db_help_group)
        
        db_help_text = QLabel("""
<b>Database Configuration:</b><br>
• <b>Server/IP Address:</b> The IP address or hostname of your SQL Server<br>
• <b>Database Name:</b> The name of the MCFax database (usually "MCFAX")<br>
• <b>Username/Password:</b> SQL Server authentication credentials<br><br>

<b>Connection Requirements:</b><br>
• SQL Server must be accessible from this machine<br>
• ODBC Driver 17 for SQL Server must be installed<br>
• Database user must have appropriate permissions<br>
• TrustServerCertificate is enabled for secure connections<br><br>

<b>Default Settings:</b><br>
• Server: 10.70.1.251<br>
• Database: MCFAX<br>
• Username: SA<br>
        """)
        db_help_text.setWordWrap(True)
        db_help_text.setStyleSheet("QLabel { color: #444; font-size: 11px; }")
        db_help_layout.addWidget(db_help_text)
        
        layout.addWidget(db_help_group)
        
        layout.addStretch()
        
        self.tab_widget.addTab(tab, "Database")
    
    def create_general_tab(self):
        """Create general settings tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # System Settings
        system_group = QGroupBox("System Settings")
        system_layout = QGridLayout(system_group)
        
        # Auto refresh interval
        system_layout.addWidget(QLabel("Auto Refresh Interval:"), 0, 0)
        self.refresh_interval_spin = QSpinBox()
        self.refresh_interval_spin.setRange(1000, 60000)
        self.refresh_interval_spin.setSingleStep(1000)
        self.refresh_interval_spin.setSuffix(" ms")
        self.refresh_interval_spin.setValue(5000)
        system_layout.addWidget(self.refresh_interval_spin, 0, 1)
        
        # Enable folder monitoring
        self.folder_monitoring_checkbox = QCheckBox("Enable automatic folder monitoring")
        system_layout.addWidget(self.folder_monitoring_checkbox, 1, 0, 1, 2)
        
        # Log level
        system_layout.addWidget(QLabel("Log Level:"), 2, 0)
        self.log_level_combo = QComboBox()
        self.log_level_combo.addItems(["DEBUG", "INFO", "WARNING", "ERROR"])
        self.log_level_combo.setCurrentText("INFO")
        system_layout.addWidget(self.log_level_combo, 2, 1)
        
        layout.addWidget(system_group)
        
        # PDF Settings
        pdf_group = QGroupBox("PDF Settings")
        pdf_layout = QGridLayout(pdf_group)
        
        # Default zoom level
        pdf_layout.addWidget(QLabel("Default Zoom Level:"), 0, 0)
        self.zoom_level_spin = QSpinBox()
        self.zoom_level_spin.setRange(25, 500)
        self.zoom_level_spin.setSingleStep(25)
        self.zoom_level_spin.setSuffix("%")
        self.zoom_level_spin.setValue(100)
        pdf_layout.addWidget(self.zoom_level_spin, 0, 1)
        
        # Auto save edits
        self.auto_save_checkbox = QCheckBox("Automatically save PDF edits")
        pdf_layout.addWidget(self.auto_save_checkbox, 1, 0, 1, 2)
        
        # Preview quality
        pdf_layout.addWidget(QLabel("Preview Quality:"), 2, 0)
        self.preview_quality_combo = QComboBox()
        self.preview_quality_combo.addItems(["low", "medium", "high"])
        self.preview_quality_combo.setCurrentText("high")
        pdf_layout.addWidget(self.preview_quality_combo, 2, 1)
        
        layout.addWidget(pdf_group)
        
        # Fax Defaults
        fax_group = QGroupBox("Fax Job Defaults")
        fax_layout = QGridLayout(fax_group)
        
        # Default priority
        fax_layout.addWidget(QLabel("Default Priority:"), 0, 0)
        self.priority_combo = QComboBox()
        self.priority_combo.addItems(["1st", "High", "Medium/High", "Medium", "Medium/Low", "Low"])
        self.priority_combo.setCurrentText("Medium")
        fax_layout.addWidget(self.priority_combo, 0, 1)
        
        # Max attempts
        fax_layout.addWidget(QLabel("Max Attempts:"), 1, 0)
        self.max_attempts_spin = QSpinBox()
        self.max_attempts_spin.setRange(1, 10)
        self.max_attempts_spin.setValue(3)
        fax_layout.addWidget(self.max_attempts_spin, 1, 1)
        
        # Retry interval
        fax_layout.addWidget(QLabel("Retry Interval:"), 2, 0)
        self.retry_interval_spin = QSpinBox()
        self.retry_interval_spin.setRange(1, 60)
        self.retry_interval_spin.setValue(5)
        self.retry_interval_spin.setSuffix(" minutes")
        fax_layout.addWidget(self.retry_interval_spin, 2, 1)
        
        # Include cover page
        self.include_cover_checkbox = QCheckBox("Include cover page by default")
        self.include_cover_checkbox.setChecked(True)
        fax_layout.addWidget(self.include_cover_checkbox, 3, 0, 1, 2)
        
        layout.addWidget(fax_group)
        
        layout.addStretch()
        
        self.tab_widget.addTab(tab, "General")
    
    def create_sender_tab(self):
        """Create sender information tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Sender Information
        sender_group = QGroupBox("Default Sender Information")
        sender_layout = QGridLayout(sender_group)
        
        # From Name
        sender_layout.addWidget(QLabel("From Name:"), 0, 0)
        self.from_name_edit = QLineEdit()
        self.from_name_edit.setPlaceholderText("Your full name")
        sender_layout.addWidget(self.from_name_edit, 0, 1)
        
        # From Company
        sender_layout.addWidget(QLabel("Company:"), 1, 0)
        self.from_company_edit = QLineEdit()
        self.from_company_edit.setText("The Spine Hospital Louisiana")
        sender_layout.addWidget(self.from_company_edit, 1, 1)
        
        # From Phone
        sender_layout.addWidget(QLabel("Phone:"), 2, 0)
        self.from_phone_edit = QLineEdit()
        self.from_phone_edit.setText("(225) 906-4805")
        sender_layout.addWidget(self.from_phone_edit, 2, 1)
        
        # From Fax
        sender_layout.addWidget(QLabel("Fax Number:"), 3, 0)
        self.from_fax_edit = QLineEdit()
        self.from_fax_edit.setText("(225) 763-2085")
        sender_layout.addWidget(self.from_fax_edit, 3, 1)
        
        layout.addWidget(sender_group)
        
        # Help text
        help_group = QGroupBox("Information")
        help_layout = QVBoxLayout(help_group)
        
        help_text = QLabel("""
<b>Sender Information:</b><br>
This information will be used as defaults when creating new fax jobs and cover pages.<br>
You can override these values for individual fax jobs if needed.<br><br>

<b>Note:</b> Changes to sender information will only affect new fax jobs.<br>
Existing fax jobs will retain their original sender information.
        """)
        help_text.setWordWrap(True)
        help_text.setStyleSheet("QLabel { color: #444; font-size: 11px; }")
        help_layout.addWidget(help_text)
        
        layout.addWidget(help_group)
        
        layout.addStretch()
        
        self.tab_widget.addTab(tab, "Sender Info")
    
    def load_current_settings(self):
        """Load current settings into the form"""
        try:
            # Load FaxFinder settings
            faxfinder_settings = self.settings.get_faxfinder_settings()
            self.host_edit.setText(faxfinder_settings.get('host', ''))
            self.username_edit.setText(faxfinder_settings.get('username', ''))
            self.password_edit.setText(faxfinder_settings.get('password', ''))
            self.use_https_checkbox.setChecked(faxfinder_settings.get('use_https', False))
            self.auto_submit_checkbox.setChecked(faxfinder_settings.get('auto_submit', False))
            
            # Load general settings
            self.refresh_interval_spin.setValue(self.settings.get_auto_refresh_interval())
            self.folder_monitoring_checkbox.setChecked(self.settings.is_folder_monitoring_enabled())
            
            # Load PDF settings
            pdf_settings = self.settings.get_pdf_settings()
            zoom_percent = int(pdf_settings.get('default_zoom_level', 1.0) * 100)
            self.zoom_level_spin.setValue(zoom_percent)
            self.auto_save_checkbox.setChecked(pdf_settings.get('auto_save_edits', True))
            self.preview_quality_combo.setCurrentText(pdf_settings.get('preview_quality', 'high'))
            
            # Load fax defaults
            fax_defaults = self.settings.get_fax_defaults()
            self.priority_combo.setCurrentText(fax_defaults.get('priority', 'Medium'))
            self.max_attempts_spin.setValue(fax_defaults.get('max_attempts', 3))
            self.retry_interval_spin.setValue(fax_defaults.get('retry_interval', 5))
            self.include_cover_checkbox.setChecked(fax_defaults.get('include_cover_page', True))
            
            # Load database settings
            database_settings = self.settings.get("database", {})
            self.db_server_edit.setText(database_settings.get('server', '10.70.1.251'))
            self.db_database_edit.setText(database_settings.get('database', 'MCFAX'))
            self.db_username_edit.setText(database_settings.get('username', 'SA'))
            self.db_password_edit.setText(database_settings.get('password', ''))
            
            # Load sender info
            sender_info = self.settings.get_sender_info()
            self.from_name_edit.setText(sender_info.get('from_name', ''))
            self.from_company_edit.setText(sender_info.get('from_company', 'The Spine Hospital Louisiana'))
            self.from_phone_edit.setText(sender_info.get('from_phone', '(225) 906-4805'))
            self.from_fax_edit.setText(sender_info.get('from_fax', '(225) 763-2085'))
            
            self.logger.info("Settings loaded into form")
            
        except Exception as e:
            self.logger.error(f"Error loading settings: {e}")
            QMessageBox.warning(self, "Settings Error", f"Error loading settings: {str(e)}")
    
    def save_settings(self):
        """Save settings from the form"""
        try:
            # Save FaxFinder settings
            self.settings.set_faxfinder_settings(
                host=self.host_edit.text().strip(),
                username=self.username_edit.text().strip(),
                password=self.password_edit.text(),
                use_https=self.use_https_checkbox.isChecked(),
                auto_submit=self.auto_submit_checkbox.isChecked()
            )
            
            # Save general settings
            self.settings.set_auto_refresh_interval(self.refresh_interval_spin.value())
            self.settings.set_folder_monitoring_enabled(self.folder_monitoring_checkbox.isChecked())
            
            # Save PDF settings
            zoom_level = self.zoom_level_spin.value() / 100.0
            self.settings.set_pdf_setting('default_zoom_level', zoom_level)
            self.settings.set_pdf_setting('auto_save_edits', self.auto_save_checkbox.isChecked())
            self.settings.set_pdf_setting('preview_quality', self.preview_quality_combo.currentText())
            
            # Save fax defaults
            self.settings.set_fax_default('priority', self.priority_combo.currentText())
            self.settings.set_fax_default('max_attempts', self.max_attempts_spin.value())
            self.settings.set_fax_default('retry_interval', self.retry_interval_spin.value())
            self.settings.set_fax_default('include_cover_page', self.include_cover_checkbox.isChecked())
            
            # Save database settings
            self.settings.set("database.server", self.db_server_edit.text().strip())
            self.settings.set("database.database", self.db_database_edit.text().strip())
            self.settings.set("database.username", self.db_username_edit.text().strip())
            self.settings.set("database.password", self.db_password_edit.text())
            
            # Save sender info
            self.settings.set_sender_info(
                from_name=self.from_name_edit.text().strip(),
                from_company=self.from_company_edit.text().strip(),
                from_phone=self.from_phone_edit.text().strip(),
                from_fax=self.from_fax_edit.text().strip()
            )
            
            # Save to file
            if self.settings.save_settings():
                QMessageBox.information(self, "Settings Saved", "Settings have been saved successfully!")
                self.logger.info("Settings saved successfully")
                self.accept()
            else:
                QMessageBox.warning(self, "Save Error", "Failed to save settings to file.")
                
        except Exception as e:
            self.logger.error(f"Error saving settings: {e}")
            QMessageBox.critical(self, "Save Error", f"Error saving settings: {str(e)}")
    
    def test_faxfinder_connection(self):
        """Test the FaxFinder connection"""
        try:
            # Get connection details from form
            host = self.host_edit.text().strip()
            username = self.username_edit.text().strip()
            password = self.password_edit.text()
            use_https = self.use_https_checkbox.isChecked()
            
            # Validate required fields
            if not host:
                QMessageBox.warning(self, "Missing Information", "Please enter the FaxFinder host/IP address.")
                self.host_edit.setFocus()
                return
            
            if not username:
                QMessageBox.warning(self, "Missing Information", "Please enter the username.")
                self.username_edit.setFocus()
                return
            
            if not password:
                QMessageBox.warning(self, "Missing Information", "Please enter the password.")
                self.password_edit.setFocus()
                return
            
            # Update status
            self.connection_status_label.setText("Status: Testing connection...")
            self.connection_status_label.setStyleSheet("QLabel { color: orange; }")
            self.test_btn.setEnabled(False)
            
            # Test connection
            api = FaxFinderAPI(host, username, password, use_https)
            result = api.test_connection()
            
            if result['success']:
                self.connection_status_label.setText("Status: ✅ Connection successful!")
                self.connection_status_label.setStyleSheet("QLabel { color: green; }")
                QMessageBox.information(
                    self, 
                    "Connection Test", 
                    f"Successfully connected to FaxFinder!\n\n"
                    f"Host: {host}\n"
                    f"Protocol: {'HTTPS' if use_https else 'HTTP'}\n"
                    f"Response: {result.get('message', 'Connection OK')}"
                )
            else:
                error_msg = result.get('error', 'Unknown error')
                self.connection_status_label.setText(f"Status: ❌ Connection failed")
                self.connection_status_label.setStyleSheet("QLabel { color: red; }")
                QMessageBox.warning(
                    self, 
                    "Connection Test Failed", 
                    f"Failed to connect to FaxFinder:\n\n{error_msg}\n\n"
                    f"Please check:\n"
                    f"• Host/IP address is correct\n"
                    f"• Username and password are correct\n"
                    f"• FaxFinder is powered on and accessible\n"
                    f"• Network connectivity"
                )
            
        except Exception as e:
            self.connection_status_label.setText("Status: ❌ Test error")
            self.connection_status_label.setStyleSheet("QLabel { color: red; }")
            self.logger.error(f"Error testing FaxFinder connection: {e}")
            QMessageBox.critical(
                self, 
                "Connection Test Error", 
                f"An error occurred while testing the connection:\n\n{str(e)}"
            )
        
        finally:
            self.test_btn.setEnabled(True)
    
    def test_database_connection(self):
        """Test the database connection"""
        try:
            # Get connection details from form
            server = self.db_server_edit.text().strip()
            database = self.db_database_edit.text().strip()
            username = self.db_username_edit.text().strip()
            password = self.db_password_edit.text()
            
            # Validate required fields
            if not server:
                QMessageBox.warning(self, "Missing Information", "Please enter the database server/IP address.")
                self.db_server_edit.setFocus()
                return
            
            if not database:
                QMessageBox.warning(self, "Missing Information", "Please enter the database name.")
                self.db_database_edit.setFocus()
                return
            
            if not username:
                QMessageBox.warning(self, "Missing Information", "Please enter the database username.")
                self.db_username_edit.setFocus()
                return
            
            if not password:
                QMessageBox.warning(self, "Missing Information", "Please enter the database password.")
                self.db_password_edit.setFocus()
                return
            
            # Update status
            self.db_connection_status_label.setText("Status: Testing connection...")
            self.db_connection_status_label.setStyleSheet("QLabel { color: orange; }")
            self.test_db_btn.setEnabled(False)
            
            # Test connection
            from database.connection import DatabaseConnection
            db_conn = DatabaseConnection(server, database, username, password)
            result = db_conn.test_connection()
            
            if result['connected']:
                self.db_connection_status_label.setText("Status: ✅ Connection successful!")
                self.db_connection_status_label.setStyleSheet("QLabel { color: green; }")
                QMessageBox.information(
                    self, 
                    "Database Connection Test", 
                    f"Successfully connected to database!\n\n"
                    f"Server: {result.get('server')}\n"
                    f"Database: {result.get('database')}\n"
                    f"Server Time: {result.get('server_time')}\n"
                    f"SQL Server Version: {result.get('version', 'Unknown')[:50]}..."
                )
            else:
                error_msg = result.get('error', 'Unknown error')
                self.db_connection_status_label.setText(f"Status: ❌ Connection failed")
                self.db_connection_status_label.setStyleSheet("QLabel { color: red; }")
                QMessageBox.warning(
                    self, 
                    "Database Connection Test Failed", 
                    f"Failed to connect to database:\n\n{error_msg}\n\n"
                    f"Please check:\n"
                    f"• Server/IP address is correct\n"
                    f"• Database name is correct\n"
                    f"• Username and password are correct\n"
                    f"• SQL Server is running and accessible\n"
                    f"• ODBC Driver 17 for SQL Server is installed\n"
                    f"• Network connectivity and firewall settings"
                )
            
        except Exception as e:
            self.db_connection_status_label.setText("Status: ❌ Test error")
            self.db_connection_status_label.setStyleSheet("QLabel { color: red; }")
            self.logger.error(f"Error testing database connection: {e}")
            QMessageBox.critical(
                self, 
                "Database Connection Test Error", 
                f"An error occurred while testing the database connection:\n\n{str(e)}\n\n"
                f"Please ensure:\n"
                f"• ODBC Driver 17 for SQL Server is installed\n"
                f"• SQL Server is accessible from this machine\n"
                f"• Connection parameters are correct"
            )
        
        finally:
            self.test_db_btn.setEnabled(True)
 
# --- END OF FILE: settings_window.py --- 
 
# --- START OF FILE: integrated_pdf_viewer.py --- 
 
"""
Integrated PDF Viewer Widget
Displays PDF content directly in the widget with editing capabilities
"""

import logging
from pathlib import Path
from typing import Optional, List, Dict, Any
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QScrollArea
)
from PyQt6.QtCore import Qt, pyqtSignal, QPoint, QRect
from PyQt6.QtGui import (
    QPixmap, QPainter, QColor, QPen, QBrush, QFont,
    QMouseEvent, QPaintEvent
)

try:
    import fitz  # PyMuPDF
    PYMUPDF_AVAILABLE = True
except ImportError:
    PYMUPDF_AVAILABLE = False

class DrawingCanvas(QLabel):
    """Canvas widget for drawing redactions and annotations on PDF pages"""
    
    def __init__(self, page_image: QPixmap, page_number: int, pdf_page_size: tuple = None):
        super().__init__()
        self.page_image = page_image
        self.page_number = page_number
        self.logger = logging.getLogger(__name__)
        
        # Store original PDF page size for coordinate transformation
        self.pdf_page_size = pdf_page_size or (page_image.width(), page_image.height())
        self.current_zoom_level = 1.0  # Track current zoom level
        
        # Drawing state
        self.drawing = False
        self.brush_size = 10
        self.brush_color = QColor(0, 0, 0)  # Black for redaction
        self.current_tool = "redaction"  # redaction, text, rectangle
        
        # Drawing data - coordinates stored in PDF space (not display space)
        self.brush_strokes = []  # List of stroke paths in PDF coordinates
        self.annotations = []    # List of text/shape annotations in PDF coordinates
        self.excluded = False    # Whether this page is excluded
        
        # Undo/redo
        self.history = []
        self.history_index = -1
        
        # Setup canvas
        self.setPixmap(page_image)
        self.setMinimumSize(page_image.size())
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Enable mouse tracking
        self.setMouseTracking(True)
        
        # Create overlay for drawing
        self.overlay = QPixmap(page_image.size())
        self.overlay.fill(Qt.GlobalColor.transparent)
        
        self.update_display()
    
    def set_brush_size(self, size: int):
        """Set brush size for redaction"""
        self.brush_size = size
    
    def set_brush_color(self, color: QColor):
        """Set brush color"""
        self.brush_color = color
    
    def set_tool(self, tool: str):
        """Set current drawing tool"""
        self.current_tool = tool
    
    def set_excluded(self, excluded: bool):
        """Set whether this page is excluded from final PDF"""
        self.excluded = excluded
        self.update_display()
    
    def mousePressEvent(self, event: QMouseEvent):
        """Handle mouse press events"""
        if event.button() == Qt.MouseButton.LeftButton:
            if self.current_tool in ["redaction", "highlight"]:
                self.drawing = True
                # Convert display coordinates to PDF coordinates
                pdf_point = self.display_to_pdf_coordinates(event.position().toPoint())
                self.current_stroke = [pdf_point]
                self.save_state()
            elif self.current_tool == "text":
                # Handle text placement - convert to PDF coordinates
                pdf_point = self.display_to_pdf_coordinates(event.position().toPoint())
                self.handle_text_placement(pdf_point)
    
    def mouseMoveEvent(self, event: QMouseEvent):
        """Handle mouse move events"""
        if self.drawing and self.current_tool in ["redaction", "highlight"]:
            # Convert display coordinates to PDF coordinates
            pdf_point = self.display_to_pdf_coordinates(event.position().toPoint())
            self.current_stroke.append(pdf_point)
            self.draw_current_stroke()
    
    def mouseReleaseEvent(self, event: QMouseEvent):
        """Handle mouse release events"""
        if event.button() == Qt.MouseButton.LeftButton and self.drawing:
            self.drawing = False
            if hasattr(self, 'current_stroke') and len(self.current_stroke) > 1:
                # Save the completed stroke in PDF coordinates
                stroke_data = {
                    'type': self.current_tool,  # Use current tool (redaction or highlight)
                    'points': [(p.x(), p.y()) if hasattr(p, 'x') else p for p in self.current_stroke],
                    'brush_size': self.brush_size,
                    'color': self.brush_color.name()
                }
                self.brush_strokes.append(stroke_data)
                self.redraw_overlay()
    
    def draw_current_stroke(self):
        """Draw the current stroke being drawn"""
        if not hasattr(self, 'current_stroke') or len(self.current_stroke) < 2:
            return
        
        # Create temporary pixmap for current stroke
        temp_overlay = self.overlay.copy()
        painter = QPainter(temp_overlay)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Set up pen for redaction - scale brush size for current zoom
        display_brush_size = max(1, int(self.brush_size * self.current_zoom_level))
        pen = QPen(self.brush_color, display_brush_size, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin)
        painter.setPen(pen)
        
        # Convert PDF coordinates to display coordinates and draw
        display_points = []
        for point in self.current_stroke:
            if hasattr(point, 'x'):
                display_point = self.pdf_to_display_coordinates(point)
            else:
                # Handle tuple format
                display_point = self.pdf_to_display_coordinates(QPoint(point[0], point[1]))
            display_points.append(display_point)
        
        # Draw the stroke
        for i in range(1, len(display_points)):
            painter.drawLine(display_points[i-1], display_points[i])
        
        painter.end()
        
        # Update display
        self.update_display_with_overlay(temp_overlay)
    
    def redraw_overlay(self):
        """Redraw the entire overlay from saved data"""
        self.overlay.fill(Qt.GlobalColor.transparent)
        painter = QPainter(self.overlay)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Draw all brush strokes
        for stroke in self.brush_strokes:
            if stroke['type'] in ['redaction', 'highlight']:
                color = QColor(stroke['color'])
                
                # Scale brush size for current zoom level
                display_brush_size = max(1, int(stroke['brush_size'] * self.current_zoom_level))
                
                # Set different drawing styles for different tools
                if stroke['type'] == 'highlight':
                    # Semi-transparent yellow for highlights
                    color.setAlpha(128)  # 50% transparency
                    pen = QPen(color, display_brush_size, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin)
                else:  # redaction
                    # Solid color for redaction
                    pen = QPen(color, display_brush_size, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin)
                
                painter.setPen(pen)
                
                # Convert PDF coordinates to display coordinates
                display_points = []
                for x, y in stroke['points']:
                    display_point = self.pdf_to_display_coordinates(QPoint(x, y))
                    display_points.append(display_point)
                
                # Draw the stroke
                for i in range(1, len(display_points)):
                    painter.drawLine(display_points[i-1], display_points[i])
        
        # Draw annotations
        for annotation in self.annotations:
            if annotation['type'] == 'text':
                # Convert PDF coordinates to display coordinates
                display_point = self.pdf_to_display_coordinates(QPoint(annotation['x'], annotation['y']))
                display_font_size = max(8, int(annotation.get('size', 12) * self.current_zoom_level))
                
                painter.setPen(QPen(QColor(annotation['color']), 2))
                painter.setFont(QFont(annotation.get('font', 'Arial'), display_font_size))
                painter.drawText(display_point, annotation['text'])
            elif annotation['type'] == 'rectangle':
                # Convert PDF coordinates to display coordinates
                top_left = self.pdf_to_display_coordinates(QPoint(annotation['x'], annotation['y']))
                width = int(annotation['width'] * self.current_zoom_level)
                height = int(annotation['height'] * self.current_zoom_level)
                
                painter.setPen(QPen(QColor(annotation['color']), 2))
                painter.drawRect(QRect(top_left.x(), top_left.y(), width, height))
        
        painter.end()
        self.update_display()
    
    def update_display(self):
        """Update the display with current overlay"""
        self.update_display_with_overlay(self.overlay)
    
    def update_display_with_overlay(self, overlay: QPixmap):
        """Update display with specified overlay"""
        # Combine original image with overlay
        combined = self.page_image.copy()
        painter = QPainter(combined)
        
        # Add exclusion overlay if page is excluded
        if self.excluded:
            painter.fillRect(combined.rect(), QColor(255, 0, 0, 100))  # Semi-transparent red
            painter.setPen(QPen(QColor(255, 0, 0), 3))
            painter.setFont(QFont("Arial", 24, QFont.Weight.Bold))
            painter.drawText(combined.rect(), Qt.AlignmentFlag.AlignCenter, "EXCLUDED")
        
        # Add drawing overlay
        painter.drawPixmap(0, 0, overlay)
        painter.end()
        
        self.setPixmap(combined)
    
    def save_state(self):
        """Save current state for undo functionality"""
        state = {
            'brush_strokes': self.brush_strokes.copy(),
            'annotations': self.annotations.copy(),
            'excluded': self.excluded
        }
        
        # Remove any states after current index (for redo)
        self.history = self.history[:self.history_index + 1]
        self.history.append(state)
        self.history_index += 1
        
        # Limit history size
        if len(self.history) > 50:
            self.history.pop(0)
            self.history_index -= 1
    
    def undo(self):
        """Undo last action"""
        if self.history_index > 0:
            self.history_index -= 1
            state = self.history[self.history_index]
            self.restore_state(state)
    
    def restore_state(self, state: Dict[str, Any]):
        """Restore canvas to a saved state"""
        self.brush_strokes = state['brush_strokes'].copy()
        self.annotations = state['annotations'].copy()
        self.excluded = state['excluded']
        self.redraw_overlay()
    
    def clear_all(self):
        """Clear all drawings and annotations"""
        self.save_state()
        self.brush_strokes.clear()
        self.annotations.clear()
        self.redraw_overlay()
    
    def handle_text_placement(self, pdf_position: QPoint):
        """Handle text placement when in text mode"""
        from PyQt6.QtWidgets import QInputDialog
        
        # Get text from user
        text, ok = QInputDialog.getText(self, 'Add Text', 'Enter text to add:')
        if ok and text.strip():
            # Position is already in PDF coordinates
            self.add_text_annotation(pdf_position.x(), pdf_position.y(), text.strip())
    
    def add_text_annotation(self, x: int, y: int, text: str, color: str = "#0000FF", font: str = "Arial", size: int = 12):
        """Add a text annotation - coordinates should be in PDF space"""
        self.save_state()
        annotation = {
            'type': 'text',
            'x': x,
            'y': y,
            'text': text,
            'color': color,
            'font': font,
            'size': size
        }
        self.annotations.append(annotation)
        self.redraw_overlay()
    
    def display_to_pdf_coordinates(self, display_point: QPoint) -> QPoint:
        """Convert display coordinates to PDF coordinates"""
        # Calculate the scale factor from display to PDF
        display_width = self.page_image.width()
        display_height = self.page_image.height()
        pdf_width, pdf_height = self.pdf_page_size
        
        # Calculate scale factors
        scale_x = pdf_width / display_width if display_width > 0 else 1.0
        scale_y = pdf_height / display_height if display_height > 0 else 1.0
        
        # Convert coordinates
        pdf_x = int(display_point.x() * scale_x)
        pdf_y = int(display_point.y() * scale_y)
        
        return QPoint(pdf_x, pdf_y)
    
    def pdf_to_display_coordinates(self, pdf_point: QPoint) -> QPoint:
        """Convert PDF coordinates to display coordinates"""
        # Calculate the scale factor from PDF to display
        display_width = self.page_image.width()
        display_height = self.page_image.height()
        pdf_width, pdf_height = self.pdf_page_size
        
        # Calculate scale factors
        scale_x = display_width / pdf_width if pdf_width > 0 else 1.0
        scale_y = display_height / pdf_height if pdf_height > 0 else 1.0
        
        # Convert coordinates
        display_x = int(pdf_point.x() * scale_x)
        display_y = int(pdf_point.y() * scale_y)
        
        return QPoint(display_x, display_y)
    
    def set_zoom_level(self, zoom_level: float):
        """Update the zoom level for coordinate transformations"""
        self.current_zoom_level = zoom_level
        # Redraw overlay with new zoom level
        self.redraw_overlay()

class IntegratedPDFViewer(QWidget):
    """
    Integrated PDF viewer widget that displays PDF content directly
    """
    
    page_changed = pyqtSignal(int)  # Emitted when page changes
    zoom_changed = pyqtSignal(float)  # Emitted when zoom changes
    
    def __init__(self, pdf_path: str, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(__name__)
        
        self.pdf_path = pdf_path
        self.pdf_document = None
        self.current_page = 0
        self.edit_mode = None
        self.excluded_pages = set()  # Set of excluded page numbers (0-based)
        
        # Load zoom level from settings
        try:
            from core.settings import get_settings
            settings = get_settings()
            self.zoom_level = settings.get("pdf_settings.default_zoom_level", 1.0)
        except Exception as e:
            self.logger.warning(f"Could not load zoom setting: {e}")
            self.zoom_level = 1.0
        
        # Drawing state
        self.brush_size = 10
        self.brush_color = QColor(0, 0, 0)  # Black for redaction
        
        # Page canvases
        self.page_canvases = []  # List of DrawingCanvas widgets
        self.page_images = []    # Original page images
        
        self.setup_ui()
        self.load_pdf()
    
    def setup_ui(self):
        """Setup the viewer UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Create scroll area for PDF content
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Create container widget to hold all canvases
        self.canvas_container = QWidget()
        self.canvas_container_layout = QVBoxLayout(self.canvas_container)
        self.canvas_container_layout.setContentsMargins(0, 0, 0, 0)
        
        # PDF display label for errors
        self.pdf_label = QLabel()
        self.pdf_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.pdf_label.setStyleSheet("""
            QLabel {
                background-color: white;
                border: 1px solid #ccc;
                margin: 10px;
            }
        """)
        self.pdf_label.hide()  # Hidden by default
        self.canvas_container_layout.addWidget(self.pdf_label)
        
        # Set the container as the scroll area widget once
        self.scroll_area.setWidget(self.canvas_container)
        layout.addWidget(self.scroll_area)
    
    def load_pdf(self):
        """Load the PDF file and create drawing canvases"""
        if not PYMUPDF_AVAILABLE:
            self.show_error("PyMuPDF not available. Please install with: pip install PyMuPDF")
            return
        
        try:
            self.pdf_document = fitz.open(self.pdf_path)
            
            self.page_images = []
            self.page_canvases = []
            
            # Load all pages and create canvases
            for page_num in range(len(self.pdf_document)):
                # Get page
                page = self.pdf_document[page_num]
                
                # Render page to image with saved zoom level
                mat = fitz.Matrix(self.zoom_level * 150/72, self.zoom_level * 150/72)  # Apply saved zoom
                pix = page.get_pixmap(matrix=mat)
                
                # Convert to QPixmap
                img_data = pix.tobytes("ppm")
                qpixmap = QPixmap()
                qpixmap.loadFromData(img_data)
                
                self.page_images.append(qpixmap)
                
                # Get original PDF page size (in points)
                pdf_rect = page.rect
                pdf_page_size = (int(pdf_rect.width), int(pdf_rect.height))
                
                # Create drawing canvas with PDF page size
                canvas = DrawingCanvas(qpixmap, page_num, pdf_page_size)
                canvas.set_brush_size(self.brush_size)
                canvas.set_brush_color(self.brush_color)
                canvas.set_tool(self.edit_mode or "redaction")
                canvas.set_zoom_level(self.zoom_level)
                
                # Add canvas to container and hide it initially
                canvas.setParent(self.canvas_container)
                self.canvas_container_layout.addWidget(canvas)
                canvas.hide()
                
                self.page_canvases.append(canvas)
            
            # Show first page
            if self.page_canvases:
                self.show_page(0)
            
            self.logger.info(f"Loaded PDF: {Path(self.pdf_path).name} with {len(self.page_canvases)} pages")
            
        except Exception as e:
            self.logger.error(f"Error loading PDF: {e}")
            self.show_error(f"Failed to load PDF: {str(e)}")
    
    def show_page(self, page_num: int):
        """Show specified page using show/hide instead of setWidget"""
        if 0 <= page_num < len(self.page_canvases):
            # Hide all canvases first
            for canvas in self.page_canvases:
                canvas.hide()
            
            # Hide error label if visible
            self.pdf_label.hide()
            
            # Show the requested canvas
            self.current_page = page_num
            canvas = self.page_canvases[page_num]
            
            # Update canvas settings
            canvas.set_brush_size(self.brush_size)
            canvas.set_brush_color(self.brush_color)
            canvas.set_tool(self.edit_mode or "redaction")
            canvas.set_excluded(page_num in self.excluded_pages)
            
            # Show the canvas
            canvas.show()
            
            # Ensure the canvas is visible in the scroll area
            self.scroll_area.ensureWidgetVisible(canvas)
            
            # Emit page changed signal
            self.page_changed.emit(page_num)
    
    def show_error(self, message: str):
        """Show error message"""
        # Hide all canvases
        for canvas in self.page_canvases:
            canvas.hide()
        
        # Show error in label
        self.pdf_label.setText(f"❌ {message}")
        self.pdf_label.setStyleSheet("""
            QLabel {
                color: red;
                font-size: 14px;
                padding: 20px;
                background-color: #fff5f5;
                border: 1px solid #ffcccc;
            }
        """)
        self.pdf_label.show()
    
    def render_current_page(self):
        """Render the current page"""
        if not self.pdf_document:
            return
        
        try:
            # Get the current page
            page = self.pdf_document[self.current_page]
            
            # Create transformation matrix for zoom
            mat = fitz.Matrix(self.zoom_level, self.zoom_level)
            
            # Render page to pixmap
            pix = page.get_pixmap(matrix=mat)
            
            # Convert to QPixmap
            img_data = pix.tobytes("ppm")
            qpixmap = QPixmap()
            qpixmap.loadFromData(img_data)
            
            # Add exclusion overlay if page is excluded
            if self.current_page in self.excluded_pages:
                painter = QPainter(qpixmap)
                painter.fillRect(qpixmap.rect(), QColor(255, 0, 0, 100))  # Red overlay
                painter.setPen(QColor(255, 255, 255))
                painter.drawText(qpixmap.rect(), Qt.AlignmentFlag.AlignCenter, "EXCLUDED FROM FAX")
                painter.end()
            
            # Display in label
            self.pdf_label.setPixmap(qpixmap)
            self.pdf_label.resize(qpixmap.size())
            
            # Update scroll area
            self.scroll_area.ensureWidgetVisible(self.pdf_label)
            
        except Exception as e:
            self.logger.error(f"Error rendering page: {e}")
            self.show_error(f"Failed to render page: {str(e)}")
    
    def get_page_count(self) -> int:
        """Get total number of pages"""
        if self.pdf_document:
            return len(self.pdf_document)
        return 0
    
    def go_to_page(self, page_number: int):
        """Go to specific page"""
        if not self.page_canvases:
            return
        
        if 0 <= page_number < len(self.page_canvases):
            self.show_page(page_number)
    
    def set_zoom(self, zoom_level: float):
        """Set zoom level and re-render current page"""
        self.zoom_level = zoom_level
        
        # Re-render the current page at the new zoom level
        if self.pdf_document and self.page_canvases:
            try:
                # Get current page
                page_num = self.current_page
                page = self.pdf_document[page_num]
                
                # Create transformation matrix for new zoom
                mat = fitz.Matrix(zoom_level * 150/72, zoom_level * 150/72)  # Base 150 DPI * zoom
                pix = page.get_pixmap(matrix=mat)
                
                # Convert to QPixmap
                img_data = pix.tobytes("ppm")
                qpixmap = QPixmap()
                qpixmap.loadFromData(img_data)
                
                # Update the current canvas with new image
                if 0 <= page_num < len(self.page_canvases):
                    canvas = self.page_canvases[page_num]
                    
                    # Store the old overlay data
                    old_brush_strokes = canvas.brush_strokes.copy()
                    old_annotations = canvas.annotations.copy()
                    old_excluded = canvas.excluded
                    
                    # Update the canvas with new image
                    canvas.page_image = qpixmap
                    canvas.setPixmap(qpixmap)
                    canvas.setMinimumSize(qpixmap.size())
                    
                    # Recreate overlay at new size
                    canvas.overlay = QPixmap(qpixmap.size())
                    canvas.overlay.fill(Qt.GlobalColor.transparent)
                    
                    # Keep brush strokes and annotations in PDF coordinates (no scaling needed)
                    canvas.brush_strokes = old_brush_strokes
                    canvas.annotations = old_annotations
                    canvas.excluded = old_excluded
                    
                    # Update canvas zoom level and redraw
                    canvas.set_zoom_level(zoom_level)
                    
                    # Ensure the canvas is visible in the scroll area
                    self.scroll_area.ensureWidgetVisible(canvas)
                
                # Save zoom level to settings
                try:
                    from core.settings import get_settings
                    settings = get_settings()
                    settings.set("pdf_settings.default_zoom_level", zoom_level)
                    settings.save_settings()
                    self.logger.info(f"Saved zoom level {zoom_level:.2f} to settings")
                except Exception as save_error:
                    self.logger.warning(f"Could not save zoom setting: {save_error}")
                
                self.zoom_changed.emit(zoom_level)
                
            except Exception as e:
                self.logger.error(f"Error setting zoom level: {e}")
    
    def set_edit_mode(self, mode: Optional[str]):
        """Set editing mode"""
        self.edit_mode = mode
        
        # Update current canvas tool
        if self.page_canvases and 0 <= self.current_page < len(self.page_canvases):
            canvas = self.page_canvases[self.current_page]
            canvas.set_tool(mode or "redaction")
        
        # Change cursor based on mode
        if mode == 'redaction':
            self.setCursor(Qt.CursorShape.CrossCursor)
        elif mode == 'highlight':
            self.setCursor(Qt.CursorShape.PointingHandCursor)
        elif mode == 'text':
            self.setCursor(Qt.CursorShape.IBeamCursor)
        else:
            self.setCursor(Qt.CursorShape.ArrowCursor)
    
    def set_brush_size(self, size: int):
        """Set brush size for all canvases"""
        self.brush_size = size
        for canvas in self.page_canvases:
            canvas.set_brush_size(size)
    
    def set_brush_color(self, color: QColor):
        """Set brush color for all canvases"""
        self.brush_color = color
        for canvas in self.page_canvases:
            canvas.set_brush_color(color)
    
    def undo_last_edit(self):
        """Undo the last edit on current page"""
        if self.page_canvases and 0 <= self.current_page < len(self.page_canvases):
            canvas = self.page_canvases[self.current_page]
            canvas.undo()
            self.logger.info(f"Undid last edit on page {self.current_page + 1}")
    
    def toggle_page_exclusion(self):
        """Toggle exclusion of current page"""
        if self.current_page in self.excluded_pages:
            self.excluded_pages.remove(self.current_page)
            self.logger.info(f"Page {self.current_page + 1} included in fax")
        else:
            self.excluded_pages.add(self.current_page)
            self.logger.info(f"Page {self.current_page + 1} excluded from fax")
        
        # Update canvas exclusion state
        if self.page_canvases and 0 <= self.current_page < len(self.page_canvases):
            canvas = self.page_canvases[self.current_page]
            canvas.set_excluded(self.current_page in self.excluded_pages)
    
    def is_page_excluded(self, page_number: int) -> bool:
        """Check if a page is excluded"""
        return page_number in self.excluded_pages
    
    def get_excluded_pages(self) -> list:
        """Get list of excluded page numbers"""
        return sorted(list(self.excluded_pages))
    
    def get_included_page_count(self) -> int:
        """Get count of pages that will be included in fax"""
        if self.pdf_document:
            return len(self.pdf_document) - len(self.excluded_pages)
        return 0
    
    
    def get_edit_data(self) -> Dict[str, Any]:
        """Collect edit data from all page canvases"""
        edit_data = {'pages': []}
        for canvas in self.page_canvases:
            page_data = {
                'page_number': canvas.page_number,
                'excluded': canvas.excluded,
                'brush_strokes': canvas.brush_strokes.copy(),
                'annotations': canvas.annotations.copy()
            }
            edit_data['pages'].append(page_data)
        return edit_data

    def apply_edit_data(self, edit_data: Dict[str, Any]):
        """Apply saved edit data to page canvases"""
        pages_data = edit_data.get('pages', [])
        for page_data in pages_data:
            page_num = page_data.get('page_number', -1)
            if 0 <= page_num < len(self.page_canvases):
                canvas = self.page_canvases[page_num]
                canvas.brush_strokes = page_data.get('brush_strokes', [])
                canvas.annotations = page_data.get('annotations', [])
                canvas.excluded = page_data.get('excluded', False)
                canvas.redraw_overlay()
        # Update excluded_pages set
        self.excluded_pages = {p['page_number'] for p in pages_data if p.get('excluded', False)}

    def save_pdf(self, output_path: Optional[str] = None) -> bool:
        """Save PDF with edits applied to a new file"""
        if not self.pdf_document:
            self.logger.warning("No PDF document loaded")
            return False
        
        try:
            # For now, we'll use the existing PDFProcessor to apply edits
            from pdf.pdf_processor import PDFProcessor
            
            # Get edit data for this PDF
            edit_data = self.get_edit_data()
            
            # If no edits, just return True (no need to save)
            if not self._has_edits(edit_data):
                self.logger.info("No edits to save")
                return True
            
            # Generate output path if not provided
            if not output_path:
                from pathlib import Path
                import time
                timestamp = int(time.time())
                output_path = f"temp/edited_{timestamp}_{Path(self.pdf_path).name}"
                
                # Create temp directory if it doesn't exist
                Path("temp").mkdir(exist_ok=True)
            
            # Use PDFProcessor to apply edits
            processor = PDFProcessor()
            success = processor.apply_edits_to_pdf(self.pdf_path, edit_data, output_path)
            
            if success:
                self.logger.info(f"Successfully saved PDF with edits to: {output_path}")
                return True
            else:
                self.logger.error(f"Failed to save PDF with edits to: {output_path}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error saving PDF with edits: {e}")
            return False
    
    def _has_edits(self, edit_data: Dict[str, Any]) -> bool:
        """Check if edit data contains any actual edits"""
        pages_data = edit_data.get('pages', [])
        
        for page_data in pages_data:
            # Check for excluded pages
            if page_data.get('excluded', False):
                return True
                
            # Check for brush strokes
            if page_data.get('brush_strokes'):
                return True
                
            # Check for annotations
            if page_data.get('annotations'):
                return True
        
        return False
    
    def closeEvent(self, event):
        """Clean up when widget is closed"""
        if self.pdf_document:
            self.pdf_document.close()
        event.accept()
 
# --- END OF FILE: integrated_pdf_viewer.py --- 
 
# --- START OF FILE: progress_button.py --- 
 
"""
Custom Progress Button Widget
A button that displays progress as a visual fill from left to right
"""

from PyQt6.QtWidgets import QPushButton
from PyQt6.QtCore import Qt, QPropertyAnimation, QEasingCurve, pyqtProperty
from PyQt6.QtGui import QPainter, QColor, QLinearGradient, QBrush
from typing import Optional

class ProgressButton(QPushButton):
    """A button that can display progress as a visual fill"""
    
    def __init__(self, text: str = "", parent=None):
        super().__init__(text, parent)
        self._progress = 0.0
        self._is_processing = False
        self._original_text = text
        self._processing_text = "Generating Final Preview"
        
        # Set up default styling
        self.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                padding: 8px 16px;
                font-size: 12px;
                font-weight: bold;
                border-radius: 4px;
                min-height: 20px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:disabled {
                background-color: #CCCCCC;
                color: #666666;
            }
        """)
    
    @pyqtProperty(float)
    def progress(self):
        """Get the current progress value (0.0 to 1.0)"""
        return self._progress
    
    @progress.setter
    def progress(self, value: float):
        """Set the progress value (0.0 to 1.0)"""
        self._progress = max(0.0, min(1.0, value))
        self.update()  # Trigger repaint
    
    def set_progress(self, value: int):
        """Set progress from integer percentage (0-100)"""
        self.progress = value / 100.0
    
    def start_processing(self):
        """Start processing mode"""
        self._is_processing = True
        self.setEnabled(False)
        self.setText(self._processing_text)
        self.progress = 0.0
        
        # Change to grey background during processing
        self.setStyleSheet("""
            QPushButton {
                background-color: #CCCCCC;
                color: #666666;
                border: none;
                padding: 8px 16px;
                font-size: 12px;
                font-weight: bold;
                border-radius: 4px;
                min-height: 20px;
            }
        """)
    
    def finish_processing(self, success: bool = True):
        """Finish processing mode"""
        self._is_processing = False
        self.setEnabled(True)
        self.setText(self._original_text)
        
        if success:
            self.progress = 1.0
        else:
            self.progress = 0.0
        
        # Restore normal styling
        self.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                padding: 8px 16px;
                font-size: 12px;
                font-weight: bold;
                border-radius: 4px;
                min-height: 20px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:disabled {
                background-color: #CCCCCC;
                color: #666666;
            }
        """)
    
    def reset(self):
        """Reset button to initial state"""
        self.finish_processing(success=False)
    
    def paintEvent(self, event):
        """Custom paint event to draw progress fill"""
        super().paintEvent(event)
        
        if self._is_processing and self._progress > 0:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Calculate progress width
            button_rect = self.rect()
            progress_width = int(button_rect.width() * self._progress)
            
            if progress_width > 0:
                # Create gradient for progress fill
                gradient = QLinearGradient(0, 0, progress_width, 0)
                gradient.setColorAt(0, QColor(33, 150, 243, 180))  # Semi-transparent blue
                gradient.setColorAt(1, QColor(25, 118, 210, 180))  # Darker blue
                
                # Draw progress fill
                progress_rect = button_rect.adjusted(0, 0, -(button_rect.width() - progress_width), 0)
                painter.fillRect(progress_rect, QBrush(gradient))
            
            painter.end()
    
    def set_original_text(self, text: str):
        """Set the original button text"""
        self._original_text = text
        if not self._is_processing:
            self.setText(text)
    
    def set_processing_text(self, text: str):
        """Set the processing button text"""
        self._processing_text = text
        if self._is_processing:
            self.setText(text)
 
# --- END OF FILE: progress_button.py --- 
 
# --- START OF FILE: __init__.py --- 
 
"""
GUI package for MCFax Application
"""
 
# --- END OF FILE: __init__.py --- 
 
