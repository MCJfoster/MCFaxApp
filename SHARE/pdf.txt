# PDF Module Files 
# This file contains all Python files from the src/pdf/ directory 
# Generated by MCFax sharing script 
 
# --- START OF FILE: pdf_browser.py --- 
 
"""
PDF Browser Module
Handles browsing and listing PDF files in the temp folder
"""

import os
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from datetime import datetime
import PyPDF2
import pdfplumber

class PDFInfo:
    """Information about a PDF file"""
    
    def __init__(self, file_path: str):
        self.file_path = Path(file_path)
        self.name = self.file_path.name
        self.size_bytes = 0
        self.size_mb = 0.0
        self.page_count = 0
        self.created_time = None
        self.modified_time = None
        self.is_valid = False
        self.error_message = None
        
        self._analyze_file()
    
    def _analyze_file(self):
        """Analyze the PDF file to extract information"""
        try:
            if not self.file_path.exists():
                self.error_message = "File does not exist"
                return
            
            # Get file stats
            stat = self.file_path.stat()
            self.size_bytes = stat.st_size
            self.size_mb = self.size_bytes / (1024 * 1024)
            self.created_time = datetime.fromtimestamp(stat.st_ctime)
            self.modified_time = datetime.fromtimestamp(stat.st_mtime)
            
            # Try to read PDF and get page count
            try:
                with open(self.file_path, 'rb') as file:
                    pdf_reader = PyPDF2.PdfReader(file)
                    self.page_count = len(pdf_reader.pages)
                    self.is_valid = True
            except Exception as e:
                self.error_message = f"Invalid PDF: {str(e)}"
                self.is_valid = False
                
        except Exception as e:
            self.error_message = f"Error analyzing file: {str(e)}"
            self.is_valid = False
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            'file_path': str(self.file_path),
            'name': self.name,
            'size_bytes': self.size_bytes,
            'size_mb': round(self.size_mb, 2),
            'page_count': self.page_count,
            'created_time': self.created_time.isoformat() if self.created_time else None,
            'modified_time': self.modified_time.isoformat() if self.modified_time else None,
            'is_valid': self.is_valid,
            'error_message': self.error_message
        }
    
    def __str__(self):
        if self.is_valid:
            return f"{self.name} ({self.page_count} pages, {self.size_mb:.1f} MB)"
        else:
            return f"{self.name} (Invalid: {self.error_message})"

class PDFBrowser:
    """
    PDF Browser for listing and managing PDF files in a directory
    """
    
    def __init__(self, folder_path: str):
        """
        Initialize PDF browser
        
        Args:
            folder_path: Path to folder containing PDF files
        """
        self.folder_path = Path(folder_path)
        self.logger = logging.getLogger(__name__)
        self._pdf_cache = {}
        self._last_scan_time = None
        
        if not self.folder_path.exists():
            self.logger.warning(f"PDF folder does not exist: {folder_path}")
        elif not self.folder_path.is_dir():
            self.logger.error(f"PDF path is not a directory: {folder_path}")
    
    def get_pdf_files(self, force_refresh: bool = False) -> List[PDFInfo]:
        """
        Get list of PDF files in the folder
        
        Args:
            force_refresh: Force refresh of file list
            
        Returns:
            List of PDFInfo objects
        """
        try:
            if not self.folder_path.exists():
                self.logger.warning(f"PDF folder does not exist: {self.folder_path}")
                return []
            
            # Check if we need to refresh
            current_time = datetime.now()
            if (not force_refresh and 
                self._last_scan_time and 
                (current_time - self._last_scan_time).seconds < 5):
                # Return cached results if scanned recently
                return list(self._pdf_cache.values())
            
            pdf_files = []
            new_cache = {}
            
            # Scan for PDF files
            for file_path in self.folder_path.glob("*.pdf"):
                if file_path.is_file():
                    # Check if we have cached info and file hasn't changed
                    file_key = str(file_path)
                    if (file_key in self._pdf_cache and 
                        file_path.stat().st_mtime == self._pdf_cache[file_key].modified_time.timestamp()):
                        # Use cached info
                        pdf_info = self._pdf_cache[file_key]
                    else:
                        # Create new info
                        pdf_info = PDFInfo(str(file_path))
                    
                    new_cache[file_key] = pdf_info
                    pdf_files.append(pdf_info)
            
            # Update cache
            self._pdf_cache = new_cache
            self._last_scan_time = current_time
            
            # Sort by name
            pdf_files.sort(key=lambda x: x.name.lower())
            
            self.logger.info(f"Found {len(pdf_files)} PDF files in {self.folder_path}")
            return pdf_files
            
        except Exception as e:
            self.logger.error(f"Error scanning PDF files: {e}")
            return []
    
    def get_pdf_info(self, file_name: str) -> Optional[PDFInfo]:
        """
        Get information about a specific PDF file
        
        Args:
            file_name: Name of the PDF file
            
        Returns:
            PDFInfo object or None if not found
        """
        file_path = self.folder_path / file_name
        if file_path.exists():
            return PDFInfo(str(file_path))
        return None
    
    def get_total_size(self, pdf_files: List[str]) -> float:
        """
        Calculate total size of selected PDF files in MB
        
        Args:
            pdf_files: List of PDF file paths
            
        Returns:
            Total size in MB
        """
        total_size = 0.0
        for pdf_path in pdf_files:
            try:
                file_path = Path(pdf_path)
                if file_path.exists():
                    total_size += file_path.stat().st_size / (1024 * 1024)
            except Exception as e:
                self.logger.error(f"Error getting size for {pdf_path}: {e}")
        
        return total_size
    
    def validate_pdf_selection(self, pdf_files: List[str], max_size_mb: float = 36.0) -> Dict[str, Any]:
        """
        Validate a selection of PDF files
        
        Args:
            pdf_files: List of PDF file paths
            max_size_mb: Maximum allowed total size in MB
            
        Returns:
            Dictionary with validation results
        """
        result = {
            'is_valid': True,
            'errors': [],
            'warnings': [],
            'total_size_mb': 0.0,
            'total_pages': 0,
            'file_count': len(pdf_files)
        }
        
        if not pdf_files:
            result['is_valid'] = False
            result['errors'].append("No PDF files selected")
            return result
        
        total_size = 0.0
        total_pages = 0
        
        for pdf_path in pdf_files:
            try:
                file_path = Path(pdf_path)
                
                if not file_path.exists():
                    result['errors'].append(f"File not found: {file_path.name}")
                    result['is_valid'] = False
                    continue
                
                # Get file size
                size_mb = file_path.stat().st_size / (1024 * 1024)
                total_size += size_mb
                
                # Try to get page count
                try:
                    with open(file_path, 'rb') as file:
                        pdf_reader = PyPDF2.PdfReader(file)
                        pages = len(pdf_reader.pages)
                        total_pages += pages
                        
                        if pages == 0:
                            result['warnings'].append(f"File has no pages: {file_path.name}")
                            
                except Exception as e:
                    result['errors'].append(f"Invalid PDF: {file_path.name} - {str(e)}")
                    result['is_valid'] = False
                    
            except Exception as e:
                result['errors'].append(f"Error processing {pdf_path}: {str(e)}")
                result['is_valid'] = False
        
        result['total_size_mb'] = round(total_size, 2)
        result['total_pages'] = total_pages
        
        # Check size limit
        if total_size > max_size_mb:
            result['errors'].append(f"Total size ({total_size:.1f} MB) exceeds limit ({max_size_mb} MB)")
            result['is_valid'] = False
        
        # Warnings for large files
        if total_size > max_size_mb * 0.8:
            result['warnings'].append(f"Total size ({total_size:.1f} MB) is close to limit ({max_size_mb} MB)")
        
        return result
    
    def search_pdfs(self, search_term: str) -> List[PDFInfo]:
        """
        Search for PDF files by name
        
        Args:
            search_term: Search term to match against file names
            
        Returns:
            List of matching PDFInfo objects
        """
        all_pdfs = self.get_pdf_files()
        search_lower = search_term.lower()
        
        matching_pdfs = []
        for pdf_info in all_pdfs:
            if search_lower in pdf_info.name.lower():
                matching_pdfs.append(pdf_info)
        
        return matching_pdfs
    
    def get_folder_stats(self) -> Dict[str, Any]:
        """
        Get statistics about the PDF folder
        
        Returns:
            Dictionary with folder statistics
        """
        try:
            if not self.folder_path.exists():
                return {
                    'exists': False,
                    'error': 'Folder does not exist'
                }
            
            pdf_files = self.get_pdf_files()
            valid_files = [pdf for pdf in pdf_files if pdf.is_valid]
            invalid_files = [pdf for pdf in pdf_files if not pdf.is_valid]
            
            total_size = sum(pdf.size_mb for pdf in valid_files)
            total_pages = sum(pdf.page_count for pdf in valid_files)
            
            return {
                'exists': True,
                'folder_path': str(self.folder_path),
                'total_files': len(pdf_files),
                'valid_files': len(valid_files),
                'invalid_files': len(invalid_files),
                'total_size_mb': round(total_size, 2),
                'total_pages': total_pages,
                'last_scan': self._last_scan_time.isoformat() if self._last_scan_time else None
            }
            
        except Exception as e:
            return {
                'exists': False,
                'error': str(e)
            }

# Utility functions
def is_valid_pdf(file_path: str) -> bool:
    """
    Check if a file is a valid PDF
    
    Args:
        file_path: Path to the file
        
    Returns:
        True if valid PDF, False otherwise
    """
    try:
        with open(file_path, 'rb') as file:
            PyPDF2.PdfReader(file)
        return True
    except:
        return False

def get_pdf_page_count(file_path: str) -> int:
    """
    Get the number of pages in a PDF file
    
    Args:
        file_path: Path to the PDF file
        
    Returns:
        Number of pages, or 0 if error
    """
    try:
        with open(file_path, 'rb') as file:
            pdf_reader = PyPDF2.PdfReader(file)
            return len(pdf_reader.pages)
    except:
        return 0

def get_pdf_text_preview(file_path: str, max_chars: int = 500) -> str:
    """
    Get a text preview of the PDF content
    
    Args:
        file_path: Path to the PDF file
        max_chars: Maximum number of characters to return
        
    Returns:
        Text preview or error message
    """
    try:
        with pdfplumber.open(file_path) as pdf:
            text = ""
            for page in pdf.pages[:3]:  # First 3 pages only
                page_text = page.extract_text()
                if page_text:
                    text += page_text + "\n"
                if len(text) > max_chars:
                    break
            
            if len(text) > max_chars:
                text = text[:max_chars] + "..."
            
            return text.strip() if text.strip() else "No text content found"
            
    except Exception as e:
        return f"Error reading PDF: {str(e)}"
 
# --- END OF FILE: pdf_browser.py --- 
 
# --- START OF FILE: pdf_viewer.py --- 
 
"""
PDF Viewer Module
Enhanced PDF viewing with editing capabilities for the MCFax application
"""

import os
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QScrollArea, QMessageBox, QGroupBox, QSlider, QSpinBox,
    QTabWidget, QDialog, QDialogButtonBox
)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QPixmap, QFont

try:
    from .pdf_editor import PDFEditor, PYMUPDF_AVAILABLE
    EDITOR_AVAILABLE = True
except ImportError:
    EDITOR_AVAILABLE = False
    PYMUPDF_AVAILABLE = False

class PDFViewerDialog(QDialog):
    """Dialog for viewing and editing PDFs"""
    
    edits_applied = pyqtSignal(dict)  # Signal emitted when edits are applied
    
    def __init__(self, pdf_path: str, parent=None):
        super().__init__(parent)
        self.pdf_path = pdf_path
        self.logger = logging.getLogger(__name__)
        
        self.setWindowTitle(f"PDF Viewer - {Path(pdf_path).name}")
        self.setGeometry(100, 100, 1400, 900)
        
        # Data
        self.excluded_pages = []
        self.edit_data = {}
        
        self.setup_ui()
    
    def setup_ui(self):
        """Setup the user interface"""
        layout = QVBoxLayout(self)
        
        # Check if editing is available
        if not EDITOR_AVAILABLE or not PYMUPDF_AVAILABLE:
            # Show simple viewer
            self.create_simple_viewer()
        else:
            # Show full editor
            self.create_editor_interface()
        
        # Button box
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self.accept_changes)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    def create_simple_viewer(self):
        """Create simple PDF viewer when editor is not available"""
        layout = self.layout()
        
        # Info message
        info_label = QLabel(
            "PDF Editor Dependencies Missing\n\n"
            "To enable PDF editing and viewing, please install:\n"
            "• PyMuPDF (required for PDF processing)\n"
            "• Pillow ✓ (installed)\n\n"
            "Install with:\n"
            "pip install PyMuPDF\n\n"
            "PyMuPDF provides complete PDF functionality\n"
            "without requiring external binaries!\n\n"
            f"Current PDF: {Path(self.pdf_path).name}"
        )
        info_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        info_label.setStyleSheet("""
            QLabel {
                border: 2px dashed #ccc;
                padding: 40px;
                font-size: 14px;
                color: #666;
                background-color: #f9f9f9;
            }
        """)
        layout.addWidget(info_label)
        
        # Basic info
        try:
            from pdf.pdf_processor import PDFProcessor
            processor = PDFProcessor()
            pdf_info = processor.get_pdf_info(self.pdf_path)
            
            info_text = f"PDF Information:\n"
            info_text += f"File: {pdf_info.get('file_name', 'Unknown')}\n"
            info_text += f"Pages: {pdf_info.get('page_count', 'Unknown')}\n"
            info_text += f"Size: {pdf_info.get('size_mb', 'Unknown')} MB\n"
            
            info_detail = QLabel(info_text)
            info_detail.setAlignment(Qt.AlignmentFlag.AlignCenter)
            layout.addWidget(info_detail)
            
        except Exception as e:
            self.logger.error(f"Error getting PDF info: {e}")
    
    def create_editor_interface(self):
        """Create full PDF editor interface"""
        layout = self.layout()
        
        try:
            # Create PDF editor
            self.pdf_editor = PDFEditor(self.pdf_path, self)
            self.pdf_editor.pages_changed.connect(self.on_pages_changed)
            layout.addWidget(self.pdf_editor)
            
        except Exception as e:
            self.logger.error(f"Error creating PDF editor: {e}")
            # Fall back to simple viewer
            error_label = QLabel(f"Error loading PDF editor:\n{str(e)}")
            error_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            error_label.setStyleSheet("QLabel { color: red; padding: 20px; }")
            layout.addWidget(error_label)
    
    def on_pages_changed(self):
        """Handle page changes from editor"""
        if hasattr(self, 'pdf_editor'):
            self.excluded_pages = self.pdf_editor.get_excluded_pages()
    
    def accept_changes(self):
        """Accept changes and emit signal"""
        if hasattr(self, 'pdf_editor'):
            # Get all edit data
            self.edit_data = self.pdf_editor.get_all_edits()
            self.excluded_pages = self.pdf_editor.get_excluded_pages()
            
            # Emit signal with edit data
            self.edits_applied.emit({
                'excluded_pages': self.excluded_pages,
                'edit_data': self.edit_data
            })
        
        self.accept()
    
    def get_excluded_pages(self) -> List[int]:
        """Get list of excluded page numbers"""
        return self.excluded_pages
    
    def get_edit_data(self) -> Dict[str, Any]:
        """Get all edit data"""
        return self.edit_data

class PDFViewer(QWidget):
    """
    Enhanced PDF viewer widget with editing capabilities
    """
    
    pdf_edited = pyqtSignal(dict)  # Signal emitted when PDF is edited
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.logger = logging.getLogger(__name__)
        self.current_pdf = None
        self.excluded_pages = []
        self.edit_data = {}
        self.setup_ui()
    
    def setup_ui(self):
        """Setup the viewer UI"""
        layout = QVBoxLayout(self)
        
        # Header
        header = QGroupBox("PDF Viewer")
        header_layout = QVBoxLayout(header)
        
        # File info
        self.file_label = QLabel("No PDF loaded")
        self.file_label.setFont(QFont("Arial", 10, QFont.Weight.Bold))
        header_layout.addWidget(self.file_label)
        
        # Status info
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("QLabel { color: #666; }")
        header_layout.addWidget(self.status_label)
        
        layout.addWidget(header)
        
        # Main content area
        content = QGroupBox("Preview")
        content_layout = QVBoxLayout(content)
        
        # Preview area
        self.preview_area = QLabel("No PDF loaded")
        self.preview_area.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.preview_area.setMinimumHeight(200)
        self.preview_area.setStyleSheet("""
            QLabel {
                border: 2px dashed #ccc;
                padding: 20px;
                font-size: 14px;
                color: #666;
                background-color: #f9f9f9;
            }
        """)
        content_layout.addWidget(self.preview_area)
        
        # Action buttons
        button_layout = QHBoxLayout()
        
        self.view_edit_btn = QPushButton("View & Edit PDF")
        self.view_edit_btn.setEnabled(False)
        self.view_edit_btn.clicked.connect(self.open_editor)
        self.view_edit_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                padding: 8px 16px;
                font-weight: bold;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:disabled {
                background-color: #cccccc;
                color: #666666;
            }
        """)
        button_layout.addWidget(self.view_edit_btn)
        
        self.clear_edits_btn = QPushButton("Clear Edits")
        self.clear_edits_btn.setEnabled(False)
        self.clear_edits_btn.clicked.connect(self.clear_edits)
        button_layout.addWidget(self.clear_edits_btn)
        
        button_layout.addStretch()
        
        content_layout.addLayout(button_layout)
        layout.addWidget(content)
        
        # Edit summary
        self.summary_group = QGroupBox("Edit Summary")
        summary_layout = QVBoxLayout(self.summary_group)
        
        self.summary_label = QLabel("No edits applied")
        self.summary_label.setStyleSheet("QLabel { color: #666; }")
        summary_layout.addWidget(self.summary_label)
        
        layout.addWidget(self.summary_group)
        self.summary_group.setVisible(False)
    
    def load_pdf(self, pdf_path: str):
        """Load a PDF file for viewing"""
        try:
            self.current_pdf = pdf_path
            file_name = Path(pdf_path).name
            
            # Update UI
            self.file_label.setText(f"File: {file_name}")
            
            # Get PDF info
            try:
                from pdf.pdf_processor import PDFProcessor
                processor = PDFProcessor()
                pdf_info = processor.get_pdf_info(pdf_path)
                
                pages = pdf_info.get('page_count', 'Unknown')
                size = pdf_info.get('size_mb', 'Unknown')
                
                self.preview_area.setText(
                    f"PDF Loaded: {file_name}\n\n"
                    f"Pages: {pages}\n"
                    f"Size: {size} MB\n\n"
                    f"Click 'View & Edit PDF' to open the editor"
                )
                
                self.status_label.setText(f"Loaded • {pages} pages • {size} MB")
                
            except Exception as e:
                self.logger.error(f"Error getting PDF info: {e}")
                self.preview_area.setText(f"PDF Loaded: {file_name}\n\nClick 'View & Edit PDF' to open")
                self.status_label.setText("Loaded")
            
            # Enable editing button
            self.view_edit_btn.setEnabled(True)
            
            # Clear previous edits
            self.clear_edits()
            
        except Exception as e:
            self.logger.error(f"Error loading PDF: {e}")
            QMessageBox.critical(self, "Error", f"Failed to load PDF: {str(e)}")
    
    def open_editor(self):
        """Open the PDF editor dialog"""
        if not self.current_pdf:
            return
        
        try:
            # Create and show editor dialog
            editor_dialog = PDFViewerDialog(self.current_pdf, self)
            editor_dialog.edits_applied.connect(self.on_edits_applied)
            
            if editor_dialog.exec() == QDialog.DialogCode.Accepted:
                self.logger.info("PDF editor closed with changes accepted")
            else:
                self.logger.info("PDF editor closed without changes")
                
        except Exception as e:
            self.logger.error(f"Error opening PDF editor: {e}")
            QMessageBox.critical(self, "Error", f"Failed to open PDF editor: {str(e)}")
    
    def on_edits_applied(self, edit_info: Dict[str, Any]):
        """Handle edits applied from editor"""
        self.excluded_pages = edit_info.get('excluded_pages', [])
        self.edit_data = edit_info.get('edit_data', {})
        
        # Update UI
        self.update_edit_summary()
        self.clear_edits_btn.setEnabled(True)
        
        # Emit signal
        self.pdf_edited.emit(edit_info)
    
    def update_edit_summary(self):
        """Update the edit summary display"""
        if not self.excluded_pages and not self.edit_data:
            self.summary_group.setVisible(False)
            return
        
        summary_parts = []
        
        if self.excluded_pages:
            excluded_count = len(self.excluded_pages)
            summary_parts.append(f"• {excluded_count} page(s) excluded")
        
        if self.edit_data and 'pages' in self.edit_data:
            edited_pages = 0
            for page_data in self.edit_data['pages']:
                if (page_data.get('brush_strokes') or 
                    page_data.get('annotations')):
                    edited_pages += 1
            
            if edited_pages > 0:
                summary_parts.append(f"• {edited_pages} page(s) have edits")
        
        if summary_parts:
            self.summary_label.setText("\n".join(summary_parts))
            self.summary_group.setVisible(True)
        else:
            self.summary_group.setVisible(False)
    
    def clear_edits(self):
        """Clear all edits"""
        self.excluded_pages = []
        self.edit_data = {}
        self.summary_group.setVisible(False)
        self.clear_edits_btn.setEnabled(False)
        
        # Update status
        if self.current_pdf:
            file_name = Path(self.current_pdf).name
            self.preview_area.setText(
                f"PDF Loaded: {file_name}\n\n"
                f"Click 'View & Edit PDF' to open the editor\n\n"
                f"All edits have been cleared"
            )
    
    def clear(self):
        """Clear the viewer"""
        self.current_pdf = None
        self.excluded_pages = []
        self.edit_data = {}
        
        self.file_label.setText("No PDF loaded")
        self.status_label.setText("Ready")
        self.preview_area.setText("No PDF loaded")
        self.view_edit_btn.setEnabled(False)
        self.clear_edits_btn.setEnabled(False)
        self.summary_group.setVisible(False)
    
    def get_excluded_pages(self) -> List[int]:
        """Get list of excluded page numbers (0-based)"""
        return self.excluded_pages.copy()
    
    def get_edit_data(self) -> Dict[str, Any]:
        """Get all edit data"""
        return self.edit_data.copy()
    
    def has_edits(self) -> bool:
        """Check if there are any edits applied"""
        return bool(self.excluded_pages or self.edit_data)

# Utility function for standalone PDF viewing
def view_pdf(pdf_path: str, parent=None) -> Dict[str, Any]:
    """
    Open a PDF in the viewer dialog and return edit results
    
    Args:
        pdf_path: Path to PDF file
        parent: Parent widget
        
    Returns:
        dict: Edit results with 'excluded_pages' and 'edit_data' keys
    """
    dialog = PDFViewerDialog(pdf_path, parent)
    
    if dialog.exec() == QDialog.DialogCode.Accepted:
        return {
            'excluded_pages': dialog.get_excluded_pages(),
            'edit_data': dialog.get_edit_data()
        }
    else:
        return {
            'excluded_pages': [],
            'edit_data': {}
        }
 
# --- END OF FILE: pdf_viewer.py --- 
 
# --- START OF FILE: pdf_editor.py --- 
 
"""
PDF Editor Module
Provides MS Paint-style redaction and simple annotation capabilities
"""

import os
import io
import json
import logging
from typing import List, Dict, Any, Tuple, Optional
from pathlib import Path
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QScrollArea, QLabel,
    QPushButton, QSlider, QSpinBox, QCheckBox, QGroupBox,
    QButtonGroup, QToolButton, QColorDialog, QMessageBox,
    QSizePolicy, QFrame
)
from PyQt6.QtCore import Qt, QPoint, QRect, pyqtSignal, QSize
from PyQt6.QtGui import (
    QPainter, QPen, QBrush, QColor, QPixmap, QFont,
    QMouseEvent, QPaintEvent, QIcon
)

try:
    import fitz  # PyMuPDF
    from PIL import Image, ImageDraw
    PYMUPDF_AVAILABLE = True
except ImportError:
    PYMUPDF_AVAILABLE = False

class DrawingCanvas(QLabel):
    """Canvas widget for drawing redactions and annotations on PDF pages"""
    
    def __init__(self, page_image: QPixmap, page_number: int):
        super().__init__()
        self.page_image = page_image
        self.page_number = page_number
        self.logger = logging.getLogger(__name__)
        
        # Drawing state
        self.drawing = False
        self.brush_size = 10
        self.brush_color = QColor(0, 0, 0)  # Black for redaction
        self.current_tool = "redaction"  # redaction, text, rectangle
        
        # Drawing data
        self.brush_strokes = []  # List of stroke paths
        self.annotations = []    # List of text/shape annotations
        self.excluded = False    # Whether this page is excluded
        
        # Undo/redo
        self.history = []
        self.history_index = -1
        
        # Setup canvas
        self.setPixmap(page_image)
        self.setMinimumSize(page_image.size())
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Enable mouse tracking
        self.setMouseTracking(True)
        
        # Create overlay for drawing
        self.overlay = QPixmap(page_image.size())
        self.overlay.fill(Qt.GlobalColor.transparent)
        
        self.update_display()
    
    def set_brush_size(self, size: int):
        """Set brush size for redaction"""
        self.brush_size = size
    
    def set_brush_color(self, color: QColor):
        """Set brush color"""
        self.brush_color = color
    
    def set_tool(self, tool: str):
        """Set current drawing tool"""
        self.current_tool = tool
    
    def set_excluded(self, excluded: bool):
        """Set whether this page is excluded from final PDF"""
        self.excluded = excluded
        self.update_display()
    
    def mousePressEvent(self, event: QMouseEvent):
        """Handle mouse press events"""
        if event.button() == Qt.MouseButton.LeftButton:
            if self.current_tool == "redaction":
                self.drawing = True
                self.current_stroke = [event.position().toPoint()]
                self.save_state()
    
    def mouseMoveEvent(self, event: QMouseEvent):
        """Handle mouse move events"""
        if self.drawing and self.current_tool == "redaction":
            self.current_stroke.append(event.position().toPoint())
            self.draw_current_stroke()
    
    def mouseReleaseEvent(self, event: QMouseEvent):
        """Handle mouse release events"""
        if event.button() == Qt.MouseButton.LeftButton and self.drawing:
            self.drawing = False
            if hasattr(self, 'current_stroke') and len(self.current_stroke) > 1:
                # Save the completed stroke
                stroke_data = {
                    'type': 'redaction',
                    'points': [(p.x(), p.y()) for p in self.current_stroke],
                    'brush_size': self.brush_size,
                    'color': self.brush_color.name()
                }
                self.brush_strokes.append(stroke_data)
                self.redraw_overlay()
    
    def draw_current_stroke(self):
        """Draw the current stroke being drawn"""
        if not hasattr(self, 'current_stroke') or len(self.current_stroke) < 2:
            return
        
        # Create temporary pixmap for current stroke
        temp_overlay = self.overlay.copy()
        painter = QPainter(temp_overlay)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Set up pen for redaction
        pen = QPen(self.brush_color, self.brush_size, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin)
        painter.setPen(pen)
        
        # Draw the stroke
        for i in range(1, len(self.current_stroke)):
            painter.drawLine(self.current_stroke[i-1], self.current_stroke[i])
        
        painter.end()
        
        # Update display
        self.update_display_with_overlay(temp_overlay)
    
    def redraw_overlay(self):
        """Redraw the entire overlay from saved data"""
        self.overlay.fill(Qt.GlobalColor.transparent)
        painter = QPainter(self.overlay)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Draw all brush strokes
        for stroke in self.brush_strokes:
            if stroke['type'] == 'redaction':
                color = QColor(stroke['color'])
                pen = QPen(color, stroke['brush_size'], Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin)
                painter.setPen(pen)
                
                points = [QPoint(x, y) for x, y in stroke['points']]
                for i in range(1, len(points)):
                    painter.drawLine(points[i-1], points[i])
        
        # Draw annotations
        for annotation in self.annotations:
            if annotation['type'] == 'text':
                painter.setPen(QPen(QColor(annotation['color']), 2))
                painter.setFont(QFont(annotation.get('font', 'Arial'), annotation.get('size', 12)))
                painter.drawText(QPoint(annotation['x'], annotation['y']), annotation['text'])
            elif annotation['type'] == 'rectangle':
                painter.setPen(QPen(QColor(annotation['color']), 2))
                painter.drawRect(QRect(annotation['x'], annotation['y'], annotation['width'], annotation['height']))
        
        painter.end()
        self.update_display()
    
    def update_display(self):
        """Update the display with current overlay"""
        self.update_display_with_overlay(self.overlay)
    
    def update_display_with_overlay(self, overlay: QPixmap):
        """Update display with specified overlay"""
        # Combine original image with overlay
        combined = self.page_image.copy()
        painter = QPainter(combined)
        
        # Add exclusion overlay if page is excluded
        if self.excluded:
            painter.fillRect(combined.rect(), QColor(255, 0, 0, 100))  # Semi-transparent red
            painter.setPen(QPen(QColor(255, 0, 0), 3))
            painter.setFont(QFont("Arial", 24, QFont.Weight.Bold))
            painter.drawText(combined.rect(), Qt.AlignmentFlag.AlignCenter, "EXCLUDED")
        
        # Add drawing overlay
        painter.drawPixmap(0, 0, overlay)
        painter.end()
        
        self.setPixmap(combined)
    
    def save_state(self):
        """Save current state for undo functionality"""
        state = {
            'brush_strokes': self.brush_strokes.copy(),
            'annotations': self.annotations.copy(),
            'excluded': self.excluded
        }
        
        # Remove any states after current index (for redo)
        self.history = self.history[:self.history_index + 1]
        self.history.append(state)
        self.history_index += 1
        
        # Limit history size
        if len(self.history) > 50:
            self.history.pop(0)
            self.history_index -= 1
    
    def undo(self):
        """Undo last action"""
        if self.history_index > 0:
            self.history_index -= 1
            state = self.history[self.history_index]
            self.restore_state(state)
    
    def redo(self):
        """Redo last undone action"""
        if self.history_index < len(self.history) - 1:
            self.history_index += 1
            state = self.history[self.history_index]
            self.restore_state(state)
    
    def restore_state(self, state: Dict[str, Any]):
        """Restore canvas to a saved state"""
        self.brush_strokes = state['brush_strokes'].copy()
        self.annotations = state['annotations'].copy()
        self.excluded = state['excluded']
        self.redraw_overlay()
    
    def clear_all(self):
        """Clear all drawings and annotations"""
        self.save_state()
        self.brush_strokes.clear()
        self.annotations.clear()
        self.redraw_overlay()
    
    def add_text_annotation(self, x: int, y: int, text: str, color: str = "#0000FF", font: str = "Arial", size: int = 12):
        """Add a text annotation"""
        self.save_state()
        annotation = {
            'type': 'text',
            'x': x,
            'y': y,
            'text': text,
            'color': color,
            'font': font,
            'size': size
        }
        self.annotations.append(annotation)
        self.redraw_overlay()
    
    def add_rectangle_annotation(self, x: int, y: int, width: int, height: int, color: str = "#0000FF"):
        """Add a rectangle annotation"""
        self.save_state()
        annotation = {
            'type': 'rectangle',
            'x': x,
            'y': y,
            'width': width,
            'height': height,
            'color': color
        }
        self.annotations.append(annotation)
        self.redraw_overlay()
    
    def get_edit_data(self) -> Dict[str, Any]:
        """Get all edit data for this page"""
        return {
            'page_number': self.page_number,
            'brush_strokes': self.brush_strokes,
            'annotations': self.annotations,
            'excluded': self.excluded
        }
    
    def load_edit_data(self, data: Dict[str, Any]):
        """Load edit data for this page"""
        self.brush_strokes = data.get('brush_strokes', [])
        self.annotations = data.get('annotations', [])
        self.excluded = data.get('excluded', False)
        self.redraw_overlay()

class PDFEditor(QWidget):
    """Main PDF editor widget with tools and page navigation"""
    
    pages_changed = pyqtSignal()  # Emitted when page exclusions change
    
    def __init__(self, pdf_path: str, parent=None):
        super().__init__(parent)
        self.pdf_path = pdf_path
        self.logger = logging.getLogger(__name__)
        
        # Check dependencies
        if not PYMUPDF_AVAILABLE:
            raise ImportError("PyMuPDF is required for PDF editing. Please install it with: pip install PyMuPDF")
        
        # Data
        self.pages = []  # List of DrawingCanvas widgets
        self.current_page = 0
        self.page_images = []  # Original page images
        
        # Setup UI
        self.setup_ui()
        self.load_pdf()
    
    def setup_ui(self):
        """Setup the user interface"""
        layout = QVBoxLayout(self)
        
        # Toolbar
        toolbar = self.create_toolbar()
        layout.addWidget(toolbar)
        
        # Main content area
        content_layout = QHBoxLayout()
        
        # Left panel - Tools
        tools_panel = self.create_tools_panel()
        content_layout.addWidget(tools_panel)
        
        # Center - PDF viewer
        viewer_panel = self.create_viewer_panel()
        content_layout.addWidget(viewer_panel, 1)  # Give it more space
        
        layout.addLayout(content_layout)
        
        # Navigation
        nav_panel = self.create_navigation_panel()
        layout.addWidget(nav_panel)
    
    def create_toolbar(self):
        """Create the main toolbar"""
        toolbar = QFrame()
        toolbar.setFrameStyle(QFrame.Shape.StyledPanel)
        layout = QHBoxLayout(toolbar)
        
        # File operations
        save_btn = QPushButton("Save Edits")
        save_btn.clicked.connect(self.save_edits)
        layout.addWidget(save_btn)
        
        load_btn = QPushButton("Load Edits")
        load_btn.clicked.connect(self.load_edits)
        layout.addWidget(load_btn)
        
        layout.addWidget(QFrame())  # Separator
        
        # Undo/Redo
        undo_btn = QPushButton("Undo")
        undo_btn.setShortcut("Ctrl+Z")
        undo_btn.clicked.connect(self.undo)
        layout.addWidget(undo_btn)
        
        redo_btn = QPushButton("Redo")
        redo_btn.setShortcut("Ctrl+Y")
        redo_btn.clicked.connect(self.redo)
        layout.addWidget(redo_btn)
        
        layout.addWidget(QFrame())  # Separator
        
        # Clear all
        clear_btn = QPushButton("Clear Page")
        clear_btn.clicked.connect(self.clear_current_page)
        layout.addWidget(clear_btn)
        
        layout.addStretch()
        
        return toolbar
    
    def create_tools_panel(self):
        """Create the tools panel"""
        panel = QGroupBox("Tools")
        layout = QVBoxLayout(panel)
        
        # Tool selection
        tool_group = QGroupBox("Drawing Tool")
        tool_layout = QVBoxLayout(tool_group)
        
        self.tool_buttons = QButtonGroup()
        
        redaction_btn = QPushButton("Redaction Brush")
        redaction_btn.setCheckable(True)
        redaction_btn.setChecked(True)
        redaction_btn.clicked.connect(lambda: self.set_tool("redaction"))
        self.tool_buttons.addButton(redaction_btn, 0)
        tool_layout.addWidget(redaction_btn)
        
        text_btn = QPushButton("Text Annotation")
        text_btn.setCheckable(True)
        text_btn.clicked.connect(lambda: self.set_tool("text"))
        self.tool_buttons.addButton(text_btn, 1)
        tool_layout.addWidget(text_btn)
        
        rect_btn = QPushButton("Rectangle")
        rect_btn.setCheckable(True)
        rect_btn.clicked.connect(lambda: self.set_tool("rectangle"))
        self.tool_buttons.addButton(rect_btn, 2)
        tool_layout.addWidget(rect_btn)
        
        layout.addWidget(tool_group)
        
        # Brush settings
        brush_group = QGroupBox("Brush Settings")
        brush_layout = QVBoxLayout(brush_group)
        
        # Brush size
        brush_layout.addWidget(QLabel("Brush Size:"))
        self.brush_size_slider = QSlider(Qt.Orientation.Horizontal)
        self.brush_size_slider.setRange(1, 50)
        self.brush_size_slider.setValue(10)
        self.brush_size_slider.valueChanged.connect(self.update_brush_size)
        brush_layout.addWidget(self.brush_size_slider)
        
        self.brush_size_label = QLabel("10 px")
        brush_layout.addWidget(self.brush_size_label)
        
        # Color selection
        self.color_btn = QPushButton("Black")
        self.color_btn.setStyleSheet("QPushButton { background-color: black; color: white; }")
        self.color_btn.clicked.connect(self.choose_color)
        brush_layout.addWidget(self.color_btn)
        
        layout.addWidget(brush_group)
        
        # Page settings
        page_group = QGroupBox("Page Settings")
        page_layout = QVBoxLayout(page_group)
        
        self.exclude_checkbox = QCheckBox("Exclude this page")
        self.exclude_checkbox.toggled.connect(self.toggle_page_exclusion)
        page_layout.addWidget(self.exclude_checkbox)
        
        layout.addWidget(page_group)
        
        layout.addStretch()
        
        return panel
    
    def create_viewer_panel(self):
        """Create the PDF viewer panel"""
        panel = QGroupBox("PDF Viewer")
        layout = QVBoxLayout(panel)
        
        # Scroll area for PDF page
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.scroll_area)
        
        return panel
    
    def create_navigation_panel(self):
        """Create the navigation panel"""
        panel = QFrame()
        panel.setFrameStyle(QFrame.Shape.StyledPanel)
        layout = QHBoxLayout(panel)
        
        # Previous page
        prev_btn = QPushButton("◀ Previous")
        prev_btn.clicked.connect(self.previous_page)
        layout.addWidget(prev_btn)
        
        # Page info
        self.page_label = QLabel("Page 1 of 1")
        self.page_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.page_label)
        
        # Next page
        next_btn = QPushButton("Next ▶")
        next_btn.clicked.connect(self.next_page)
        layout.addWidget(next_btn)
        
        layout.addStretch()
        
        # Page exclusion summary
        self.exclusion_label = QLabel("0 pages excluded")
        layout.addWidget(self.exclusion_label)
        
        return panel
    
    def load_pdf(self):
        """Load PDF and convert pages to images using PyMuPDF"""
        try:
            self.logger.info(f"Loading PDF: {self.pdf_path}")
            
            # Check if file exists
            if not os.path.exists(self.pdf_path):
                raise FileNotFoundError(f"PDF file not found: {self.pdf_path}")
            
            # Open PDF with PyMuPDF
            pdf_document = fitz.open(self.pdf_path)
            
            self.page_images = []
            self.pages = []
            
            for page_num in range(len(pdf_document)):
                # Get page
                page = pdf_document[page_num]
                
                # Render page to image (150 DPI)
                mat = fitz.Matrix(150/72, 150/72)  # 150 DPI scaling
                pix = page.get_pixmap(matrix=mat)
                
                # Convert to PIL Image
                img_data = pix.tobytes("png")
                pil_image = Image.open(io.BytesIO(img_data))
                
                # Convert PIL image to QPixmap
                temp_path = f"temp_page_{page_num}.png"
                pil_image.save(temp_path, "PNG")
                
                pixmap = QPixmap(temp_path)
                self.page_images.append(pixmap)
                
                # Create drawing canvas
                canvas = DrawingCanvas(pixmap, page_num)
                self.pages.append(canvas)
                
                # Clean up temp file
                os.remove(temp_path)
            
            # Close PDF document
            pdf_document.close()
            
            # Show first page
            if self.pages:
                self.show_page(0)
            
            self.logger.info(f"Loaded {len(self.pages)} pages")
            
        except Exception as e:
            self.logger.error(f"Error loading PDF: {e}")
            raise Exception(f"Failed to load PDF: {str(e)}")
    
    def show_page(self, page_num: int):
        """Show specified page"""
        if 0 <= page_num < len(self.pages):
            self.current_page = page_num
            canvas = self.pages[page_num]
            
            # Update scroll area
            self.scroll_area.setWidget(canvas)
            
            # Update UI
            self.page_label.setText(f"Page {page_num + 1} of {len(self.pages)}")
            self.exclude_checkbox.setChecked(canvas.excluded)
            
            # Update tool settings
            canvas.set_brush_size(self.brush_size_slider.value())
            canvas.set_tool(self.get_current_tool())
            
            self.update_exclusion_summary()
    
    def previous_page(self):
        """Go to previous page"""
        if self.current_page > 0:
            self.show_page(self.current_page - 1)
    
    def next_page(self):
        """Go to next page"""
        if self.current_page < len(self.pages) - 1:
            self.show_page(self.current_page + 1)
    
    def set_tool(self, tool: str):
        """Set current drawing tool"""
        if self.pages:
            self.pages[self.current_page].set_tool(tool)
    
    def get_current_tool(self) -> str:
        """Get current tool name"""
        checked_id = self.tool_buttons.checkedId()
        tools = ["redaction", "text", "rectangle"]
        return tools[checked_id] if 0 <= checked_id < len(tools) else "redaction"
    
    def update_brush_size(self, size: int):
        """Update brush size"""
        self.brush_size_label.setText(f"{size} px")
        if self.pages:
            self.pages[self.current_page].set_brush_size(size)
    
    def choose_color(self):
        """Open color chooser dialog"""
        color = QColorDialog.getColor(QColor(0, 0, 0), self, "Choose Color")
        if color.isValid():
            self.color_btn.setText(color.name())
            self.color_btn.setStyleSheet(f"QPushButton {{ background-color: {color.name()}; color: white; }}")
            if self.pages:
                self.pages[self.current_page].set_brush_color(color)
    
    def toggle_page_exclusion(self, excluded: bool):
        """Toggle page exclusion"""
        if self.pages:
            self.pages[self.current_page].set_excluded(excluded)
            self.update_exclusion_summary()
            self.pages_changed.emit()
    
    def update_exclusion_summary(self):
        """Update exclusion summary label"""
        excluded_count = sum(1 for page in self.pages if page.excluded)
        self.exclusion_label.setText(f"{excluded_count} pages excluded")
    
    def undo(self):
        """Undo last action on current page"""
        if self.pages:
            self.pages[self.current_page].undo()
    
    def redo(self):
        """Redo last action on current page"""
        if self.pages:
            self.pages[self.current_page].redo()
    
    def clear_current_page(self):
        """Clear all edits on current page"""
        if self.pages:
            reply = QMessageBox.question(
                self,
                "Clear Page",
                "Are you sure you want to clear all edits on this page?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.pages[self.current_page].clear_all()
    
    def get_all_edits(self) -> Dict[str, Any]:
        """Get all edits for all pages"""
        return {
            'pdf_path': self.pdf_path,
            'pages': [page.get_edit_data() for page in self.pages]
        }
    
    def get_excluded_pages(self) -> List[int]:
        """Get list of excluded page numbers (0-based)"""
        return [i for i, page in enumerate(self.pages) if page.excluded]
    
    def save_edits(self):
        """Save edits to file"""
        from PyQt6.QtWidgets import QFileDialog
        
        filename = f"{Path(self.pdf_path).stem}_edits.json"
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save PDF Edits",
            filename,
            "JSON Files (*.json);;All Files (*)"
        )
        
        if file_path:
            try:
                edits = self.get_all_edits()
                with open(file_path, 'w') as f:
                    json.dump(edits, f, indent=2)
                
                QMessageBox.information(self, "Saved", f"Edits saved to:\n{file_path}")
                
            except Exception as e:
                self.logger.error(f"Error saving edits: {e}")
                QMessageBox.critical(self, "Error", f"Failed to save edits:\n{str(e)}")
    
    def load_edits(self):
        """Load edits from file"""
        from PyQt6.QtWidgets import QFileDialog
        
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Load PDF Edits",
            "",
            "JSON Files (*.json);;All Files (*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'r') as f:
                    edits = json.load(f)
                
                # Load edits for each page
                for page_data in edits.get('pages', []):
                    page_num = page_data.get('page_number', 0)
                    if 0 <= page_num < len(self.pages):
                        self.pages[page_num].load_edit_data(page_data)
                
                # Refresh current page
                self.show_page(self.current_page)
                
                QMessageBox.information(self, "Loaded", f"Edits loaded from:\n{file_path}")
                
            except Exception as e:
                self.logger.error(f"Error loading edits: {e}")
                QMessageBox.critical(self, "Error", f"Failed to load edits:\n{str(e)}")
 
# --- END OF FILE: pdf_editor.py --- 
 
# --- START OF FILE: pdf_processor.py --- 
 
"""
PDF Processor Module
Handles PDF combining, page exclusion, and basic editing
"""

import os
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any, Tuple
import PyPDF2
from PyPDF2 import PdfWriter, PdfReader

try:
    import fitz  # PyMuPDF
    PYMUPDF_AVAILABLE = True
except ImportError:
    PYMUPDF_AVAILABLE = False

class PDFProcessor:
    """
    PDF processor for combining and basic editing operations
    """
    
    def __init__(self):
        """Initialize PDF processor"""
        self.logger = logging.getLogger(__name__)
    
    def combine_pdfs(self, pdf_files: List[str], output_path: str, 
                    excluded_pages: Dict[str, List[int]] = None) -> bool:
        """
        Combine multiple PDF files into one, optionally excluding specific pages
        
        Args:
            pdf_files: List of PDF file paths to combine
            output_path: Path for the combined PDF output
            excluded_pages: Dict mapping file paths to lists of page numbers to exclude (0-based)
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            if not pdf_files:
                self.logger.error("No PDF files provided for combining")
                return False
            
            # Create output directory if needed
            output_dir = Path(output_path).parent
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Initialize PDF writer
            pdf_writer = PdfWriter()
            
            # Process each PDF file
            for pdf_path in pdf_files:
                try:
                    if not Path(pdf_path).exists():
                        self.logger.warning(f"PDF file not found: {pdf_path}")
                        continue
                    
                    # Get excluded pages for this file
                    excluded = excluded_pages.get(pdf_path, []) if excluded_pages else []
                    
                    # Read PDF
                    with open(pdf_path, 'rb') as file:
                        pdf_reader = PdfReader(file)
                        
                        # Add pages (excluding specified ones)
                        for page_num in range(len(pdf_reader.pages)):
                            if page_num not in excluded:
                                page = pdf_reader.pages[page_num]
                                pdf_writer.add_page(page)
                            else:
                                self.logger.info(f"Excluding page {page_num + 1} from {Path(pdf_path).name}")
                
                except Exception as e:
                    self.logger.error(f"Error processing PDF {pdf_path}: {e}")
                    continue
            
            # Write combined PDF
            with open(output_path, 'wb') as output_file:
                pdf_writer.write(output_file)
            
            self.logger.info(f"Successfully combined {len(pdf_files)} PDFs into {output_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error combining PDFs: {e}")
            return False
    
    def get_pdf_info(self, pdf_path: str) -> Dict[str, Any]:
        """
        Get information about a PDF file
        
        Args:
            pdf_path: Path to the PDF file
            
        Returns:
            dict: PDF information including page count, size, etc.
        """
        try:
            file_path = Path(pdf_path)
            
            if not file_path.exists():
                return {'error': 'File not found'}
            
            # Get file stats
            stat = file_path.stat()
            size_mb = stat.st_size / (1024 * 1024)
            
            # Read PDF
            with open(pdf_path, 'rb') as file:
                pdf_reader = PdfReader(file)
                page_count = len(pdf_reader.pages)
                
                # Try to get metadata
                metadata = pdf_reader.metadata
                
                return {
                    'file_path': str(file_path),
                    'file_name': file_path.name,
                    'size_bytes': stat.st_size,
                    'size_mb': round(size_mb, 2),
                    'page_count': page_count,
                    'title': metadata.title if metadata and metadata.title else None,
                    'author': metadata.author if metadata and metadata.author else None,
                    'subject': metadata.subject if metadata and metadata.subject else None,
                    'creator': metadata.creator if metadata and metadata.creator else None,
                    'producer': metadata.producer if metadata and metadata.producer else None,
                    'creation_date': str(metadata.creation_date) if metadata and metadata.creation_date else None,
                    'modification_date': str(metadata.modification_date) if metadata and metadata.modification_date else None
                }
                
        except Exception as e:
            self.logger.error(f"Error getting PDF info for {pdf_path}: {e}")
            return {'error': str(e)}
    
    def validate_pdf_combination(self, pdf_files: List[str], 
                               excluded_pages: Dict[str, List[int]] = None,
                               max_size_mb: float = 36.0) -> Dict[str, Any]:
        """
        Validate a PDF combination before processing
        
        Args:
            pdf_files: List of PDF file paths
            excluded_pages: Dict of excluded pages per file
            max_size_mb: Maximum allowed size in MB
            
        Returns:
            dict: Validation results
        """
        result = {
            'is_valid': True,
            'errors': [],
            'warnings': [],
            'total_size_mb': 0.0,
            'total_pages': 0,
            'file_count': len(pdf_files),
            'files_info': []
        }
        
        if not pdf_files:
            result['is_valid'] = False
            result['errors'].append("No PDF files provided")
            return result
        
        total_size = 0.0
        total_pages = 0
        
        for pdf_path in pdf_files:
            file_info = self.get_pdf_info(pdf_path)
            
            if 'error' in file_info:
                result['errors'].append(f"Error with {Path(pdf_path).name}: {file_info['error']}")
                result['is_valid'] = False
                continue
            
            # Calculate pages after exclusions
            excluded = excluded_pages.get(pdf_path, []) if excluded_pages else []
            included_pages = file_info['page_count'] - len(excluded)
            
            if included_pages <= 0:
                result['warnings'].append(f"All pages excluded from {file_info['file_name']}")
            
            total_size += file_info['size_mb']
            total_pages += included_pages
            
            file_info['excluded_pages'] = excluded
            file_info['included_pages'] = included_pages
            result['files_info'].append(file_info)
        
        result['total_size_mb'] = round(total_size, 2)
        result['total_pages'] = total_pages
        
        # Check size limit
        if total_size > max_size_mb:
            result['errors'].append(f"Total size ({total_size:.1f} MB) exceeds limit ({max_size_mb} MB)")
            result['is_valid'] = False
        
        # Size warning
        if total_size > max_size_mb * 0.8:
            result['warnings'].append(f"Total size ({total_size:.1f} MB) is close to limit ({max_size_mb} MB)")
        
        # Page count warning
        if total_pages == 0:
            result['errors'].append("No pages will be included in the final PDF")
            result['is_valid'] = False
        elif total_pages > 100:
            result['warnings'].append(f"Large number of pages ({total_pages}) may cause processing delays")
        
        return result
    
    def extract_pages(self, pdf_path: str, page_numbers: List[int], 
                     output_path: str) -> bool:
        """
        Extract specific pages from a PDF
        
        Args:
            pdf_path: Source PDF file path
            page_numbers: List of page numbers to extract (0-based)
            output_path: Output file path
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            if not Path(pdf_path).exists():
                self.logger.error(f"Source PDF not found: {pdf_path}")
                return False
            
            # Create output directory
            output_dir = Path(output_path).parent
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Read source PDF
            with open(pdf_path, 'rb') as file:
                pdf_reader = PdfReader(file)
                pdf_writer = PdfWriter()
                
                # Validate page numbers
                max_pages = len(pdf_reader.pages)
                valid_pages = [p for p in page_numbers if 0 <= p < max_pages]
                
                if not valid_pages:
                    self.logger.error("No valid page numbers provided")
                    return False
                
                # Extract pages
                for page_num in sorted(valid_pages):
                    page = pdf_reader.pages[page_num]
                    pdf_writer.add_page(page)
                
                # Write output
                with open(output_path, 'wb') as output_file:
                    pdf_writer.write(output_file)
            
            self.logger.info(f"Extracted {len(valid_pages)} pages to {output_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error extracting pages: {e}")
            return False
    
    def get_page_count(self, pdf_path: str) -> int:
        """
        Get the number of pages in a PDF
        
        Args:
            pdf_path: Path to PDF file
            
        Returns:
            int: Number of pages, or 0 if error
        """
        try:
            with open(pdf_path, 'rb') as file:
                pdf_reader = PdfReader(file)
                return len(pdf_reader.pages)
        except Exception as e:
            self.logger.error(f"Error getting page count for {pdf_path}: {e}")
            return 0
    
    def split_pdf(self, pdf_path: str, output_dir: str, 
                  pages_per_file: int = 1) -> List[str]:
        """
        Split a PDF into multiple files
        
        Args:
            pdf_path: Source PDF file path
            output_dir: Directory to save split files
            pages_per_file: Number of pages per output file
            
        Returns:
            list: List of created file paths
        """
        try:
            if not Path(pdf_path).exists():
                self.logger.error(f"Source PDF not found: {pdf_path}")
                return []
            
            # Create output directory
            output_path = Path(output_dir)
            output_path.mkdir(parents=True, exist_ok=True)
            
            # Read source PDF
            with open(pdf_path, 'rb') as file:
                pdf_reader = PdfReader(file)
                total_pages = len(pdf_reader.pages)
                
                created_files = []
                base_name = Path(pdf_path).stem
                
                # Split into chunks
                for start_page in range(0, total_pages, pages_per_file):
                    end_page = min(start_page + pages_per_file, total_pages)
                    
                    # Create output filename
                    if pages_per_file == 1:
                        output_filename = f"{base_name}_page_{start_page + 1}.pdf"
                    else:
                        output_filename = f"{base_name}_pages_{start_page + 1}-{end_page}.pdf"
                    
                    output_file_path = output_path / output_filename
                    
                    # Create PDF writer for this chunk
                    pdf_writer = PdfWriter()
                    
                    # Add pages to this chunk
                    for page_num in range(start_page, end_page):
                        page = pdf_reader.pages[page_num]
                        pdf_writer.add_page(page)
                    
                    # Write chunk
                    with open(output_file_path, 'wb') as output_file:
                        pdf_writer.write(output_file)
                    
                    created_files.append(str(output_file_path))
                
                self.logger.info(f"Split PDF into {len(created_files)} files")
                return created_files
                
        except Exception as e:
            self.logger.error(f"Error splitting PDF: {e}")
            return []
    
    def add_cover_page(self, cover_pdf_path: str, content_pdf_path: str, 
                      output_path: str) -> bool:
        """
        Add a cover page to the beginning of a PDF
        
        Args:
            cover_pdf_path: Path to cover page PDF
            content_pdf_path: Path to content PDF
            output_path: Path for combined output
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            if not Path(cover_pdf_path).exists():
                self.logger.error(f"Cover page PDF not found: {cover_pdf_path}")
                return False
            
            if not Path(content_pdf_path).exists():
                self.logger.error(f"Content PDF not found: {content_pdf_path}")
                return False
            
            # Create output directory
            output_dir = Path(output_path).parent
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Combine PDFs
            pdf_writer = PdfWriter()
            
            # Add cover page
            with open(cover_pdf_path, 'rb') as cover_file:
                cover_reader = PdfReader(cover_file)
                for page in cover_reader.pages:
                    pdf_writer.add_page(page)
            
            # Add content pages
            with open(content_pdf_path, 'rb') as content_file:
                content_reader = PdfReader(content_file)
                for page in content_reader.pages:
                    pdf_writer.add_page(page)
            
            # Write combined PDF
            with open(output_path, 'wb') as output_file:
                pdf_writer.write(output_file)
            
            self.logger.info(f"Added cover page to PDF: {output_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error adding cover page: {e}")
            return False
    
    def apply_edits_to_pdf(self, pdf_path: str, edit_data: Dict[str, Any], 
                          output_path: str) -> bool:
        """
        Apply visual edits (redactions, highlights, annotations) to a PDF
        
        Args:
            pdf_path: Source PDF file path
            edit_data: Edit data from PDF editor containing brush strokes and annotations
            output_path: Path for the edited PDF output
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            if not PYMUPDF_AVAILABLE:
                self.logger.error("PyMuPDF is required for applying PDF edits")
                return False
            
            if not Path(pdf_path).exists():
                self.logger.error(f"Source PDF not found: {pdf_path}")
                return False
            
            # Create output directory
            output_dir = Path(output_path).parent
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Open PDF with PyMuPDF
            pdf_document = fitz.open(pdf_path)
            
            # Get pages data from edit_data
            pages_data = edit_data.get('pages', [])
            
            # Apply edits to each page
            for page_data in pages_data:
                page_num = page_data.get('page_number', 0)
                
                # Skip if page is excluded
                if page_data.get('excluded', False):
                    continue
                
                # Skip if page number is invalid
                if page_num < 0 or page_num >= len(pdf_document):
                    continue
                
                page = pdf_document[page_num]
                
                # Apply brush strokes (redactions, highlights)
                brush_strokes = page_data.get('brush_strokes', [])
                for stroke in brush_strokes:
                    self._apply_brush_stroke(page, stroke)
                
                # Apply annotations (text, rectangles)
                annotations = page_data.get('annotations', [])
                for annotation in annotations:
                    self._apply_annotation(page, annotation)
            
            # Save the edited PDF
            pdf_document.save(output_path)
            pdf_document.close()
            
            self.logger.info(f"Applied edits to PDF: {output_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error applying edits to PDF: {e}")
            return False
    
    def _apply_brush_stroke(self, page, stroke_data: Dict[str, Any]):
        """Apply a brush stroke (redaction/highlight) to a PDF page"""
        try:
            stroke_type = stroke_data.get('type', 'redaction')
            points = stroke_data.get('points', [])
            brush_size = stroke_data.get('brush_size', 10)
            color_str = stroke_data.get('color', '#000000')
            
            if len(points) < 2:
                return
            
            # Convert color string to RGB tuple
            color = self._hex_to_rgb(color_str)
            
            # Create path from points
            if stroke_type == 'redaction':
                # For redactions, create filled rectangles along the path
                for i in range(len(points) - 1):
                    x1, y1 = points[i]
                    x2, y2 = points[i + 1]
                    
                    # Create rectangle around the line segment
                    rect = fitz.Rect(
                        min(x1, x2) - brush_size/2,
                        min(y1, y2) - brush_size/2,
                        max(x1, x2) + brush_size/2,
                        max(y1, y2) + brush_size/2
                    )
                    
                    # Add redaction annotation
                    redact_annot = page.add_redact_annot(rect)
                    redact_annot.set_colors(stroke=color, fill=color)
                    redact_annot.update()
                
                # Apply redactions
                page.apply_redactions()
                
            else:
                # For highlights and other strokes, draw as shapes
                shape = page.new_shape()
                
                # Set stroke properties
                shape.width = brush_size
                shape.color = color
                
                # Draw path
                shape.draw_line(fitz.Point(points[0][0], points[0][1]), 
                              fitz.Point(points[1][0], points[1][1]))
                
                for i in range(1, len(points) - 1):
                    shape.draw_line(fitz.Point(points[i][0], points[i][1]), 
                                  fitz.Point(points[i+1][0], points[i+1][1]))
                
                # Commit the shape
                shape.commit()
                
        except Exception as e:
            self.logger.error(f"Error applying brush stroke: {e}")
    
    def _apply_annotation(self, page, annotation_data: Dict[str, Any]):
        """Apply an annotation (text, rectangle) to a PDF page"""
        try:
            annotation_type = annotation_data.get('type', 'text')
            color_str = annotation_data.get('color', '#0000FF')
            color = self._hex_to_rgb(color_str)
            
            if annotation_type == 'text':
                x = annotation_data.get('x', 0)
                y = annotation_data.get('y', 0)
                text = annotation_data.get('text', '')
                font_size = annotation_data.get('size', 12)
                
                # Add text annotation
                point = fitz.Point(x, y)
                text_annot = page.add_text_annot(point, text)
                text_annot.set_info(content=text)
                text_annot.update()
                
                # Also add the text directly to the page
                page.insert_text(point, text, fontsize=font_size, color=color)
                
            elif annotation_type == 'rectangle':
                x = annotation_data.get('x', 0)
                y = annotation_data.get('y', 0)
                width = annotation_data.get('width', 100)
                height = annotation_data.get('height', 50)
                
                # Create rectangle
                rect = fitz.Rect(x, y, x + width, y + height)
                
                # Add rectangle annotation
                rect_annot = page.add_rect_annot(rect)
                rect_annot.set_colors(stroke=color)
                rect_annot.update()
                
        except Exception as e:
            self.logger.error(f"Error applying annotation: {e}")
    
    def _hex_to_rgb(self, hex_color: str) -> Tuple[float, float, float]:
        """Convert hex color string to RGB tuple (0-1 range)"""
        try:
            # Remove # if present
            hex_color = hex_color.lstrip('#')
            
            # Convert to RGB (0-255 range)
            r = int(hex_color[0:2], 16)
            g = int(hex_color[2:4], 16)
            b = int(hex_color[4:6], 16)
            
            # Convert to 0-1 range for PyMuPDF
            return (r/255.0, g/255.0, b/255.0)
            
        except Exception:
            # Default to black if conversion fails
            return (0.0, 0.0, 0.0)
    
    def combine_pdfs_with_edits(self, pdf_files: List[str], output_path: str,
                               edit_data_map: Dict[str, Dict[str, Any]] = None,
                               excluded_pages: Dict[str, List[int]] = None) -> bool:
        """
        Combine multiple PDF files with applied edits
        
        Args:
            pdf_files: List of PDF file paths to combine
            output_path: Path for the combined PDF output
            edit_data_map: Dict mapping file paths to their edit data
            excluded_pages: Dict mapping file paths to lists of page numbers to exclude (0-based)
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            if not pdf_files:
                self.logger.error("No PDF files provided for combining")
                return False
            
            # Create temporary directory for edited PDFs
            temp_dir = Path(output_path).parent / "temp_edited_pdfs"
            temp_dir.mkdir(exist_ok=True)
            
            # List to store paths of PDFs to combine (original or edited)
            pdfs_to_combine = []
            temp_files_to_cleanup = []
            
            # Process each PDF file
            for pdf_path in pdf_files:
                if not Path(pdf_path).exists():
                    self.logger.warning(f"PDF file not found: {pdf_path}")
                    continue
                
                # Check if this PDF has edits
                edit_data = edit_data_map.get(pdf_path) if edit_data_map else None
                
                if edit_data and self._has_visual_edits(edit_data):
                    # Apply edits and use edited version
                    temp_edited_path = temp_dir / f"edited_{Path(pdf_path).name}"
                    
                    if self.apply_edits_to_pdf(pdf_path, edit_data, str(temp_edited_path)):
                        pdfs_to_combine.append(str(temp_edited_path))
                        temp_files_to_cleanup.append(str(temp_edited_path))
                        self.logger.info(f"Using edited version of {Path(pdf_path).name}")
                    else:
                        # Fall back to original if edit application fails
                        pdfs_to_combine.append(pdf_path)
                        self.logger.warning(f"Failed to apply edits to {Path(pdf_path).name}, using original")
                else:
                    # Use original PDF
                    pdfs_to_combine.append(pdf_path)
            
            # Combine the PDFs (original or edited versions)
            success = self.combine_pdfs(pdfs_to_combine, output_path, excluded_pages)
            
            # Clean up temporary files
            for temp_file in temp_files_to_cleanup:
                try:
                    Path(temp_file).unlink()
                except Exception as e:
                    self.logger.warning(f"Failed to clean up temp file {temp_file}: {e}")
            
            # Remove temp directory if empty
            try:
                temp_dir.rmdir()
            except Exception:
                pass  # Directory might not be empty or might not exist
            
            return success
            
        except Exception as e:
            self.logger.error(f"Error combining PDFs with edits: {e}")
            return False
    
    def _has_visual_edits(self, edit_data: Dict[str, Any]) -> bool:
        """Check if edit data contains visual edits that need to be applied"""
        pages_data = edit_data.get('pages', [])
        
        for page_data in pages_data:
            # Skip excluded pages
            if page_data.get('excluded', False):
                continue
                
            # Check for brush strokes
            if page_data.get('brush_strokes'):
                return True
                
            # Check for annotations
            if page_data.get('annotations'):
                return True
        
        return False

# Utility functions
def quick_combine_pdfs(pdf_files: List[str], output_path: str) -> bool:
    """
    Quick utility to combine PDFs without exclusions
    
    Args:
        pdf_files: List of PDF file paths
        output_path: Output file path
        
    Returns:
        bool: True if successful, False otherwise
    """
    processor = PDFProcessor()
    return processor.combine_pdfs(pdf_files, output_path)

def get_total_pages(pdf_files: List[str]) -> int:
    """
    Get total page count across multiple PDFs
    
    Args:
        pdf_files: List of PDF file paths
        
    Returns:
        int: Total page count
    """
    processor = PDFProcessor()
    total = 0
    for pdf_path in pdf_files:
        total += processor.get_page_count(pdf_path)
    return total

def validate_pdf_files(pdf_files: List[str]) -> Dict[str, Any]:
    """
    Validate a list of PDF files
    
    Args:
        pdf_files: List of PDF file paths
        
    Returns:
        dict: Validation results
    """
    processor = PDFProcessor()
    return processor.validate_pdf_combination(pdf_files)
 
# --- END OF FILE: pdf_processor.py --- 
 
# --- START OF FILE: cover_page.py --- 
 
"""
Cover Page Generator Module
Creates cover pages for fax jobs using reportlab
"""

import os
import logging
from pathlib import Path
from typing import Optional, Dict, Any
from datetime import datetime
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib import colors
from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT
from reportlab.graphics.shapes import Drawing, Circle, Rect
from reportlab.graphics import renderPDF

from database.models import CoverPageDetails

class CoverPageGenerator:
    """
    Generator for fax cover pages
    """
    
    def __init__(self):
        """Initialize cover page generator"""
        self.logger = logging.getLogger(__name__)
        self.styles = getSampleStyleSheet()
        self.setup_custom_styles()
    
    def setup_custom_styles(self):
        """Setup custom styles for cover page"""
        # Title style
        self.title_style = ParagraphStyle(
            'CustomTitle',
            parent=self.styles['Heading1'],
            fontSize=36,
            spaceAfter=20,
            alignment=TA_LEFT,
            textColor=colors.black,
            fontName='Helvetica-Bold'
        )
        
        # Header info style
        self.header_info_style = ParagraphStyle(
            'HeaderInfo',
            parent=self.styles['Normal'],
            fontSize=10,
            spaceAfter=2,
            alignment=TA_LEFT,
            textColor=colors.black,
            fontName='Helvetica'
        )
        
        # Hospital name style
        self.hospital_name_style = ParagraphStyle(
            'HospitalName',
            parent=self.styles['Heading2'],
            fontSize=18,
            spaceAfter=5,
            alignment=TA_RIGHT,
            textColor=colors.black,
            fontName='Helvetica-Bold'
        )
        
        # Hospital subtitle style
        self.hospital_subtitle_style = ParagraphStyle(
            'HospitalSubtitle',
            parent=self.styles['Normal'],
            fontSize=12,
            spaceAfter=2,
            alignment=TA_RIGHT,
            textColor=colors.black,
            fontName='Helvetica'
        )
        
        # Field label style
        self.label_style = ParagraphStyle(
            'FieldLabel',
            parent=self.styles['Normal'],
            fontSize=11,
            fontName='Helvetica-Bold',
            textColor=colors.black
        )
        
        # Field value style
        self.value_style = ParagraphStyle(
            'FieldValue',
            parent=self.styles['Normal'],
            fontSize=11,
            fontName='Helvetica',
            textColor=colors.black
        )
        
        # Checkbox label style
        self.checkbox_style = ParagraphStyle(
            'CheckboxLabel',
            parent=self.styles['Normal'],
            fontSize=11,
            fontName='Helvetica',
            textColor=colors.black
        )
        
        # Message style
        self.message_style = ParagraphStyle(
            'MessageStyle',
            parent=self.styles['Normal'],
            fontSize=11,
            fontName='Helvetica',
            textColor=colors.black,
            spaceAfter=12
        )
    
    def generate_cover_page(self, cover_details: CoverPageDetails, 
                          output_path: str, page_count: int = 0, 
                          logo_path: Optional[str] = None) -> bool:
        """
        Generate a cover page PDF
        
        Args:
            cover_details: Cover page details
            output_path: Path to save the cover page PDF
            page_count: Number of pages in the fax (excluding cover page)
            logo_path: Path to hospital logo image
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Create output directory if it doesn't exist
            output_dir = Path(output_path).parent
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Create PDF document
            doc = SimpleDocTemplate(
                output_path,
                pagesize=letter,
                rightMargin=72,
                leftMargin=72,
                topMargin=36,
                bottomMargin=72
            )
            
            # Build content
            story = []
            
            # Header section with hospital info and logo
            story.extend(self._create_header_section(logo_path))
            story.append(Spacer(1, 20))
            
            # Fax title
            title = Paragraph("Fax", self.title_style)
            story.append(title)
            story.append(Spacer(1, 15))
            
            # Main information table
            story.append(self._create_main_info_table(cover_details, page_count))
            story.append(Spacer(1, 15))
            
            # Checkboxes section
            story.append(self._create_checkboxes_section(cover_details))
            story.append(Spacer(1, 20))
            
            # Message section (if any content)
            if cover_details.comments or cover_details.msg:
                story.extend(self._create_message_section(cover_details))
            
            # Build PDF
            doc.build(story)
            
            self.logger.info(f"Cover page generated successfully: {output_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error generating cover page: {e}")
            return False
    
    def _create_header_section(self, logo_path: Optional[str] = None) -> list:
        """Create the header section with hospital info and logo"""
        elements = []
        
        # Create header table with contact info on left and hospital name/logo on right
        header_data = []
        
        # Left side - contact information
        contact_info = [
            "10105 Park Rowe Circle",
            "Baton Rouge, Louisiana  70810",
            "T:  (225) 906-4805",
            "F:  (225) 763-2085"
        ]
        
        contact_paragraphs = []
        for info in contact_info:
            contact_paragraphs.append(Paragraph(info, self.header_info_style))
        
        # Right side - hospital name and logo
        hospital_info = []
        
        # Add logo if available
        if logo_path and os.path.exists(logo_path):
            try:
                # Create logo image with appropriate sizing
                logo = Image(logo_path, width=1.5*inch, height=1.5*inch, kind='proportional')
                hospital_info.append(logo)
            except Exception as e:
                self.logger.warning(f"Could not load logo: {e}")
        
        # Hospital name and subtitle
        hospital_info.append(Paragraph("THE SPINE HOSPITAL", self.hospital_name_style))
        hospital_info.append(Paragraph("LOUISIANA", self.hospital_name_style))
        hospital_info.append(Paragraph("at The NeuroMedical Center", self.hospital_subtitle_style))
        
        # Create the header table
        header_table_data = [[contact_paragraphs, hospital_info]]
        
        header_table = Table(header_table_data, colWidths=[3*inch, 4*inch])
        header_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('ALIGN', (0, 0), (0, 0), 'LEFT'),
            ('ALIGN', (1, 0), (1, 0), 'RIGHT'),
            ('LEFTPADDING', (0, 0), (-1, -1), 0),
            ('RIGHTPADDING', (0, 0), (-1, -1), 0),
            ('TOPPADDING', (0, 0), (-1, -1), 0),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 0),
        ]))
        
        elements.append(header_table)
        
        # Add decorative red dots (similar to original template)
        elements.append(self._create_decorative_dots())
        
        return elements
    
    def _create_decorative_dots(self):
        """Create decorative red dots similar to the original template"""
        # Create a drawing with red dots
        drawing = Drawing(400, 20)
        
        # Add vertical line of red dots
        dot_color = colors.Color(0.8, 0.2, 0.2)  # Red color
        
        for i in range(8):
            y_pos = 2 + (i * 2)
            circle = Circle(200, y_pos, 2)
            circle.fillColor = dot_color
            circle.strokeColor = dot_color
            drawing.add(circle)
        
        return drawing
    
    def _create_main_info_table(self, cover_details: CoverPageDetails, page_count: int):
        """Create the main information table"""
        # Calculate total pages (including cover page)
        total_pages = page_count + 1
        
        # Create the main table data
        table_data = [
            # Row 1: To and From
            [
                Paragraph("To:", self.label_style),
                Paragraph(cover_details.to or "", self.value_style),
                Paragraph("From:", self.label_style),
                Paragraph(cover_details.from_field or "", self.value_style)
            ],
            # Row 2: Fax and Phone
            [
                Paragraph("Fax:", self.label_style),
                Paragraph(cover_details.fax or "", self.value_style),
                Paragraph("Phone:", self.label_style),
                Paragraph(cover_details.phone or "", self.value_style)
            ],
            # Row 3: Pages and Date
            [
                Paragraph("Pages:", self.label_style),
                Paragraph(f"{total_pages} (including this one)", self.value_style),
                Paragraph("Date:", self.label_style),
                Paragraph(cover_details.date or datetime.now().strftime("%m/%d/%Y"), self.value_style)
            ],
            # Row 4: Re and CC
            [
                Paragraph("Re:", self.label_style),
                Paragraph(cover_details.re or "", self.value_style),
                Paragraph("CC:", self.label_style),
                Paragraph(cover_details.cc or "", self.value_style)
            ]
        ]
        
        # Create table
        main_table = Table(table_data, colWidths=[0.8*inch, 2.7*inch, 0.8*inch, 2.7*inch])
        main_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('LEFTPADDING', (0, 0), (-1, -1), 6),
            ('RIGHTPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 8),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),  # Label columns
            ('BACKGROUND', (2, 0), (2, -1), colors.lightgrey),
        ]))
        
        return main_table
    
    def _create_checkboxes_section(self, cover_details: CoverPageDetails):
        """Create the checkboxes section"""
        # Create checkbox symbols
        checked_box = "☑"
        unchecked_box = "☐"
        
        # Create checkbox data
        checkbox_data = [[
            Paragraph(f"{checked_box if cover_details.urgent else unchecked_box} Urgent", self.checkbox_style),
            Paragraph(f"{checked_box if cover_details.for_review else unchecked_box} For Review", self.checkbox_style),
            Paragraph(f"{checked_box if cover_details.please_comment else unchecked_box} Please Comment", self.checkbox_style),
            Paragraph(f"{checked_box if cover_details.please_reply else unchecked_box} Please Reply", self.checkbox_style)
        ]]
        
        checkbox_table = Table(checkbox_data, colWidths=[1.75*inch, 1.75*inch, 1.75*inch, 1.75*inch])
        checkbox_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 0),
            ('RIGHTPADDING', (0, 0), (-1, -1), 0),
            ('TOPPADDING', (0, 0), (-1, -1), 5),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
        ]))
        
        return checkbox_table
    
    def _create_message_section(self, cover_details: CoverPageDetails) -> list:
        """Create the message section"""
        elements = []
        
        # Comments section
        if cover_details.comments:
            elements.append(Paragraph("COMMENTS:", self.label_style))
            elements.append(Paragraph(cover_details.comments, self.message_style))
            elements.append(Spacer(1, 10))
        
        # Message section
        if cover_details.msg:
            elements.append(Paragraph("MESSAGE:", self.label_style))
            elements.append(Paragraph(cover_details.msg, self.message_style))
            elements.append(Spacer(1, 10))
        
        return elements
    
    def preview_cover_page(self, cover_details: CoverPageDetails, page_count: int = 0) -> str:
        """
        Generate a text preview of the cover page
        
        Args:
            cover_details: Cover page details
            page_count: Number of pages in the fax
            
        Returns:
            str: Text preview of the cover page
        """
        preview = "THE SPINE HOSPITAL LOUISIANA\n"
        preview += "at The NeuroMedical Center\n"
        preview += "=" * 50 + "\n"
        preview += "FAX TRANSMISSION\n"
        preview += "=" * 50 + "\n\n"
        
        # Main information
        preview += f"TO: {cover_details.to or '':<25} FROM: {cover_details.from_field or ''}\n"
        preview += f"FAX: {cover_details.fax or '':<24} PHONE: {cover_details.phone or ''}\n"
        preview += f"PAGES: {page_count + 1} (including this one)    DATE: {cover_details.date or datetime.now().strftime('%m/%d/%Y')}\n"
        preview += f"RE: {cover_details.re or '':<25} CC: {cover_details.cc or ''}\n\n"
        
        # Checkboxes
        preview += "PRIORITY:\n"
        preview += f"{'[X]' if cover_details.urgent else '[ ]'} Urgent    "
        preview += f"{'[X]' if cover_details.for_review else '[ ]'} For Review    "
        preview += f"{'[X]' if cover_details.please_comment else '[ ]'} Please Comment    "
        preview += f"{'[X]' if cover_details.please_reply else '[ ]'} Please Reply\n\n"
        
        # Comments
        if cover_details.comments:
            preview += "COMMENTS:\n"
            preview += f"{cover_details.comments}\n\n"
        
        # Message
        if cover_details.msg:
            preview += "MESSAGE:\n"
            preview += f"{cover_details.msg}\n\n"
        
        return preview
    
    def get_default_cover_details(self) -> CoverPageDetails:
        """
        Get default cover page details with current date
        
        Returns:
            CoverPageDetails: Default cover page details
        """
        return CoverPageDetails(
            date=datetime.now().strftime("%m/%d/%Y"),
            company="The Spine Hospital Louisiana"
        )
    
    def validate_cover_details(self, cover_details: CoverPageDetails) -> list:
        """
        Validate cover page details
        
        Args:
            cover_details: Cover page details to validate
            
        Returns:
            list: List of validation errors
        """
        errors = []
        
        # Check for required fields (basic validation)
        if not cover_details.to and not cover_details.attn:
            errors.append("Either 'To' or 'Attention' field is required")
        
        if not cover_details.from_field:
            errors.append("'From' field is recommended")
        
        # Validate date format if provided
        if cover_details.date:
            try:
                datetime.strptime(cover_details.date, "%m/%d/%Y")
            except ValueError:
                errors.append("Date must be in MM/DD/YYYY format")
        
        return errors

# Utility functions
def create_simple_cover_page(to: str, from_name: str, subject: str = "", 
                           pages: int = 1, output_path: str = None,
                           logo_path: str = None) -> str:
    """
    Create a simple cover page with minimal information
    
    Args:
        to: Recipient name
        from_name: Sender name
        subject: Subject line
        pages: Number of pages
        output_path: Output file path (auto-generated if None)
        logo_path: Path to logo image
        
    Returns:
        str: Path to generated cover page
    """
    if not output_path:
        output_path = f"cover_page_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
    
    cover_details = CoverPageDetails(
        to=to,
        from_field=from_name,
        subject=subject,
        date=datetime.now().strftime("%m/%d/%Y"),
        pages=pages
    )
    
    generator = CoverPageGenerator()
    success = generator.generate_cover_page(cover_details, output_path, pages - 1, logo_path)
    
    if success:
        return output_path
    else:
        raise Exception("Failed to generate cover page")

def get_cover_page_template() -> Dict[str, str]:
    """
    Get a template for cover page fields
    
    Returns:
        dict: Template with field descriptions
    """
    return {
        'to': 'Recipient name or company',
        'attn': 'Attention line (specific person)',
        'from_field': 'Sender name',
        'company': 'Sender company',
        'fax': 'Recipient fax number',
        'phone': 'Sender phone number',
        'date': 'Date (MM/DD/YYYY format)',
        'pages': 'Total number of pages (auto-calculated)',
        'subject': 'Subject line',
        're': 'Reference line',
        'cc': 'Carbon copy recipients',
        'comments': 'Additional comments',
        'msg': 'Main message content',
        'urgent': 'Mark as urgent',
        'for_review': 'Mark for review',
        'please_comment': 'Request comments',
        'please_reply': 'Request reply'
    }
 
# --- END OF FILE: cover_page.py --- 
 
# --- START OF FILE: __init__.py --- 
 
"""
PDF processing package for MCFax Application
"""
 
# --- END OF FILE: __init__.py --- 
 
