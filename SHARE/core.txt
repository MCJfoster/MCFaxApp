# Core Module Files 
# This file contains all Python files from the src/core/ directory 
# Generated by MCFax sharing script 
 
# --- START OF FILE: settings_portable.py --- 
 
"""
Portable Settings Management Module
Handles persistent application configuration for MCFax with portable settings
"""

import json
import logging
import sys
from pathlib import Path
from typing import Dict, Any, Optional
from PyQt6.QtCore import QSettings, QStandardPaths

class SettingsManager:
    """Manages application settings with JSON-based persistence in application folder"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Default settings structure
        self.default_settings = {
            "paths": {
                "temp_folder": "",
                "recent_folders": [],
                "last_export_folder": ""
            },
            "ui": {
                "window_geometry": {
                    "x": 100,
                    "y": 100,
                    "width": 1200,
                    "height": 800
                },
                "splitter_sizes": [600, 400],
                "main_window_maximized": False
            },
            "fax_defaults": {
                "priority": "Medium",
                "max_attempts": 3,
                "retry_interval": 5,
                "sender_name": "",
                "sender_email": "",
                "include_cover_page": True
            },
            "sender_info": {
                "from_name": "",
                "from_company": "The Spine Hospital Louisiana",
                "from_phone": "(225) 906-4805",
                "from_fax": "(225) 763-2085"
            },
            "pdf_settings": {
                "default_redaction_color": "#000000",
                "default_brush_size": 10,
                "auto_save_edits": True,
                "preview_quality": "high",
                "default_zoom_level": 1.0
            },
            "system": {
                "auto_refresh_interval": 5000,
                "enable_folder_monitoring": True,
                "log_level": "INFO",
                "backup_settings": True
            },
            "faxfinder": {
                "host": "",
                "username": "",
                "password": "",
                "use_https": False,
                "auto_submit": False
            },
            "database": {
                "server": "10.70.1.251",
                "database": "MCFAX",
                "username": "SA",
                "password": "Blue$8080"
            }
        }
        
        # Settings file path - portable location
        self.settings_file = self._get_settings_file_path()
        self.backup_file = self.settings_file.with_suffix('.bak')
        
        # Current settings
        self.settings = self.default_settings.copy()
        
        # Load existing settings
        self.load_settings()
        
        # Ensure settings file exists with defaults
        self.ensure_settings_file_exists()
        
        # Ensure application folders exist
        self.ensure_app_folders_exist()
    
    def _get_settings_file_path(self) -> Path:
        """Get the settings file path - use application folder for portability"""
        # Check if running from PyInstaller executable
        if getattr(sys, 'frozen', False):
            # Running from PyInstaller executable
            app_dir = Path(sys.executable).parent
        else:
            # Running from source code
            app_dir = Path(__file__).parent.parent.parent
        
        # Ensure the application directory exists
        app_dir.mkdir(parents=True, exist_ok=True)
        
        return app_dir / "settings.json"
    
    def _get_app_directory(self) -> Path:
        """Get the application directory"""
        if getattr(sys, 'frozen', False):
            # Running from PyInstaller executable
            return Path(sys.executable).parent
        else:
            # Running from source code
            return Path(__file__).parent.parent.parent
    
    def ensure_app_folders_exist(self) -> None:
        """Ensure all required application folders exist"""
        app_dir = self._get_app_directory()
        folders = ['xml', 'processed', 'logs', 'temp', 'assets']
        
        for folder in folders:
            folder_path = app_dir / folder
            folder_path.mkdir(exist_ok=True)
            self.logger.debug(f"Ensured folder exists: {folder_path}")
    
    def load_settings(self) -> bool:
        """Load settings from file"""
        try:
            if self.settings_file.exists():
                with open(self.settings_file, 'r', encoding='utf-8') as f:
                    loaded_settings = json.load(f)
                
                # Merge with defaults to ensure all keys exist
                self.settings = self._merge_settings(self.default_settings, loaded_settings)
                
                self.logger.info(f"Settings loaded from: {self.settings_file}")
                return True
            else:
                self.logger.info("No settings file found, using defaults")
                return False
                
        except Exception as e:
            self.logger.error(f"Error loading settings: {e}")
            
            # Try to load backup
            if self.backup_file.exists():
                try:
                    with open(self.backup_file, 'r', encoding='utf-8') as f:
                        loaded_settings = json.load(f)
                    
                    self.settings = self._merge_settings(self.default_settings, loaded_settings)
                    self.logger.info("Settings restored from backup")
                    return True
                except Exception as backup_error:
                    self.logger.error(f"Error loading backup settings: {backup_error}")
            
            # Fall back to defaults
            self.settings = self.default_settings.copy()
            return False
    
    def save_settings(self) -> bool:
        """Save settings to file"""
        try:
            # Create backup if enabled
            if self.get("system.backup_settings", True) and self.settings_file.exists():
                try:
                    import shutil
                    shutil.copy2(self.settings_file, self.backup_file)
                except Exception as e:
                    self.logger.warning(f"Failed to create settings backup: {e}")
            
            # Save current settings
            with open(self.settings_file, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Settings saved to: {self.settings_file}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error saving settings: {e}")
            return False
    
    def _merge_settings(self, defaults: Dict[str, Any], loaded: Dict[str, Any]) -> Dict[str, Any]:
        """Recursively merge loaded settings with defaults"""
        result = defaults.copy()
        
        for key, value in loaded.items():
            if key in result:
                if isinstance(result[key], dict) and isinstance(value, dict):
                    result[key] = self._merge_settings(result[key], value)
                else:
                    result[key] = value
            else:
                result[key] = value
        
        return result
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get a setting value using dot notation (e.g., 'paths.temp_folder')"""
        try:
            keys = key.split('.')
            value = self.settings
            
            for k in keys:
                value = value[k]
            
            return value
            
        except (KeyError, TypeError):
            return default
    
    def set(self, key: str, value: Any) -> None:
        """Set a setting value using dot notation"""
        keys = key.split('.')
        setting = self.settings
        
        # Navigate to the parent dictionary
        for k in keys[:-1]:
            if k not in setting:
                setting[k] = {}
            setting = setting[k]
        
        # Set the value
        setting[keys[-1]] = value
    
    def get_temp_folder(self) -> Optional[str]:
        """Get the configured temp folder"""
        folder = self.get("paths.temp_folder")
        return folder if folder else None
    
    def set_temp_folder(self, folder_path: str) -> None:
        """Set the temp folder and add to recent folders"""
        self.set("paths.temp_folder", folder_path)
        
        # Add to recent folders
        recent = self.get("paths.recent_folders", [])
        if folder_path in recent:
            recent.remove(folder_path)
        recent.insert(0, folder_path)
        
        # Keep only last 10 recent folders
        self.set("paths.recent_folders", recent[:10])
    
    def get_recent_folders(self) -> list:
        """Get list of recent folders"""
        return self.get("paths.recent_folders", [])
    
    def get_window_geometry(self) -> Dict[str, int]:
        """Get window geometry settings"""
        return self.get("ui.window_geometry", self.default_settings["ui"]["window_geometry"])
    
    def set_window_geometry(self, x: int, y: int, width: int, height: int) -> None:
        """Set window geometry"""
        self.set("ui.window_geometry", {
            "x": x,
            "y": y,
            "width": width,
            "height": height
        })
    
    def get_splitter_sizes(self) -> list:
        """Get splitter sizes"""
        return self.get("ui.splitter_sizes", [600, 400])
    
    def set_splitter_sizes(self, sizes: list) -> None:
        """Set splitter sizes"""
        self.set("ui.splitter_sizes", sizes)
    
    def is_window_maximized(self) -> bool:
        """Check if window should be maximized"""
        return self.get("ui.main_window_maximized", False)
    
    def set_window_maximized(self, maximized: bool) -> None:
        """Set window maximized state"""
        self.set("ui.main_window_maximized", maximized)
    
    def get_fax_defaults(self) -> Dict[str, Any]:
        """Get default fax settings"""
        return self.get("fax_defaults", self.default_settings["fax_defaults"])
    
    def set_fax_default(self, key: str, value: Any) -> None:
        """Set a fax default setting"""
        self.set(f"fax_defaults.{key}", value)
    
    def get_pdf_settings(self) -> Dict[str, Any]:
        """Get PDF editor settings"""
        return self.get("pdf_settings", self.default_settings["pdf_settings"])
    
    def set_pdf_setting(self, key: str, value: Any) -> None:
        """Set a PDF editor setting"""
        self.set(f"pdf_settings.{key}", value)
    
    def get_auto_refresh_interval(self) -> int:
        """Get auto refresh interval in milliseconds"""
        return self.get("system.auto_refresh_interval", 5000)
    
    def set_auto_refresh_interval(self, interval_ms: int) -> None:
        """Set auto refresh interval"""
        self.set("system.auto_refresh_interval", interval_ms)
    
    def is_folder_monitoring_enabled(self) -> bool:
        """Check if folder monitoring is enabled"""
        return self.get("system.enable_folder_monitoring", True)
    
    def set_folder_monitoring_enabled(self, enabled: bool) -> None:
        """Enable/disable folder monitoring"""
        self.set("system.enable_folder_monitoring", enabled)
    
    def get_sender_info(self) -> Dict[str, str]:
        """Get sender information"""
        return self.get("sender_info", self.default_settings["sender_info"])
    
    def set_sender_info(self, from_name: str = None, from_company: str = None, 
                       from_phone: str = None, from_fax: str = None) -> None:
        """Set sender information"""
        if from_name is not None:
            self.set("sender_info.from_name", from_name)
        if from_company is not None:
            self.set("sender_info.from_company", from_company)
        if from_phone is not None:
            self.set("sender_info.from_phone", from_phone)
        if from_fax is not None:
            self.set("sender_info.from_fax", from_fax)
    
    def get_faxfinder_settings(self) -> Dict[str, Any]:
        """Get FaxFinder connection settings"""
        return self.get("faxfinder", self.default_settings["faxfinder"])
    
    def set_faxfinder_settings(self, host: str = None, username: str = None, 
                              password: str = None, use_https: bool = None, 
                              auto_submit: bool = None) -> None:
        """Set FaxFinder connection settings"""
        if host is not None:
            self.set("faxfinder.host", host)
        if username is not None:
            self.set("faxfinder.username", username)
        if password is not None:
            self.set("faxfinder.password", password)
        if use_https is not None:
            self.set("faxfinder.use_https", use_https)
        if auto_submit is not None:
            self.set("faxfinder.auto_submit", auto_submit)
    
    def reset_to_defaults(self) -> None:
        """Reset all settings to defaults"""
        self.settings = self.default_settings.copy()
        self.logger.info("Settings reset to defaults")
    
    def export_settings(self, file_path: str) -> bool:
        """Export settings to a file"""
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Settings exported to: {file_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error exporting settings: {e}")
            return False
    
    def import_settings(self, file_path: str) -> bool:
        """Import settings from a file"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                imported_settings = json.load(f)
            
            # Merge with defaults to ensure all keys exist
            self.settings = self._merge_settings(self.default_settings, imported_settings)
            
            self.logger.info(f"Settings imported from: {file_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error importing settings: {e}")
            return False
    
    def ensure_settings_file_exists(self) -> None:
        """Ensure settings file exists with default values"""
        if not self.settings_file.exists():
            self.logger.info("Creating settings file with default values")
            self.save_settings()
    
    def get_settings_file_path(self) -> str:
        """Get the settings file path as string"""
        return str(self.settings_file)
    
    def __enter__(self):
        """Context manager entry"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit - auto-save settings"""
        self.save_settings()

# Global settings instance
_settings_instance = None

def get_settings() -> SettingsManager:
    """Get the global settings instance"""
    global _settings_instance
    if _settings_instance is None:
        _settings_instance = SettingsManager()
    return _settings_instance

def save_settings() -> bool:
    """Save the global settings"""
    return get_settings().save_settings()
 
# --- END OF FILE: settings_portable.py --- 
 
# --- START OF FILE: folder_watcher.py --- 
 
"""
Folder Monitoring Module (1.1) for MCFax Application
Detects new PDF files in user-specified folder to trigger fax job creation
"""

import os
import time
import logging
from typing import Callable, Optional, List, Set
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileCreatedEvent, FileModifiedEvent

class PDFFileHandler(FileSystemEventHandler):
    """File system event handler for PDF files"""
    
    def __init__(self, callback: Callable[[str], None], 
                 naming_filter: Optional[str] = None,
                 recursive: bool = False):
        """
        Initialize PDF file handler
        
        Args:
            callback: Function to call when PDF is detected
            naming_filter: Optional naming convention filter (e.g., "fax_*.pdf")
            recursive: Whether to monitor subfolders
        """
        super().__init__()
        self.callback = callback
        self.naming_filter = naming_filter
        self.recursive = recursive
        self.processed_files: Set[str] = set()
        self.logger = logging.getLogger(__name__)
        
    def on_created(self, event):
        """Handle file creation events"""
        if not event.is_directory:
            self._handle_file_event(event.src_path, "created")
    
    def on_modified(self, event):
        """Handle file modification events"""
        if not event.is_directory:
            self._handle_file_event(event.src_path, "modified")
    
    def _handle_file_event(self, file_path: str, event_type: str):
        """Process file events for PDF files"""
        try:
            # Check if it's a PDF file
            if not file_path.lower().endswith('.pdf'):
                return
            
            # Avoid processing the same file multiple times
            if file_path in self.processed_files:
                return
            
            # Apply naming filter if specified
            if self.naming_filter and not self._matches_naming_filter(file_path):
                return
            
            # Wait a moment to ensure file is fully written
            time.sleep(0.5)
            
            # Verify file exists and is readable
            if not os.path.exists(file_path):
                return
            
            try:
                # Try to open file to ensure it's not locked
                with open(file_path, 'rb') as f:
                    f.read(1024)  # Read first 1KB to test
            except (IOError, PermissionError):
                self.logger.warning(f"File {file_path} is not ready or locked, skipping")
                return
            
            # Mark as processed and notify callback
            self.processed_files.add(file_path)
            self.logger.info(f"PDF file {event_type}: {file_path}")
            
            # Call the callback function
            self.callback(file_path)
            
        except Exception as e:
            self.logger.error(f"Error processing file event for {file_path}: {e}")
    
    def _matches_naming_filter(self, file_path: str) -> bool:
        """Check if file matches naming convention filter"""
        if not self.naming_filter:
            return True
        
        filename = os.path.basename(file_path)
        
        # Simple wildcard matching
        if '*' in self.naming_filter:
            prefix, suffix = self.naming_filter.split('*', 1)
            return filename.startswith(prefix) and filename.endswith(suffix)
        else:
            return filename == self.naming_filter

class FolderWatcher:
    """
    Folder Monitoring Module (1.1)
    Monitors specified folder for new PDF files and triggers callbacks
    """
    
    def __init__(self):
        """Initialize folder watcher"""
        self.observer: Optional[Observer] = None
        self.watched_folder: Optional[str] = None
        self.recursive: bool = False
        self.naming_filter: Optional[str] = None
        self.callback: Optional[Callable[[str], None]] = None
        self.is_monitoring: bool = False
        self.logger = logging.getLogger(__name__)
        
    def set_folder(self, folder_path: str, recursive: bool = False) -> bool:
        """
        Set the folder to monitor
        
        Args:
            folder_path: Path to folder to monitor
            recursive: Whether to monitor subfolders
            
        Returns:
            bool: True if folder is valid and set successfully
        """
        try:
            # Validate folder path
            if not os.path.exists(folder_path):
                self.logger.error(f"Folder does not exist: {folder_path}")
                return False
            
            if not os.path.isdir(folder_path):
                self.logger.error(f"Path is not a directory: {folder_path}")
                return False
            
            # Stop current monitoring if active
            if self.is_monitoring:
                self.stop_monitoring()
            
            self.watched_folder = os.path.abspath(folder_path)
            self.recursive = recursive
            
            self.logger.info(f"Folder set for monitoring: {self.watched_folder} (recursive: {recursive})")
            return True
            
        except Exception as e:
            self.logger.error(f"Error setting folder: {e}")
            return False
    
    def set_naming_filter(self, filter_pattern: Optional[str]):
        """
        Set naming convention filter for PDF files
        
        Args:
            filter_pattern: Pattern like "fax_*.pdf" or None for no filter
        """
        self.naming_filter = filter_pattern
        if filter_pattern:
            self.logger.info(f"Naming filter set: {filter_pattern}")
        else:
            self.logger.info("Naming filter cleared")
    
    def set_callback(self, callback: Callable[[str], None]):
        """
        Set callback function to be called when PDF is detected
        
        Args:
            callback: Function that takes file path as parameter
        """
        self.callback = callback
        self.logger.info("PDF detection callback set")
    
    def start_monitoring(self) -> bool:
        """
        Start monitoring the specified folder
        
        Returns:
            bool: True if monitoring started successfully
        """
        try:
            if not self.watched_folder:
                self.logger.error("No folder specified for monitoring")
                return False
            
            if not self.callback:
                self.logger.error("No callback function specified")
                return False
            
            if self.is_monitoring:
                self.logger.warning("Already monitoring, stopping previous monitoring")
                self.stop_monitoring()
            
            # Create file handler
            handler = PDFFileHandler(
                callback=self.callback,
                naming_filter=self.naming_filter,
                recursive=self.recursive
            )
            
            # Create and start observer
            self.observer = Observer()
            self.observer.schedule(handler, self.watched_folder, recursive=self.recursive)
            self.observer.start()
            
            self.is_monitoring = True
            self.logger.info(f"Started monitoring folder: {self.watched_folder}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error starting folder monitoring: {e}")
            return False
    
    def stop_monitoring(self):
        """Stop folder monitoring"""
        try:
            if self.observer and self.is_monitoring:
                self.observer.stop()
                self.observer.join(timeout=5)  # Wait up to 5 seconds
                self.observer = None
                self.is_monitoring = False
                self.logger.info("Stopped folder monitoring")
            
        except Exception as e:
            self.logger.error(f"Error stopping folder monitoring: {e}")
    
    def get_status(self) -> dict:
        """
        Get current monitoring status
        
        Returns:
            dict: Status information
        """
        return {
            'is_monitoring': self.is_monitoring,
            'watched_folder': self.watched_folder,
            'recursive': self.recursive,
            'naming_filter': self.naming_filter,
            'has_callback': self.callback is not None
        }
    
    def scan_existing_files(self) -> List[str]:
        """
        Scan for existing PDF files in the monitored folder
        
        Returns:
            list: List of existing PDF file paths
        """
        if not self.watched_folder:
            return []
        
        pdf_files = []
        
        try:
            if self.recursive:
                # Recursive scan
                for root, dirs, files in os.walk(self.watched_folder):
                    for file in files:
                        if file.lower().endswith('.pdf'):
                            file_path = os.path.join(root, file)
                            if not self.naming_filter or self._matches_naming_filter(file_path):
                                pdf_files.append(file_path)
            else:
                # Top-level scan only
                for item in os.listdir(self.watched_folder):
                    item_path = os.path.join(self.watched_folder, item)
                    if os.path.isfile(item_path) and item.lower().endswith('.pdf'):
                        if not self.naming_filter or self._matches_naming_filter(item_path):
                            pdf_files.append(item_path)
            
            self.logger.info(f"Found {len(pdf_files)} existing PDF files")
            return sorted(pdf_files)
            
        except Exception as e:
            self.logger.error(f"Error scanning existing files: {e}")
            return []
    
    def _matches_naming_filter(self, file_path: str) -> bool:
        """Check if file matches naming convention filter"""
        if not self.naming_filter:
            return True
        
        filename = os.path.basename(file_path)
        
        # Simple wildcard matching
        if '*' in self.naming_filter:
            prefix, suffix = self.naming_filter.split('*', 1)
            return filename.startswith(prefix) and filename.endswith(suffix)
        else:
            return filename == self.naming_filter
    
    def __enter__(self):
        """Context manager entry"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.stop_monitoring()

# Utility functions for folder monitoring
def validate_folder_path(folder_path: str) -> tuple[bool, str]:
    """
    Validate folder path for monitoring
    
    Args:
        folder_path: Path to validate
        
    Returns:
        tuple: (is_valid, error_message)
    """
    try:
        if not folder_path or not folder_path.strip():
            return False, "Folder path cannot be empty"
        
        if not os.path.exists(folder_path):
            return False, "Folder does not exist"
        
        if not os.path.isdir(folder_path):
            return False, "Path is not a directory"
        
        # Test read access
        try:
            os.listdir(folder_path)
        except PermissionError:
            return False, "No read permission for folder"
        
        return True, ""
        
    except Exception as e:
        return False, f"Error validating folder: {str(e)}"

def get_folder_info(folder_path: str) -> dict:
    """
    Get information about a folder
    
    Args:
        folder_path: Path to analyze
        
    Returns:
        dict: Folder information
    """
    try:
        if not os.path.exists(folder_path):
            return {'exists': False}
        
        stat = os.stat(folder_path)
        
        # Count PDF files
        pdf_count = 0
        subfolder_count = 0
        
        try:
            for item in os.listdir(folder_path):
                item_path = os.path.join(folder_path, item)
                if os.path.isfile(item_path) and item.lower().endswith('.pdf'):
                    pdf_count += 1
                elif os.path.isdir(item_path):
                    subfolder_count += 1
        except PermissionError:
            pdf_count = -1  # Indicates permission error
            subfolder_count = -1
        
        return {
            'exists': True,
            'path': os.path.abspath(folder_path),
            'size_bytes': stat.st_size,
            'modified_time': stat.st_mtime,
            'pdf_count': pdf_count,
            'subfolder_count': subfolder_count,
            'readable': pdf_count >= 0
        }
        
    except Exception as e:
        return {
            'exists': False,
            'error': str(e)
        }
 
# --- END OF FILE: folder_watcher.py --- 
 
# --- START OF FILE: settings.py --- 
 
"""
Settings Management Module
Handles persistent application configuration for MCFax
"""

import json
import logging
from pathlib import Path
from typing import Dict, Any, Optional
from PyQt6.QtCore import QSettings, QStandardPaths

class SettingsManager:
    """Manages application settings with JSON-based persistence"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Default settings structure
        self.default_settings = {
            "paths": {
                "temp_folder": "",
                "recent_folders": [],
                "last_export_folder": ""
            },
            "ui": {
                "window_geometry": {
                    "x": 100,
                    "y": 100,
                    "width": 1200,
                    "height": 800
                },
                "splitter_sizes": [600, 400],
                "main_window_maximized": False
            },
            "fax_defaults": {
                "priority": "Medium",
                "max_attempts": 3,
                "retry_interval": 5,
                "sender_name": "",
                "sender_email": "",
                "include_cover_page": True
            },
            "sender_info": {
                "from_name": "",
                "from_company": "The Spine Hospital Louisiana",
                "from_phone": "(225) 906-4805",
                "from_fax": "(225) 763-2085"
            },
            "pdf_settings": {
                "default_redaction_color": "#000000",
                "default_brush_size": 10,
                "auto_save_edits": True,
                "preview_quality": "high",
                "default_zoom_level": 1.0
            },
            "system": {
                "auto_refresh_interval": 5000,
                "enable_folder_monitoring": True,
                "log_level": "INFO",
                "backup_settings": True
            },
            "faxfinder": {
                "host": "",
                "username": "",
                "password": "",
                "use_https": False,
                "auto_submit": False
            }
        }
        
        # Settings file path
        self.settings_file = self._get_settings_file_path()
        self.backup_file = self.settings_file.with_suffix('.bak')
        
        # Current settings
        self.settings = self.default_settings.copy()
        
        # Load existing settings
        self.load_settings()
        
        # Ensure settings file exists with defaults
        self.ensure_settings_file_exists()
    
    def _get_settings_file_path(self) -> Path:
        """Get the settings file path"""
        # Use QStandardPaths to get appropriate config directory
        config_dir = Path(QStandardPaths.writableLocation(QStandardPaths.StandardLocation.ConfigLocation))
        app_config_dir = config_dir / "MCFax"
        app_config_dir.mkdir(parents=True, exist_ok=True)
        
        return app_config_dir / "settings.json"
    
    def load_settings(self) -> bool:
        """Load settings from file"""
        try:
            if self.settings_file.exists():
                with open(self.settings_file, 'r', encoding='utf-8') as f:
                    loaded_settings = json.load(f)
                
                # Merge with defaults to ensure all keys exist
                self.settings = self._merge_settings(self.default_settings, loaded_settings)
                
                self.logger.info(f"Settings loaded from: {self.settings_file}")
                return True
            else:
                self.logger.info("No settings file found, using defaults")
                return False
                
        except Exception as e:
            self.logger.error(f"Error loading settings: {e}")
            
            # Try to load backup
            if self.backup_file.exists():
                try:
                    with open(self.backup_file, 'r', encoding='utf-8') as f:
                        loaded_settings = json.load(f)
                    
                    self.settings = self._merge_settings(self.default_settings, loaded_settings)
                    self.logger.info("Settings restored from backup")
                    return True
                except Exception as backup_error:
                    self.logger.error(f"Error loading backup settings: {backup_error}")
            
            # Fall back to defaults
            self.settings = self.default_settings.copy()
            return False
    
    def save_settings(self) -> bool:
        """Save settings to file"""
        try:
            # Create backup if enabled
            if self.get("system.backup_settings", True) and self.settings_file.exists():
                try:
                    import shutil
                    shutil.copy2(self.settings_file, self.backup_file)
                except Exception as e:
                    self.logger.warning(f"Failed to create settings backup: {e}")
            
            # Save current settings
            with open(self.settings_file, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Settings saved to: {self.settings_file}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error saving settings: {e}")
            return False
    
    def _merge_settings(self, defaults: Dict[str, Any], loaded: Dict[str, Any]) -> Dict[str, Any]:
        """Recursively merge loaded settings with defaults"""
        result = defaults.copy()
        
        for key, value in loaded.items():
            if key in result:
                if isinstance(result[key], dict) and isinstance(value, dict):
                    result[key] = self._merge_settings(result[key], value)
                else:
                    result[key] = value
            else:
                result[key] = value
        
        return result
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get a setting value using dot notation (e.g., 'paths.temp_folder')"""
        try:
            keys = key.split('.')
            value = self.settings
            
            for k in keys:
                value = value[k]
            
            return value
            
        except (KeyError, TypeError):
            return default
    
    def set(self, key: str, value: Any) -> None:
        """Set a setting value using dot notation"""
        keys = key.split('.')
        setting = self.settings
        
        # Navigate to the parent dictionary
        for k in keys[:-1]:
            if k not in setting:
                setting[k] = {}
            setting = setting[k]
        
        # Set the value
        setting[keys[-1]] = value
    
    def get_temp_folder(self) -> Optional[str]:
        """Get the configured temp folder"""
        folder = self.get("paths.temp_folder")
        return folder if folder else None
    
    def set_temp_folder(self, folder_path: str) -> None:
        """Set the temp folder and add to recent folders"""
        self.set("paths.temp_folder", folder_path)
        
        # Add to recent folders
        recent = self.get("paths.recent_folders", [])
        if folder_path in recent:
            recent.remove(folder_path)
        recent.insert(0, folder_path)
        
        # Keep only last 10 recent folders
        self.set("paths.recent_folders", recent[:10])
    
    def get_recent_folders(self) -> list:
        """Get list of recent folders"""
        return self.get("paths.recent_folders", [])
    
    def get_window_geometry(self) -> Dict[str, int]:
        """Get window geometry settings"""
        return self.get("ui.window_geometry", self.default_settings["ui"]["window_geometry"])
    
    def set_window_geometry(self, x: int, y: int, width: int, height: int) -> None:
        """Set window geometry"""
        self.set("ui.window_geometry", {
            "x": x,
            "y": y,
            "width": width,
            "height": height
        })
    
    def get_splitter_sizes(self) -> list:
        """Get splitter sizes"""
        return self.get("ui.splitter_sizes", [600, 400])
    
    def set_splitter_sizes(self, sizes: list) -> None:
        """Set splitter sizes"""
        self.set("ui.splitter_sizes", sizes)
    
    def is_window_maximized(self) -> bool:
        """Check if window should be maximized"""
        return self.get("ui.main_window_maximized", False)
    
    def set_window_maximized(self, maximized: bool) -> None:
        """Set window maximized state"""
        self.set("ui.main_window_maximized", maximized)
    
    def get_fax_defaults(self) -> Dict[str, Any]:
        """Get default fax settings"""
        return self.get("fax_defaults", self.default_settings["fax_defaults"])
    
    def set_fax_default(self, key: str, value: Any) -> None:
        """Set a fax default setting"""
        self.set(f"fax_defaults.{key}", value)
    
    def get_pdf_settings(self) -> Dict[str, Any]:
        """Get PDF editor settings"""
        return self.get("pdf_settings", self.default_settings["pdf_settings"])
    
    def set_pdf_setting(self, key: str, value: Any) -> None:
        """Set a PDF editor setting"""
        self.set(f"pdf_settings.{key}", value)
    
    def get_auto_refresh_interval(self) -> int:
        """Get auto refresh interval in milliseconds"""
        return self.get("system.auto_refresh_interval", 5000)
    
    def set_auto_refresh_interval(self, interval_ms: int) -> None:
        """Set auto refresh interval"""
        self.set("system.auto_refresh_interval", interval_ms)
    
    def is_folder_monitoring_enabled(self) -> bool:
        """Check if folder monitoring is enabled"""
        return self.get("system.enable_folder_monitoring", True)
    
    def set_folder_monitoring_enabled(self, enabled: bool) -> None:
        """Enable/disable folder monitoring"""
        self.set("system.enable_folder_monitoring", enabled)
    
    def get_sender_info(self) -> Dict[str, str]:
        """Get sender information"""
        return self.get("sender_info", self.default_settings["sender_info"])
    
    def set_sender_info(self, from_name: str = None, from_company: str = None, 
                       from_phone: str = None, from_fax: str = None) -> None:
        """Set sender information"""
        if from_name is not None:
            self.set("sender_info.from_name", from_name)
        if from_company is not None:
            self.set("sender_info.from_company", from_company)
        if from_phone is not None:
            self.set("sender_info.from_phone", from_phone)
        if from_fax is not None:
            self.set("sender_info.from_fax", from_fax)
    
    def get_faxfinder_settings(self) -> Dict[str, Any]:
        """Get FaxFinder connection settings"""
        return self.get("faxfinder", self.default_settings["faxfinder"])
    
    def set_faxfinder_settings(self, host: str = None, username: str = None, 
                              password: str = None, use_https: bool = None, 
                              auto_submit: bool = None) -> None:
        """Set FaxFinder connection settings"""
        if host is not None:
            self.set("faxfinder.host", host)
        if username is not None:
            self.set("faxfinder.username", username)
        if password is not None:
            self.set("faxfinder.password", password)
        if use_https is not None:
            self.set("faxfinder.use_https", use_https)
        if auto_submit is not None:
            self.set("faxfinder.auto_submit", auto_submit)
    
    def reset_to_defaults(self) -> None:
        """Reset all settings to defaults"""
        self.settings = self.default_settings.copy()
        self.logger.info("Settings reset to defaults")
    
    def export_settings(self, file_path: str) -> bool:
        """Export settings to a file"""
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Settings exported to: {file_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error exporting settings: {e}")
            return False
    
    def import_settings(self, file_path: str) -> bool:
        """Import settings from a file"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                imported_settings = json.load(f)
            
            # Merge with defaults to ensure all keys exist
            self.settings = self._merge_settings(self.default_settings, imported_settings)
            
            self.logger.info(f"Settings imported from: {file_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error importing settings: {e}")
            return False
    
    def ensure_settings_file_exists(self) -> None:
        """Ensure settings file exists with default values"""
        if not self.settings_file.exists():
            self.logger.info("Creating settings file with default values")
            self.save_settings()
    
    def get_settings_file_path(self) -> str:
        """Get the settings file path as string"""
        return str(self.settings_file)
    
    def __enter__(self):
        """Context manager entry"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit - auto-save settings"""
        self.save_settings()

# Global settings instance
_settings_instance = None

def get_settings() -> SettingsManager:
    """Get the global settings instance"""
    global _settings_instance
    if _settings_instance is None:
        _settings_instance = SettingsManager()
    return _settings_instance

def save_settings() -> bool:
    """Save the global settings"""
    return get_settings().save_settings()
 
# --- END OF FILE: settings.py --- 
 
# --- START OF FILE: __init__.py --- 
 
"""
Core module for MCFax Application
Contains business logic and core functionality
"""

from .folder_watcher import FolderWatcher

__all__ = ['FolderWatcher']
 
# --- END OF FILE: __init__.py --- 
 
