# Fax Module Files 
# This file contains all Python files from the src/fax/ directory 
# Generated by MCFax sharing script 
 
# --- START OF FILE: xml_generator.py --- 
 
"""
Fax XML Generator Module
Creates FaxFinder-compliant XML files for fax job submission
"""

import os
import logging
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Optional, Dict, Any
from datetime import datetime
import uuid
import base64

from database.models import FaxJob, Contact, CoverPageDetails

class FaxXMLGenerator:
    """
    Generator for FaxFinder XML job files
    """
    
    def __init__(self):
        """Initialize XML generator"""
        self.logger = logging.getLogger(__name__)
    
    def generate_fax_xml(self, fax_job: FaxJob, contact: Contact, 
                        pdf_file_path: str, output_path: str) -> bool:
        """
        Generate FaxFinder-compliant XML for a fax job (for local storage - no base64)
        
        Args:
            fax_job: FaxJob object with job details
            contact: Contact object with recipient details
            pdf_file_path: Path to the PDF file to fax
            output_path: Path to save the XML file
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Create root element - FaxFinder expects "schedule_fax"
            root = ET.Element("schedule_fax")
            
            # Job identification
            job_id = fax_job.fax_id or str(uuid.uuid4())
            ET.SubElement(root, "JobID").text = str(job_id)
            ET.SubElement(root, "SubmissionTime").text = datetime.now().isoformat()
            
            # Sender information
            sender = ET.SubElement(root, "Sender")
            ET.SubElement(sender, "Name").text = fax_job.sender_name or ""
            if fax_job.sender_email:
                ET.SubElement(sender, "Email").text = fax_job.sender_email
            
            # Recipient information
            recipient = ET.SubElement(root, "Recipient")
            ET.SubElement(recipient, "Name").text = contact.name or ""
            ET.SubElement(recipient, "FaxNumber").text = contact.fax_number or ""
            if contact.organization:
                ET.SubElement(recipient, "Organization").text = contact.organization
            if contact.phone_number:
                ET.SubElement(recipient, "Phone").text = contact.phone_number
            if contact.email:
                ET.SubElement(recipient, "Email").text = contact.email
            
            # Fax settings
            settings = ET.SubElement(root, "Settings")
            ET.SubElement(settings, "Priority").text = fax_job.priority or "Medium"
            ET.SubElement(settings, "MaxAttempts").text = str(fax_job.max_attempts or 3)
            ET.SubElement(settings, "RetryInterval").text = str(fax_job.retry_interval or 5)
            
            # Cover page information
            if fax_job.cover_page_details:
                cover_page = ET.SubElement(root, "CoverPage")
                cover = fax_job.cover_page_details
                
                if cover.to:
                    ET.SubElement(cover_page, "To").text = cover.to
                if cover.attn:
                    ET.SubElement(cover_page, "Attention").text = cover.attn
                if cover.from_field:
                    ET.SubElement(cover_page, "From").text = cover.from_field
                if cover.company:
                    ET.SubElement(cover_page, "Company").text = cover.company
                if cover.subject:
                    ET.SubElement(cover_page, "Subject").text = cover.subject
                if cover.re:
                    ET.SubElement(cover_page, "Reference").text = cover.re
                if cover.cc:
                    ET.SubElement(cover_page, "CC").text = cover.cc
                if cover.comments:
                    ET.SubElement(cover_page, "Comments").text = cover.comments
                if cover.msg:
                    ET.SubElement(cover_page, "Message").text = cover.msg
            
            # Document information
            document = ET.SubElement(root, "Document")
            ET.SubElement(document, "FilePath").text = str(Path(pdf_file_path).resolve())
            ET.SubElement(document, "FileName").text = Path(pdf_file_path).name
            
            # File size
            try:
                file_size = Path(pdf_file_path).stat().st_size
                ET.SubElement(document, "FileSize").text = str(file_size)
            except:
                pass
            
            # Status tracking
            status = ET.SubElement(root, "Status")
            ET.SubElement(status, "State").text = "Pending"
            ET.SubElement(status, "CreatedTime").text = datetime.now().isoformat()
            
            # Ensure XML directory exists relative to current working directory
            xml_dir = Path.cwd() / "xml"
            xml_dir.mkdir(parents=True, exist_ok=True)
            
            # If output_path is just a filename, put it in the xml directory
            output_path_obj = Path(output_path)
            if not output_path_obj.is_absolute() and output_path_obj.parent == Path('.'):
                output_path = xml_dir / output_path_obj.name
            else:
                # Create output directory if needed
                output_dir = Path(output_path).parent
                output_dir.mkdir(parents=True, exist_ok=True)
            
            # Write XML file
            tree = ET.ElementTree(root)
            ET.indent(tree, space="  ", level=0)  # Pretty print
            tree.write(output_path, encoding="utf-8", xml_declaration=True)
            
            self.logger.info(f"Generated fax XML: {output_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error generating fax XML: {e}")
            return False
    
    def generate_simple_xml(self, recipient_fax: str, sender_name: str, 
                          pdf_file_path: str, output_path: str,
                          subject: str = "", priority: str = "Medium") -> bool:
        """
        Generate a simple XML file with minimal information
        
        Args:
            recipient_fax: Recipient fax number
            sender_name: Sender name
            pdf_file_path: Path to PDF file
            output_path: Output XML path
            subject: Optional subject
            priority: Fax priority
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Create root element - FaxFinder expects "schedule_fax"
            root = ET.Element("schedule_fax")
            
            # Basic information
            ET.SubElement(root, "JobID").text = str(uuid.uuid4())
            ET.SubElement(root, "SubmissionTime").text = datetime.now().isoformat()
            
            # Sender
            sender = ET.SubElement(root, "Sender")
            ET.SubElement(sender, "Name").text = sender_name
            
            # Recipient
            recipient = ET.SubElement(root, "Recipient")
            ET.SubElement(recipient, "FaxNumber").text = recipient_fax
            
            # Settings
            settings = ET.SubElement(root, "Settings")
            ET.SubElement(settings, "Priority").text = priority
            ET.SubElement(settings, "MaxAttempts").text = "3"
            ET.SubElement(settings, "RetryInterval").text = "5"
            
            # Cover page (if subject provided)
            if subject:
                cover_page = ET.SubElement(root, "CoverPage")
                ET.SubElement(cover_page, "Subject").text = subject
            
            # Document
            document = ET.SubElement(root, "Document")
            ET.SubElement(document, "FilePath").text = str(Path(pdf_file_path).resolve())
            ET.SubElement(document, "FileName").text = Path(pdf_file_path).name
            
            # Status
            status = ET.SubElement(root, "Status")
            ET.SubElement(status, "State").text = "Pending"
            ET.SubElement(status, "CreatedTime").text = datetime.now().isoformat()
            
            # Create output directory
            output_dir = Path(output_path).parent
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # Write XML
            tree = ET.ElementTree(root)
            ET.indent(tree, space="  ", level=0)
            tree.write(output_path, encoding="utf-8", xml_declaration=True)
            
            self.logger.info(f"Generated simple fax XML: {output_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error generating simple XML: {e}")
            return False
    
    def validate_xml(self, xml_path: str) -> Dict[str, Any]:
        """
        Validate a generated XML file
        
        Args:
            xml_path: Path to XML file
            
        Returns:
            dict: Validation results
        """
        result = {
            'is_valid': True,
            'errors': [],
            'warnings': [],
            'job_id': None,
            'recipient_fax': None,
            'document_path': None
        }
        
        try:
            if not Path(xml_path).exists():
                result['is_valid'] = False
                result['errors'].append("XML file does not exist")
                return result
            
            # Parse XML
            tree = ET.parse(xml_path)
            root = tree.getroot()
            
            if root.tag not in ["FaxJob", "schedule_fax"]:
                result['errors'].append("Root element must be 'schedule_fax' or 'FaxJob'")
                result['is_valid'] = False
            
            # Check required elements
            job_id_elem = root.find("JobID")
            if job_id_elem is not None:
                result['job_id'] = job_id_elem.text
            else:
                result['errors'].append("Missing JobID element")
                result['is_valid'] = False
            
            # Check recipient fax
            recipient = root.find("Recipient")
            if recipient is not None:
                fax_elem = recipient.find("FaxNumber")
                if fax_elem is not None:
                    result['recipient_fax'] = fax_elem.text
                    if not fax_elem.text:
                        result['errors'].append("Recipient fax number is empty")
                        result['is_valid'] = False
                else:
                    result['errors'].append("Missing recipient fax number")
                    result['is_valid'] = False
            else:
                result['errors'].append("Missing Recipient element")
                result['is_valid'] = False
            
            # Check document
            document = root.find("Document")
            if document is not None:
                file_path_elem = document.find("FilePath")
                if file_path_elem is not None:
                    result['document_path'] = file_path_elem.text
                    if not Path(file_path_elem.text).exists():
                        result['warnings'].append("Referenced document file does not exist")
                else:
                    result['errors'].append("Missing document file path")
                    result['is_valid'] = False
            else:
                result['errors'].append("Missing Document element")
                result['is_valid'] = False
            
            # Check sender
            sender = root.find("Sender")
            if sender is None:
                result['warnings'].append("Missing Sender information")
            
        except ET.ParseError as e:
            result['is_valid'] = False
            result['errors'].append(f"XML parsing error: {str(e)}")
        except Exception as e:
            result['is_valid'] = False
            result['errors'].append(f"Validation error: {str(e)}")
        
        return result
    
    def generate_faxfinder_xml(self, fax_job: FaxJob, contact: Contact, 
                              pdf_file_path: str) -> str:
        """
        Generate FaxFinder submission XML with embedded base64 PDF content
        Uses the correct FaxFinder FF240.R1 API format
        
        Args:
            fax_job: FaxJob object with job details
            contact: Contact object with recipient details
            pdf_file_path: Path to the PDF file to fax
            
        Returns:
            str: XML content ready for FaxFinder submission
        """
        try:
            # Read and encode PDF
            with open(pdf_file_path, 'rb') as pdf_file:
                pdf_data = pdf_file.read()
                pdf_base64 = base64.b64encode(pdf_data).decode('utf-8')
            
            # Log PDF processing details
            self.logger.info(f"Processing PDF for FaxFinder submission:")
            self.logger.info(f"  File: {pdf_file_path}")
            self.logger.info(f"  Size: {len(pdf_data)} bytes ({len(pdf_data)/1024/1024:.1f} MB)")
            self.logger.info(f"  Base64 length: {len(pdf_base64)} characters")
            
            # Create root element - FaxFinder expects "schedule_fax"
            root = ET.Element("schedule_fax")
            
            # NOTE: No cover_page section - we use our own cover page generation
            # The PDF already contains the complete document with cover page
            
            # Sender information (FaxFinder format)
            sender = ET.SubElement(root, "sender")
            ET.SubElement(sender, "name").text = fax_job.sender_name or ""
            
            # Add optional sender organization
            if fax_job.cover_page_details and fax_job.cover_page_details.company:
                ET.SubElement(sender, "organization").text = fax_job.cover_page_details.company
            elif hasattr(fax_job, 'sender_organization') and fax_job.sender_organization:
                ET.SubElement(sender, "organization").text = fax_job.sender_organization
            
            # Recipient information (FaxFinder format)
            recipient = ET.SubElement(root, "recipient")
            ET.SubElement(recipient, "name").text = contact.name or ""
            ET.SubElement(recipient, "fax_number").text = contact.fax_number or ""
            
            # Add optional recipient organization
            if contact.organization:
                ET.SubElement(recipient, "organization").text = contact.organization
            
            # Convert priority to number (FaxFinder expects 1-5)
            priority_map = {
                "Low": "1",
                "Below Normal": "2", 
                "Medium": "3",
                "Normal": "3",
                "Above Normal": "4",
                "High": "5"
            }
            priority_text = fax_job.priority or "Medium"
            priority_num = priority_map.get(priority_text, "3")
            ET.SubElement(root, "priority").text = priority_num
            
            # Fax settings (FaxFinder format)
            ET.SubElement(root, "max_tries").text = str(fax_job.max_attempts or 3)
            ET.SubElement(root, "try_interval").text = str(fax_job.retry_interval or 5)
            
            # Attachment with embedded PDF content (FaxFinder format)
            attachment = ET.SubElement(root, "attachment")
            ET.SubElement(attachment, "location").text = "inline"
            
            # Add required attachment filename
            pdf_filename = Path(pdf_file_path).name
            ET.SubElement(attachment, "name").text = pdf_filename
            
            ET.SubElement(attachment, "content_type").text = "application/pdf"
            ET.SubElement(attachment, "content_transfer_encoding").text = "base64"
            
            # Embed base64 PDF content
            content = ET.SubElement(attachment, "content")
            content.text = pdf_base64
            
            # Convert to string
            ET.indent(root, space="  ", level=0)
            xml_content = ET.tostring(root, encoding='unicode')
            
            # Add XML declaration
            full_xml = '<?xml version="1.0" encoding="UTF-8"?>\n' + xml_content
            
            self.logger.info(f"Generated FaxFinder XML with {len(pdf_base64)} character PDF using correct FF240.R1 format")
            return full_xml
            
        except Exception as e:
            self.logger.error(f"Error generating FaxFinder XML: {e}")
            raise
    
    def get_xml_template(self) -> str:
        """
        Get a template XML structure
        
        Returns:
            str: XML template as string
        """
        template = '''<?xml version="1.0" encoding="utf-8"?>
<FaxJob>
  <JobID>{job_id}</JobID>
  <SubmissionTime>{submission_time}</SubmissionTime>
  
  <Sender>
    <Name>{sender_name}</Name>
    <Email>{sender_email}</Email>
  </Sender>
  
  <Recipient>
    <Name>{recipient_name}</Name>
    <FaxNumber>{recipient_fax}</FaxNumber>
    <Organization>{recipient_org}</Organization>
    <Phone>{recipient_phone}</Phone>
    <Email>{recipient_email}</Email>
  </Recipient>
  
  <Settings>
    <Priority>{priority}</Priority>
    <MaxAttempts>{max_attempts}</MaxAttempts>
    <RetryInterval>{retry_interval}</RetryInterval>
  </Settings>
  
  <CoverPage>
    <To>{cover_to}</To>
    <Attention>{cover_attn}</Attention>
    <From>{cover_from}</From>
    <Company>{cover_company}</Company>
    <Subject>{cover_subject}</Subject>
    <Reference>{cover_re}</Reference>
    <CC>{cover_cc}</CC>
    <Comments>{cover_comments}</Comments>
    <Message>{cover_message}</Message>
  </CoverPage>
  
  <Document>
    <FilePath>{document_path}</FilePath>
    <FileName>{document_name}</FileName>
    <FileSize>{document_size}</FileSize>
  </Document>
  
  <Status>
    <State>Pending</State>
    <CreatedTime>{created_time}</CreatedTime>
  </Status>
</FaxJob>'''
        
        return template

# Utility functions
def create_fax_xml(recipient_fax: str, sender_name: str, pdf_path: str, 
                  output_dir: str = "xml") -> str:
    """
    Quick utility to create a fax XML file
    
    Args:
        recipient_fax: Recipient fax number
        sender_name: Sender name
        pdf_path: Path to PDF file
        output_dir: Output directory (defaults to "xml")
        
    Returns:
        str: Path to created XML file
    """
    # Ensure XML directory exists relative to current working directory
    xml_dir = Path.cwd() / output_dir
    xml_dir.mkdir(parents=True, exist_ok=True)
    
    # Generate output filename
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    xml_filename = f"fax_job_{timestamp}.xml"
    xml_path = xml_dir / xml_filename
    
    # Create XML
    generator = FaxXMLGenerator()
    success = generator.generate_simple_xml(
        recipient_fax, sender_name, pdf_path, str(xml_path)
    )
    
    if success:
        return str(xml_path)
    else:
        raise Exception("Failed to generate fax XML")

def validate_fax_xml(xml_path: str) -> bool:
    """
    Quick validation of a fax XML file
    
    Args:
        xml_path: Path to XML file
        
    Returns:
        bool: True if valid, False otherwise
    """
    generator = FaxXMLGenerator()
    result = generator.validate_xml(xml_path)
    return result['is_valid']
 
# --- END OF FILE: xml_generator.py --- 
 
# --- START OF FILE: faxfinder_api.py --- 
 
"""
FaxFinder API Integration Module
Handles communication with MultiTech FaxFinder FF240.R1 Web Services API
"""

import os
import logging
import base64
import requests
from typing import Optional, Dict, Any, List
from datetime import datetime
from requests.auth import HTTPBasicAuth
import xml.etree.ElementTree as ET

class FaxFinderAPI:
    """
    API client for FaxFinder FF240.R1 Web Services
    """
    
    def __init__(self, host: str, username: str, password: str, use_https: bool = False):
        """
        Initialize FaxFinder API client
        
        Args:
            host: FaxFinder IP address or hostname
            username: API username
            password: API password
            use_https: Whether to use HTTPS (default: False for FF240.R1)
        """
        self.host = host
        self.username = username
        self.password = password
        self.use_https = use_https
        self.base_url = f"{'https' if use_https else 'http'}://{host}"
        self.auth = HTTPBasicAuth(username, password)
        self.logger = logging.getLogger(__name__)
        
        # API endpoints
        self.endpoints = {
            'send_fax': '/ffws/v1/ofax',
            'fax_status': '/ffws/v1/ofax/{fax_entry_url}',
            'receive_fax': '/ffws/v1/ifax',
            'fax_list': '/ffws/v1/ofax'
        }
    
    def test_connection(self) -> Dict[str, Any]:
        """
        Test connection to FaxFinder API
        
        Returns:
            dict: Connection test results
        """
        try:
            # Try to get fax list to test connection
            url = f"{self.base_url}{self.endpoints['fax_list']}"
            response = requests.get(url, auth=self.auth, timeout=10)
            
            return {
                'success': True,
                'status_code': response.status_code,
                'response_time': response.elapsed.total_seconds(),
                'message': 'Connection successful' if response.status_code == 200 else f'HTTP {response.status_code}'
            }
            
        except requests.exceptions.ConnectionError:
            return {
                'success': False,
                'error': 'Connection failed - check host and network connectivity'
            }
        except requests.exceptions.Timeout:
            return {
                'success': False,
                'error': 'Connection timeout - check host responsiveness'
            }
        except requests.exceptions.RequestException as e:
            return {
                'success': False,
                'error': f'Request error: {str(e)}'
            }
    
    def submit_fax_job(self, fax_job, contact, pdf_path: str) -> Dict[str, Any]:
        """
        Submit a fax job directly using FaxJob and Contact objects
        
        Args:
            fax_job: FaxJob object with job details
            contact: Contact object with recipient details
            pdf_path: Path to PDF file to send
            
        Returns:
            dict: Send fax results
        """
        try:
            # Import here to avoid circular imports
            from .xml_generator import FaxXMLGenerator
            
            # Generate FaxFinder-compatible XML with embedded PDF
            generator = FaxXMLGenerator()
            xml_content = generator.generate_faxfinder_xml(fax_job, contact, pdf_path)
            
            # Log XML details for debugging
            self.logger.info(f"Submitting to FaxFinder:")
            self.logger.info(f"  URL: {self.base_url}{self.endpoints['send_fax']}")
            self.logger.info(f"  XML length: {len(xml_content)} characters")
            
            # Check if XML contains base64 content (using correct format)
            if '<content>' in xml_content and 'base64' in xml_content:
                # Find the base64 content using the correct format
                start_marker = '<content>'
                end_marker = '</content>'
                start_pos = xml_content.find(start_marker)
                end_pos = xml_content.find(end_marker, start_pos)
                if start_pos != -1 and end_pos != -1:
                    start_pos += len(start_marker)
                    base64_content = xml_content[start_pos:end_pos].strip()
                    self.logger.info(f"  Base64 PDF content: {len(base64_content)} characters")
                    if len(base64_content) > 100:
                        self.logger.info(f"  Base64 sample: {base64_content[:50]}...{base64_content[-50:]}")
                    else:
                        self.logger.warning(f"  Base64 content seems too short: {len(base64_content)} chars")
                else:
                    self.logger.error("  Base64 content markers found but content extraction failed")
            else:
                self.logger.warning("  No base64 content found in XML - this may cause submission failure")
            
            # Send to FaxFinder
            url = f"{self.base_url}{self.endpoints['send_fax']}"
            headers = {
                'Content-Type': 'application/xml',
                'Accept': 'application/xml'
            }
            
            response = requests.post(
                url, 
                data=xml_content, 
                headers=headers, 
                auth=self.auth,
                timeout=30
            )
            
            if response.status_code in [200, 201]:
                # Parse response to get fax_entry_url
                fax_entry_url = self._parse_fax_response(response.text)
                
                return {
                    'success': True,
                    'fax_entry_url': fax_entry_url,
                    'status_code': response.status_code,
                    'response': response.text,
                    'message': 'Fax submitted successfully'
                }
            else:
                return {
                    'success': False,
                    'status_code': response.status_code,
                    'response': response.text,
                    'error': f'HTTP {response.status_code}: {response.text}'
                }
                
        except Exception as e:
            self.logger.error(f"Error submitting fax job: {e}")
            return {
                'success': False,
                'error': f'Submit fax error: {str(e)}'
            }

    def send_fax(self, xml_content: str, pdf_path: str) -> Dict[str, Any]:
        """
        Send a fax using the FaxFinder API
        
        Args:
            xml_content: XML content with fax job details
            pdf_path: Path to PDF file to send
            
        Returns:
            dict: Send fax results
        """
        try:
            # Read and encode PDF
            with open(pdf_path, 'rb') as pdf_file:
                pdf_base64 = base64.b64encode(pdf_file.read()).decode('utf-8')
            
            # Insert base64 PDF into XML
            # This is a simplified approach - in production, you'd want more sophisticated XML handling
            xml_with_pdf = self._insert_pdf_into_xml(xml_content, pdf_base64)
            
            # Send request
            url = f"{self.base_url}{self.endpoints['send_fax']}"
            headers = {
                'Content-Type': 'application/xml',
                'Accept': 'application/xml'
            }
            
            response = requests.post(
                url, 
                data=xml_with_pdf, 
                headers=headers, 
                auth=self.auth,
                timeout=30
            )
            
            if response.status_code == 200:
                # Parse response to get fax_entry_url
                fax_entry_url = self._parse_fax_response(response.text)
                
                return {
                    'success': True,
                    'fax_entry_url': fax_entry_url,
                    'status_code': response.status_code,
                    'response': response.text,
                    'message': 'Fax submitted successfully'
                }
            else:
                return {
                    'success': False,
                    'status_code': response.status_code,
                    'response': response.text,
                    'error': f'HTTP {response.status_code}: {response.text}'
                }
                
        except FileNotFoundError:
            return {
                'success': False,
                'error': f'PDF file not found: {pdf_path}'
            }
        except Exception as e:
            self.logger.error(f"Error sending fax: {e}")
            return {
                'success': False,
                'error': f'Send fax error: {str(e)}'
            }
    
    def get_fax_status(self, fax_entry_url: str) -> Dict[str, Any]:
        """
        Get status of a sent fax
        
        Args:
            fax_entry_url: Fax entry URL returned from send_fax
            
        Returns:
            dict: Fax status information
        """
        try:
            url = f"{self.base_url}{self.endpoints['fax_status'].format(fax_entry_url=fax_entry_url)}"
            response = requests.get(url, auth=self.auth, timeout=10)
            
            if response.status_code == 200:
                status_info = self._parse_status_response(response.text)
                return {
                    'success': True,
                    'status_info': status_info,
                    'raw_response': response.text
                }
            else:
                return {
                    'success': False,
                    'status_code': response.status_code,
                    'error': f'HTTP {response.status_code}: {response.text}'
                }
                
        except Exception as e:
            self.logger.error(f"Error getting fax status: {e}")
            return {
                'success': False,
                'error': f'Status check error: {str(e)}'
            }
    
    def get_received_faxes(self) -> Dict[str, Any]:
        """
        Get list of received faxes
        
        Returns:
            dict: Received fax information
        """
        try:
            url = f"{self.base_url}{self.endpoints['receive_fax']}"
            response = requests.get(url, auth=self.auth, timeout=10)
            
            if response.status_code == 200:
                received_faxes = self._parse_received_faxes(response.text)
                return {
                    'success': True,
                    'received_faxes': received_faxes,
                    'count': len(received_faxes),
                    'raw_response': response.text
                }
            else:
                return {
                    'success': False,
                    'status_code': response.status_code,
                    'error': f'HTTP {response.status_code}: {response.text}'
                }
                
        except Exception as e:
            self.logger.error(f"Error getting received faxes: {e}")
            return {
                'success': False,
                'error': f'Receive fax error: {str(e)}'
            }
    
    def download_received_fax(self, fax_url: str, output_path: str) -> Dict[str, Any]:
        """
        Download a received fax PDF
        
        Args:
            fax_url: URL of the received fax
            output_path: Path to save the downloaded PDF
            
        Returns:
            dict: Download results
        """
        try:
            response = requests.get(fax_url, auth=self.auth, timeout=30)
            
            if response.status_code == 200:
                # Create output directory if needed
                os.makedirs(os.path.dirname(output_path), exist_ok=True)
                
                # Save PDF
                with open(output_path, 'wb') as f:
                    f.write(response.content)
                
                return {
                    'success': True,
                    'output_path': output_path,
                    'file_size': len(response.content),
                    'message': 'Fax downloaded successfully'
                }
            else:
                return {
                    'success': False,
                    'status_code': response.status_code,
                    'error': f'HTTP {response.status_code}: Failed to download fax'
                }
                
        except Exception as e:
            self.logger.error(f"Error downloading fax: {e}")
            return {
                'success': False,
                'error': f'Download error: {str(e)}'
            }
    
    def _insert_pdf_into_xml(self, xml_content: str, pdf_base64: str) -> str:
        """
        Insert base64-encoded PDF into XML content
        
        Args:
            xml_content: Original XML content
            pdf_base64: Base64-encoded PDF data
            
        Returns:
            str: XML with embedded PDF
        """
        try:
            # Parse XML
            root = ET.fromstring(xml_content)
            
            # Find Document element and add PDF data
            document = root.find('Document')
            if document is not None:
                # Add PDF data element
                pdf_data = ET.SubElement(document, 'PDFData')
                pdf_data.text = pdf_base64
                
                # Add encoding attribute
                pdf_data.set('encoding', 'base64')
            
            # Convert back to string
            return ET.tostring(root, encoding='unicode')
            
        except Exception as e:
            self.logger.error(f"Error inserting PDF into XML: {e}")
            # Fallback: simple string replacement (not recommended for production)
            return xml_content.replace('</Document>', f'<PDFData encoding="base64">{pdf_base64}</PDFData></Document>')
    
    def _parse_fax_response(self, response_text: str) -> Optional[str]:
        """
        Parse fax submission response to extract fax_entry_url
        
        Args:
            response_text: XML response from FaxFinder
            
        Returns:
            str: Fax entry URL or None if not found
        """
        try:
            root = ET.fromstring(response_text)
            # Look for fax entry URL in response
            # This depends on the actual FaxFinder response format
            fax_entry = root.find('.//fax_entry_url')
            if fax_entry is not None:
                return fax_entry.text
            
            # Alternative: look for ID or other identifier
            fax_id = root.find('.//id')
            if fax_id is not None:
                return fax_id.text
                
            return None
            
        except Exception as e:
            self.logger.error(f"Error parsing fax response: {e}")
            return None
    
    def _parse_status_response(self, response_text: str) -> Dict[str, Any]:
        """
        Parse fax status response
        
        Args:
            response_text: XML response from FaxFinder
            
        Returns:
            dict: Parsed status information
        """
        try:
            root = ET.fromstring(response_text)
            
            status_info = {
                'status': 'Unknown',
                'pages': 0,
                'attempts': 0,
                'last_attempt': None,
                'completion_time': None
            }
            
            # Extract status information based on FaxFinder response format
            status_elem = root.find('.//status')
            if status_elem is not None:
                status_info['status'] = status_elem.text
            
            pages_elem = root.find('.//pages')
            if pages_elem is not None:
                status_info['pages'] = int(pages_elem.text or 0)
            
            attempts_elem = root.find('.//attempts')
            if attempts_elem is not None:
                status_info['attempts'] = int(attempts_elem.text or 0)
            
            return status_info
            
        except Exception as e:
            self.logger.error(f"Error parsing status response: {e}")
            return {'status': 'Parse Error', 'error': str(e)}
    
    def _parse_received_faxes(self, response_text: str) -> List[Dict[str, Any]]:
        """
        Parse received faxes response
        
        Args:
            response_text: XML response from FaxFinder
            
        Returns:
            list: List of received fax information
        """
        try:
            root = ET.fromstring(response_text)
            received_faxes = []
            
            # Find all fax entries
            for fax_elem in root.findall('.//fax'):
                fax_info = {
                    'id': None,
                    'sender': None,
                    'pages': 0,
                    'received_time': None,
                    'url': None
                }
                
                # Extract fax information
                id_elem = fax_elem.find('id')
                if id_elem is not None:
                    fax_info['id'] = id_elem.text
                
                sender_elem = fax_elem.find('sender')
                if sender_elem is not None:
                    fax_info['sender'] = sender_elem.text
                
                pages_elem = fax_elem.find('pages')
                if pages_elem is not None:
                    fax_info['pages'] = int(pages_elem.text or 0)
                
                time_elem = fax_elem.find('received_time')
                if time_elem is not None:
                    fax_info['received_time'] = time_elem.text
                
                url_elem = fax_elem.find('url')
                if url_elem is not None:
                    fax_info['url'] = url_elem.text
                
                received_faxes.append(fax_info)
            
            return received_faxes
            
        except Exception as e:
            self.logger.error(f"Error parsing received faxes: {e}")
            return []

# Utility functions
def create_api_client(host: str, username: str, password: str) -> FaxFinderAPI:
    """
    Create a FaxFinder API client with standard settings
    
    Args:
        host: FaxFinder IP address
        username: API username
        password: API password
        
    Returns:
        FaxFinderAPI: Configured API client
    """
    return FaxFinderAPI(host, username, password, use_https=False)

def test_api_connection(host: str, username: str, password: str) -> bool:
    """
    Quick test of API connection
    
    Args:
        host: FaxFinder IP address
        username: API username
        password: API password
        
    Returns:
        bool: True if connection successful
    """
    api = create_api_client(host, username, password)
    result = api.test_connection()
    return result['success']
 
# --- END OF FILE: faxfinder_api.py --- 
 
# --- START OF FILE: __init__.py --- 
 
"""
Fax package for MCFax Application
Handles fax job XML generation and submission
"""

from .xml_generator import FaxXMLGenerator, create_fax_xml, validate_fax_xml
from .faxfinder_api import FaxFinderAPI, create_api_client, test_api_connection

__all__ = [
    'FaxXMLGenerator',
    'create_fax_xml', 
    'validate_fax_xml',
    'FaxFinderAPI',
    'create_api_client',
    'test_api_connection'
]
 
# --- END OF FILE: __init__.py --- 
 
